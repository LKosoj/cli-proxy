# Обзор проекта

# Класс `SessionUI`

Класс `SessionUI` обеспечивает пользовательский интерфейс для управления сессиями Telegram-бота. Предоставляет интерактивное меню через `InlineKeyboardMarkup` и обрабатывает действия пользователя, такие как выбор, переименование, обновление resume-токена, проверка состояния и закрытие сессий.

## Основные компоненты
- **`manager`** — управляет активными сессиями, их состоянием и сохранением.
- **`config`** — хранит и сохраняет конфигурацию приложения.
- **`pending_session_rename`**, **`pending_session_resume`** — словари для отслеживания пользователей, ожидающих ввода имени или resume-токена.

## Ключевые методы
- `build_sessions_menu()` — генерирует клавиатуру со списком сессий.
- `handle_callback()` — обрабатывает callback-запросы (выбор, активация, статус, переименование, resume, очистка очереди, закрытие).
- `handle_pending_message()` — обрабатывает текстовые сообщения при ожидании ввода (имя сессии, resume-токен), поддерживает отмену через "отмена", "-", "Отмена".

## Поддерживаемые действия
- Просмотр и редактирование resume-токена (`sess_resume:`).
- Отображение состояния сессии (`sess_state:`).
- Проверка и очистка очереди сообщений (`sess_queue`, `sess_clearqueue`).
- Закрытие сессии с вызовом колбэков `_on_before_close` и `_on_close`.
- Сохранение изменений через `manager._persist_sessions()`.

## Интеграции
- Отправка и редактирование сообщений: `send_message`, `edit_message_text`.
- Форматирование временных меток: `format_ts`.
- Колбэки: `on_close`, `on_before_close` при завершении сессии.

Класс обеспечивает полный цикл управления сессиями с сохранением состояния и реактивным взаимодействием через Telegram-интерфейс.

# Резюме: Telegram-бот для управления CLI-агентами

Telegram-бот предоставляет удобный интерфейс для взаимодействия с CLI-агентами (Codex, Gemini, Qwen, Claude) через Telegram, поддерживая многопользовательские сессии, очереди команд, HTML-вывод и интеграцию с внешними сервисами.

## Основные возможности
- **Управление сессиями**: каждая сессия изолирована в отдельном рабочем каталоге, поддерживается восстановление после перезапуска.
- **Очередь команд**: контроль выполнения, предотвращение перегрузки.
- **HTML-рендеринг**: отображение результата с поддержкой Markdown, ANSI-цветов и mermaid-диаграмм (в SVG).
- **Кэширование**: справка по инструментам сохраняется в `toolhelp.json`.
- **Сохранение состояния**: активные сессии, prompt, resume-токены и пути хранятся в `state.json`.
- **Шаблоны задач**: настройка через `/preset` и секцию `presets` в `config.yaml`.
- **Работа с файлами**: загрузка текстовых файлов до 500 КБ и изображений (с обработкой при наличии `image_cmd`).

## Основные сущности
- **Сессии CLI** — в изолированных каталогах.
- **Очередь запросов** — с контролем занятости.
- **Git-интеграция** — интерактивные операции (`/git`): status, pull, merge, rebase, commit, разрешение конфликтов.
- **Файловый менеджер** — просмотр и отправка файлов через `/files`.
- **Переменные окружения** — подстановка через `${VAR}`, приоритет: `env` в `tools.*` > `config.yaml` > системные переменные.

## Настройки (`config.yaml`)
- `telegram.token`, `whitelist_chat_ids` — авторизация и ограничение доступа.
- `defaults.workdir` — базовый путь для сессий.
- `defaults.log_path` — логирование с ротацией (ошибки в `*_error.log`).
- `image_temp_dir`, `image_max_mb` — обработка изображений.
- `tools.*` — конфигурация агентов: команды, режимы (`yolo`, `--approval-mode`), `resume_cmd`, `image_cmd`, `env`.
- `presets` — шаблоны задач (название + prompt).
- `mcp` — TCP-мост для внешних клиентов.
- Интеграции: `openai_*`, `zai_api_key`, `tavily_api_key`, `jina_api_key`, `github_token`.

## Переменные окружения (приоритет выше config)
- `TAVILY_API_KEY` — для поиска через Tavily.
- `JINA_API_KEY` — для веб-поиска и чтения страниц (Jina.ai).
- `GITHUB_TOKEN` — для аутентификации в Git (HTTPS, без интерактивного ввода).

## Команды
- **Основные (в меню)**: `/new`, `/sessions`, `/interrupt`, `/git`, `/files`, `/tools`, `/toolhelp`.
- **Скрытые**: `/dirs`, `/newpath`, `/use`, `/cwd`, `/setprompt`, `/send`, `/resume`, `/close`, `/status`, `/rename`, `/state`, `/clearqueue`, `/queue`, `/preset`, `/metrics`.
- **Прямой ввод**: через `/send` или префикс `>`.

## Тестирование
- Запуск: `pytest -q`

## Особенности
- Автоопределение prompt и resume-токена.
- Поддержка вложений: текст — до 500 КБ, изображения — с обработкой по подписи.
- Переменные окружения подставляются динамически.

Файл содержит справочную информацию о доступных slash-командах в различных CLI-инструментах, связанных с ИИ-ассистентами (Codex, Claude, Gemini, Qwen). Каждая запись включает название инструмента, тип (`tool`), текстовое описание с перечнем команд и временной меткой обновления. Основное назначение — быстрое ознакомление с функционалом командной строки каждого инструмента. Ключевые сущности: `codex`, `claude`, `gemini`, `qwen`. Важные команды: `/help`, `/status`, `/new`, `/exit`, `/quit`, `/clear`, `/settings`, `/auth`, `/chat`, `/model`, `/mcp`. Для получения справки в большинстве случаев используется `/help` или `/?`.

# Git-бот в Telegram: Краткое резюме

Git-бот предоставляет упрощённый интерфейс для работы с Git через Telegram, позволяя выполнять основные операции без знания командной строки. Бот запускает стандартные git-команды и отображает их результат.

## Основные функции
- **Просмотр состояния**: `Status`, `Log`, `Diff`, `Summary`
- **Синхронизация**: `Fetch`, `Pull` (с `--ff-only` для безопасности)
- **Коммиты и отправка**: `Commit`, `Push`
- **Управление изменениями**: `Stash`
- **Слияние веток**: `Merge`, `Rebase`
- **Работа с конфликтами**: отображение конфликтующих файлов, кнопки `Abort`, `Continue`, `Позвать агента`

## Особенности
- Автоматическое определение upstream-ветки
- Поддержка приватных репозиториев через **Personal Access Token**
- Токен задаётся в `config.yaml` → `defaults.github_token`
- Операции выполняются в очереди при занятой сессии

## Ограничения
- Нет автоматического разрешения конфликтов (требуется ручное редактирование меток `<<<<<<<`, `=======`, `>>>>>>>`)
- Зависимость от текущего состояния репозитория
- Отсутствие "умного" автомержа

## Рекомендации
- Начинайте с команды `Status`
- Избегайте слияний без проверки состояния
- Используйте `Abort` при неуверенности в действиях
- Убедитесь, что репозиторий находится в корректном состоянии перед операциями

# Конфигурационный файл Telegram-бота (YAML)

Конфигурационный файл в формате YAML для централизованной настройки Telegram-бота с поддержкой внешних инструментов, MCP-серверов, пресетов и интеграций.

## Основные секции

- **`telegram`**  
  Параметры подключения к Telegram: `token`, список разрешённых `chat_id`.

- **`tools`**  
  Описание внешних инструментов (команд). Поддержка режимов `headless` и `interactive`, команд, переменных окружения, регулярных выражений для определения приглашений.

- **`defaults`**  
  Глобальные настройки:
  - `workdir` — рабочая директория выполнения команд.
  - Таймауты: `idle_timeout_sec`.
  - Лимиты: `memory_max_kb`, `memory_compact_target_kb`, `output_max_chars`.
  - Пути: `state_file`, `log_file`.
  - API-ключи: OpenAI, ZAI, Tavily, Jina, GitHub.
  - Логирование и уточнения: `clarification_enabled`, `clarification_keywords`.

- **`mcp`**  
  Настройки встроенного MCP-сервера: `enabled`, `host`, `port`, `token`.

- **`mcp_clients`** / **`mcp_servers`**  
  Подключение к внешним MCP-серверам. Поддержка транспорта: `stdio`, `http`. Параметры: `cmd`, `url`, `env`, `headers`, `timeout`.

- **`presets`**  
  Именованные промпты для упрощения взаимодействия.

## Особенности
- Файл загружается и сохраняется через `load_config` / `save_config`.
- Путь к файлу хранится в `path`.
- Поддержка кириллицы: `allow_unicode=False`.
- Обеспечивает гибкую интеграцию с LLM, поисковыми системами и внешними сервисами.

Файл предоставляет функциональность для управления состоянием сессий и активных сессий через чтение/запись JSON-файлов. Основное назначение — хранение и обновление данных о запущенных инструментах (tools), рабочих директориях, токенах возобновления, описаниях сессий и активных состояниях.

Ключевые сущности:
- `SessionState` — данные сохранённой сессии: инструмент, рабочая директория, токен возобновления, сводка, временная метка обновления и необязательное имя.
- `ActiveState` — данные активной сессии: инструмент, рабочая директория, идентификатор сессии и временная метка.

Файл работает с JSON-файлом по указанному пути, где хранит:
- Записи сессий по ключу вида `{tool}::{workdir}`.
- Специальную запись `_active` для хранения активной сессии.
- Специальную запись `_sessions` для хранения дополнительных сессионных данных.

Ключевые функции:
- `load_state`, `save_state` — загрузка и сохранение состояний сессий.
- `update_state`, `get_state`, `delete_state` — управление отдельными сессиями.
- `load_active_state`, `set_active_state`, `clear_active_state` — работа с активной сессией.
- `load_sessions`, `save_sessions` — чтение и запись дополнительных сессионных данных.
- `make_key` — формирование уникального ключа сессии.

Все операции обрабатывают ошибки чтения/записи файлов с логированием, игнорируют отсутствующие файлы и некорректные данные.

Файл определяет реестр команд для бота, возвращая список словарей с описанием каждой команды. Каждая команда содержит имя (`name`), описание (`desc`), ссылку на обработчик (`handler`) и флаг видимости в меню (`menu`). Реестр используется для регистрации доступных команд в интерфейсе бота, включая как пользовательские действия (создание сессий, управление файлами, git-операции), так и служебные функции (метрики, отладка, управление очередями). Ключевые сущности — это обработчики команд из экземпляра `bot_app`, которые привязываются к текстовым командам. Настройка `menu=True` означает, что команда будет отображаться в основном меню бота.

Класс `Metrics` предназначен для сбора и отслеживания метрик работы приложения в режиме реального времени. Основные сущности — счётчики событий и временные отметки. Поддерживает инкремент счётчиков по ключу, фиксацию вывода и формирование текстового снимка состояния. Ключевые счётчики: `messages`, `commands`, `outputs`, `errors`, `queued`. При каждом вызове `observe_output` обновляется количество символов последнего вывода и временная метка. Метод `snapshot` возвращает строку с общим временем работы, значениями счётчиков и информацией о последнем выводе (время, сколько прошло, размер в символах).

Класс `MCPBridge` реализует асинхронный TCP-сервер для взаимодействия с ботом через текстовые JSON-запросы. Сервер ожидает подключений, принимает входящие сообщения, проверяет токен авторизации, выполняет обработку текстового запроса через `bot_app.run_prompt_raw` и возвращает результат. Поддерживает построчную передачу данных, где каждое сообщение завершается символом новой строки.

Ключевые сущности:  
- `config.mcp.enabled` — включение/отключение сервера.  
- `config.mcp.host`, `config.mcp.port` — параметры привязки сервера.  
- `config.mcp.token` — опциональный токен для аутентификации.  

Формат запроса:  
```json
{"token": "токен", "prompt": "текст запроса", "session_id": "идентификатор сессии"}
```

Формат ответа:  
```json
{"ok": true, "output": "результат"}  
{"ok": false, "error": "описание ошибки"}
```

Сервер корректно завершает работу при вызове `stop()`, закрывая все соединения. Ошибки обработки логируются с помощью `logging.exception`.

# Telegram-бот для управления сессиями и агентами

## Назначение
Файл реализует асинхронного Telegram-бота на основе `python-telegram-bot` для управления сессиями, выполнения команд, взаимодействия с агентом, навигации по файловой системе и интеграции с внешними системами (Git, MCP, плагины). Бот поддерживает интерактивный интерфейс, подтверждение действий, песочницу агента и расширенные функции взаимодействия.

## Основные компоненты
- **`BotApp`** — центральный класс, координирующий сессии, команды, интеграции и взаимодействие с Telegram.
- **`SessionManager`** — управление жизненным циклом сессий пользователей.
- **`Session`** — активная сессия с атрибутами: `tool`, `workdir`, `agent_enabled`, `queue`, `busy`, `project_root`.
- **`OrchestratorRunner`** — запуск и контроль агента.
- **`GitOps`** — выполнение Git-операций (клонирование, коммиты и т.д.).
- **`MCPBridge`** — интеграция с внешними сервисами/протоколами.
- **`Metrics`** — сбор и учёт метрик использования (объём вывода, производительность).
- **`SessionUI`, `dirs_ui`** — построение интерактивных интерфейсов (клавиатуры, меню).

## Функциональность
### Управление сессиями
- Создание (`/create`), выбор (`/use`), просмотр (`/sessions`, `/status`), закрытие (`/close`).
- Восстановление сессий, персистентность состояния (`state_path`), таймауты неактивности.
- Проверка безопасности путей (`is_within_root`), защита от выхода за пределы `workdir`.

### Работа с агентом
- Включение/выключение (`/agent`), привязка проекта, очистка песочницы (`AGENT_SANDBOX_ROOT`).
- Выполнение запросов (`run_prompt`, `run_agent`), обработка вывода с аннотациями и ANSI → HTML.
- Буферизация и отправка вывода с метрикой `observe_output`.

### Интерактивный интерфейс
- Поддержка inline-клавиатур: навигация по состояниям, файлам, сессиям, инструментам.
- Пагинация (20 элементов на страницу), просмотр, выбор, удаление файлов (с подтверждением).
- Навигация по каталогам: вверх, ручной ввод пути, создание директорий, `git clone`.

### Обработка ввода
- Приём команд (с префиксом `>`), текста, изображений (до `image_max_mb`), документов (до 500 КБ).
- Буферизация длинных сообщений с автоматической отправкой по таймауту.
- Очередь ввода, отмена, lock-механизмы при занятой сессии.

### Команды и пресеты
- `/preset` — запуск предустановленных команд (`tests`, `lint`, `build`, `refactor`).
- `/toolhelp` — справка по CLI-инструментам с поддержкой ANSI.
- `/metrics` — вывод статистики использования.
- `/tools`, `/new`, `/newpath` — управление инструментами и сессиями.

### Callback-обработка
- Подтверждение команд, ответы на вопросы, управление плагинами.
- Маршрутизация по формату `action:key:values`.
- Поддержка inline-меню: выбор сессии, навигация, настройки.

## Интеграции и расширения
- **Плагины**: поддержка `plugin_commands`, `message_handlers`, `inline_handlers` с изоляцией.
- **Git**: клонирование, коммиты, статус, интеграция в сессии.
- **MCP**: внешняя интеграция через `MCPBridge`.
- **HTML-рендеринг**: преобразование ANSI-вывода в HTML, временные файлы.

## Настройки
- Конфигурация из `config.yaml` (`CONFIG_PATH`), включая:
  - `telegram.whitelist_chat_ids`
  - `defaults.workdir`, `state_path`, `log_path`
  - `summary_max_chars`, `image_max_mb`, `idle_timeout_sec`
- Песочница: `workdir/sandbox`
- Пресеты: `config.presets`

## Логирование и метрики
- Централизованное логирование с `TimedRotatingFileHandler` (03:00 UTC, `backupCount=1`):
  - Общий лог (`log_path`)
  - Ошибки (`error_log_path`)
  - Лог агента (`agent_log_path`)
- Изоляция логгера `agent`, предотвращение дублирования.
- Обработка исключений, сетевых ошибок, логирование в потоках.
- Метрики: объём вывода, время выполнения, активность.

## Запуск и инициализация
- Функция `build_app`:
  - Регистрация обработчиков команд, сообщений, колбэков.
  - Интеграция плагинов с фильтрацией (`_AgentEnabledFilter`).
  - Обработка ошибок через `_on_error`.
- Режим polling, запуск приложения с проверкой доступа (`is_allowed`).

# Резюме модуля

Асинхронный модуль для генерации резюме текста и сообщений коммитов с использованием OpenAI API. Основные функции:

- **Резюмирование текста**:  
  - `summarize_text` — возвращает краткую сводку на русском языке, с акцентом на ключевую информацию из конца текста.  
  - `summarize_text_with_reason` — расширенная версия с возвратом причины при ошибке.  
  - Использует адаптивное определение длины резюме (короткое/среднее/длинное) и ограничение по `max_chars` с пометкой об усечении.  
  - Извлечение финального контекста через `_tail_digest`, очистка текста от CLI-заголовков — `_strip_cli_preamble`.

- **Генерация сообщений коммитов**:  
  - `suggest_commit_message_async` — краткое сообщение (~80 символов).  
  - `suggest_commit_message_detailed_async` — детальное сообщение (заголовок + тело, 3–6 пунктов, упоминание файлов, изменений, статуса тестов).  
  - Возвращает кортеж (заголовок, тело) для детального формата.

**Общие особенности**:
- Поддержка русского языка.
- Асинхронная работа через `_chat_completion_async`.
- Конфигурация: `OPENAI_API_KEY`, `OPENAI_MODEL`, `OPENAI_BASE_URL` (через окружение или `AppConfig`).
- `temperature=0.2` — для стабильности генерации.
- Адаптивный расчёт `max_tokens` в зависимости от входа (до 80 для кратких, 220 для детальных).
- Очистка текста: удаление ANSI-кодов и лишних пробелов (`normalize_text` из `utils`).

**Обработка ошибок**:
- Обрабатываются таймауты, сетевые и статусные ошибки API.
- При сбоях возвращается `None` и краткая причина (до 120 символов, `_compact_reason`).

**Вспомогательные функции**:
- `_length_bucket` — классификация по объёму.
- `_suggest_max_tokens` — расчёт лимита токенов.

# Класс `GitOps` — Работа с Git в Telegram-боте

Класс `GitOps` предоставляет асинхронный интерфейс для выполнения Git-операций через Telegram-бота, интегрированный с системой сессий (`SessionManager`) и поддерживающий интерактивное взаимодействие через inline-кнопки и callback-запросы.

## Основные возможности
- Выполнение Git-команд: `commit`, `fetch`, `pull`, `merge`, `rebase`, `diff`, `log`, `stash`, `push`.
- Интерактивное управление операциями: выбор веток, подтверждение действий, разрешение конфликтов.
- Автоматическое формирование сообщений коммита (с поддержкой OpenAI при наличии API-ключа).
- Отображение статуса репозитория, истории, отставания/опережения относительно upstream.
- Генерация HTML-отчётов и отправка справки из `git.md`.

## Ключевые сущности
- `Session` — активная сессия пользователя.
- `SessionManager` — управление сессиями.
- `config.github_token` — токен для аутентификации в Git (через `GIT_ASKPASS`).
- Внутренние состояния по `chat_id`:  
  - `git_branch_menu`, `git_pending_ref`, `git_pull_target`, `pending_git_commit` — хранение промежуточных данных операций.

## Основные методы
- **`_run_git()`** — асинхронное выполнение Git-команд с перехватом вывода.
- **`git_env()`**, `_ensure_git_askpass()` — безопасная передача токена аутентификации.
- **`build_git_keyboard()`** — построение основного меню и вспомогательных клавиатур (выбор ветки, подтверждение, конфликты).
- **Проверки состояния**:  
  - `ensure_git_session()`, `ensure_git_repo()`, `ensure_git_not_busy()` — валидация окружения и блокировка параллельных операций.
- **Анализ репозитория**:  
  - `_git_current_branch`, `_git_upstream`, `_git_ahead_behind`, `_git_in_progress`, `_git_conflict_files`.
- **Формирование отчётов**:  
  - `_git_status_text`, `_git_commit_context`, `_build_commit_body`, `_sanitize_commit_message`.

## Обработка событий
- `handle_callback()` — обработка inline-действий: `git_status`, `git_fetch`, `git_pull`, `git_help`, `git_confirm_merge` и др.
- `handle_pending_commit_message()` — обработка ввода сообщения коммита, включая отмену и валидацию.
- Поддержка разрешения конфликтов: показ `diff`, вызов агента, продолжение/отмена операции.

## Безопасность и настройки
- Токен GitHub передаётся через временный `GIT_ASKPASS`-скрипт.
- Все операции асинхронны, не блокируют бота.
- Вывод команд обрезается до 4000 символов.
- Временные HTML-файлы удаляются после отправки.
- Кодировка: UTF-8 с игнорированием ошибок декодирования.

## Зависимости
- Git должен быть доступен в `PATH`.
- Требуется `github_token` в конфиге для приватных репозиториев.
- Наличие файлов: `git.md` (справка), права на чтение/запись в рабочей директории.

Файл содержит функции для работы с файловой системой в контексте Telegram-бота, позволяя пользователю навигацию по каталогам через интерфейс с кнопками. Основное назначение — безопасное отображение и выбор директорий с поддержкой пагинации и ограничением доступа к корневому каталогу.

Ключевые сущности: словари `dirs_menu`, `dirs_base`, `dirs_page`, `dirs_root`, хранящие состояние каталогов для каждого `chat_id`; функции `prepare_dirs` и `build_dirs_keyboard` для подготовки списка директорий и построения интерактивной клавиатуры.

Функция `prepare_dirs` проверяет доступ к каталогу, читает поддиректории, сохраняет состояние и возвращает сообщение об ошибке или `None` при успехе. Параметр `allow_empty` позволяет обрабатывать отсутствие подкаталогов без ошибки.

Функция `build_dirs_keyboard` формирует `InlineKeyboardMarkup` с кнопками для выбора каталога, навигации (вверх, назад, далее), а также действиями: использовать текущий каталог, создать каталог, выполнить git clone или ввести путь вручную. Используется пагинация по 10 элементов на страницу. Каждая кнопка генерирует callback-данные для обработки в боте.

Модуль для управления справочной информацией по инструментам (tool help) в формате JSON-файла. Основное назначение — хранение, обновление и чтение описаний инструментов с меткой времени последнего изменения.

Ключевая сущность — `ToolHelpEntry`, dataclass, содержащий поля: `tool` (название инструмента), `content` (текст справки), `updated_at` (временная метка обновления в формате Unix time).

Основные функции:
- `load_toolhelp(path)` — загружает данные из JSON-файла по указанному пути, возвращает словарь `tool_name → ToolHelpEntry`.
- `save_toolhelp(path, data)` — сохраняет словарь с записями в JSON-файл с отступами и поддержкой Unicode.
- `update_toolhelp(path, tool, content)` — добавляет или обновляет запись для инструмента, автоматически устанавливая текущее время как `updated_at`.
- `get_toolhelp(path, tool)` — возвращает объект `ToolHelpEntry` для указанного инструмента или `None`, если не найден.

Файл хранится в формате JSON с ключами: `tool`, `content`, `updated_at`. При отсутствии файла или пустом содержимом возвращается пустой словарь.

Список зависимостей Python-пакетов для реализации Telegram-бота с расширенными функциями обработки текста, поиска, мультимедиа и веб-контента. Основное назначение — поддержка бота, взаимодействующего с OpenAI, выполняющего парсинг веб-страниц, извлечение текста из PDF и видео (YouTube), озвучку текста, конвертацию разметки и поиск информации через DuckDuckGo.

Ключевые сущности:
- `python-telegram-bot` — основа для работы с Telegram API.
- `openai` — интеграция с моделями OpenAI (например, GPT).
- `requests`, `httpx`, `beautifulsoup4`, `trafilatura` — HTTP-запросы и парсинг HTML.
- `pdfminer.six` — извлечение текста из PDF-файлов.
- `youtube-transcript-api` — получение субтитров с YouTube.
- `gTTS` — преобразование текста в речь.
- `markdown-it-py` с плагинами — обработка Markdown и ссылок.
- `duckduckgo-search` — поиск в интернете без использования Google.
- `PyYAML` — работа с YAML-конфигурациями.
- `pexpect` — управление интерактивными процессами.
- `ansi2html` — конвертация ANSI-цветного вывода в HTML.
- `pytest` — тестирование кода.

Важные настройки и версии:
- Зафиксированы версии критичных пакетов (например, `python-telegram-bot==20.7` для совместимости с асинхронным API).
- Для `openai`, `httpx`, `beautifulsoup4`, `trafilatura`, `pdfminer.six` допускаются версии выше указанных — обеспечивается гибкость обновлений при сохранении минимальных требований.

# Резюме: Утилиты обработки текста с ANSI, Markdown и Mermaid

Модуль предоставляет набор вспомогательных функций для преобразования терминального вывода (с ANSI-кодами, Mermaid-диаграммами и служебными метками) в чистый, валидный HTML, готовый к отображению в браузере.

## Основные возможности
- **Обработка ANSI-кодов**:  
  - `strip_ansi()` — удаление ANSI-последовательностей.  
  - `ansi_to_html()` — преобразование ANSI-размеченного текста в HTML с цветами, жирным шрифтом, списками и таблицами.  
  - Цвета (30–37, 90–97) сопоставляются с HTML-цветами через `_ANSI_FG_COLORS`.  
  - Используются регулярные выражения `_ANSI_RE` и `_LOOSE_ANSI_RE`.

- **Поддержка Mermaid**:  
  - `_MERMAID_BLOCK_RE` выделяет блоки Mermaid.  
  - `_render_mermaid_svg()` рендерит диаграммы через внешний сервис [mermaid.ink](https://mermaid.ink).

- **Нормализация текста**:  
  - `normalize_text()` удаляет строки с префиксом `mcp:` (через `_MCP_LINE_RE`) и устраняет дублирование блоков.  
  - `build_preview()` — обрезка текста с пометкой усечения.

- **Работа с HTML и файлами**:  
  - `escape_html_text()` — экранирование HTML-символов.  
  - `make_html_file()` — создание временного HTML-файла.  
  - `is_within_root()` — проверка безопасного пути в файловой системе.

- **Сборка и обработка команд**:  
  - `build_command()` — подстановка значений (`{prompt}`, `{resume}`, `{image}`) в шаблон с фильтрацией неактуальных флагов.  
  - `resolve_env_value()` — раскрытие переменных окружения.

- **Детекция сессий и приглашений**:  
  - `detect_prompt_regex()` — определение приглашения ввода по последним строкам.  
  - `detect_resume_regex()` — поиск идентификаторов сессии (thread_id, conversation_id и др.) по жёстко заданным шаблонам.

## Вспомогательные функции
- `sandbox_*` — работа с путями в песочнице.  
- `_TICK_OR_TIME_RE` — извлечение временных меток.

## Зависимости и особенности
- Модули: `os`, `re`, `html`, `tempfile`.  
- Глобальное состояние (`out`, `fg_color`, `bold`, `open_span`) — требует осторожности при использовании в многопоточной среде.  
- Регулярные выражения и шаблоны частично зашиты в код.

Результат — структурированный HTML с инлайн-стилями, поддержкой цветов, диаграмм и безопасной подстановкой данных.

# Обзор модуля управления сессиями

Модуль реализует асинхронное управление сессиями выполнения внешних инструментов (например, CLI-агентов), поддерживая **headless-** и **интерактивный режимы** работы. Основные компоненты — `Session` и `SessionManager`.

## Основные сущности

### `Session`
Представляет контекст выполнения инструмента. Управляет запуском, вводом/выводом, состоянием и жизненным циклом процесса.

**Ключевые поля:**
- `tool`: конфигурация инструмента (`ToolConfig`)
- `workdir`: рабочая директория
- `child`: `pexpect`-процесс (интерактивный режим)
- `current_proc`: `asyncio.subprocess` (headless-режим)
- `resume_token`: токен для возобновления сессии
- `idle_timeout_sec`: таймаут бездействия
- `agent_memory`, `git_conflict`, `agent_enabled`: состояние агента

**Режимы выполнения:**
- **Headless**: запуск через `asyncio.subprocess`, отслеживание stdout/stderr, принудительное завершение при зависании.
- **Интерактивный**: эмуляция терминала через `pexpect`, синхронизация по `prompt_regex` и `resume_regex`.

**Ключевые методы:**
- `run_prompt()`: точка входа, выбирает режим выполнения
- `_run_headless()`: выполнение без интерактивности с таймаутами
- `_run_interactive()`: интерактивное выполнение с ожиданием приглашения
- `interrupt()`, `close()`: управление завершением

**Особенности:**
- Поддержка передачи изображений (если указано в конфиге)
- Фильтрация ANSI-кодов
- Детекция активности по выводу, токенов продолжения и конфликтов в Git
- Проверка активности процесса через `ps` и PID

### `SessionManager`
Управляет коллекцией сессий: создание, активация, восстановление, сохранение.

**Ключевые методы:**
- `create()`: создаёт новую сессию
- `get()`, `active()`: получение сессии
- `set_active()`: установка активной сессии
- `close()`: закрытие и удаление сессии

**Сериализация:**
- Сессии сохраняются в файл по пути `config.defaults.state_path`
- Сериализуемые данные: ID инструмента, рабочая директория, имя, токен, очередь сообщений, состояние агента, корень проекта
- Восстановление при старте из файла (`_restore_sessions`)
- Ошибки чтения/записи игнорируются

**Уведомления:**
- Колбэк `on_session_change` вызывается при изменении активной сессии (`_fire_session_change`)

## Интеграции и зависимости
- `pexpect`: интерактивные сессии, запуск `run_tool_help`
- `asyncio.subprocess`: headless-режим
- `AppConfig`, `ToolConfig`: конфигурация инструментов и путей
- `get_state`, `save_sessions`: работа с состоянием

## Дополнительные функции
- `run_tool_help`: запуск команды помощи инструмента, возврат вывода или сообщение об отсутствии
- Поддержка `auto_commands` (команды при старте)
- Управление окружением (`env`) и рабочей директорией

Конфигурационный файл для Telegram-бота, интегрированного с различными LLM-инструментами (Codex, Claude, Gemini, Qwen). Определяет параметры подключения к Telegram, настройки инструментов, переменные окружения, режимы работы и поведение бота.

**Telegram**: задаётся токен бота и список разрешённых chat_id для доступа.  
**Инструменты (tools)**: для каждого LLM (codex, claude, gemini, qwen) указаны команды запуска в headless-режиме, интерактивные команды, команды продолжения сессии, шаблоны подстановки (`{prompt}`, `{resume}`, `{image}`), регулярные выражения для извлечения данных (например, thread_id), команды помощи и переменные окружения (ключи API).  
**Defaults**: глобальные настройки — рабочая директория, таймаут бездействия, лимиты вывода, пути к файлам состояния и логов, параметры обработки изображений и памяти, включение уточнений по ключевым словам (например, "уточни", "почему", "где").  
**MCP**: управление MCP-серверами — отключено по умолчанию (локальный сервер на 127.0.0.1:8765), но поддерживается подключение к внешним MCP-серверам через `mcp_servers` (например, context7, notebooklm, chrome-devtools и др.) по HTTP.  
**Presets**: предустановленные команды, такие как запуск тестов и линтера, с готовыми текстами запросов.  

Поддерживает динамическую подстановку API-ключей через переменные окружения, работу с изображениями до 10 МБ, ограничение памяти и автоматическое резюмирование диалогов.

Класс `Dispatcher` отвечает за выбор профиля исполнителя (`ExecutorProfile`) для каждого шага плана (`PlanStep`). На текущий момент поддерживается только один профиль по умолчанию, инициализируемый на основе конфигурации приложения (`AppConfig`) и реестра инструментов (`ToolRegistry`). 

Ключевые сущности:
- `AppConfig` — конфигурация приложения.
- `ToolRegistry` — реестр доступных инструментов.
- `ExecutorProfile` — профиль исполнителя, определяющий поведение при выполнении шага.
- `PlanStep` — шаг плана, для которого выбирается профиль.

Важные настройки:
- Инициализация профиля по умолчанию через `build_default_profile`.
- Логирование инициализации и выбора профиля на уровне `INFO`.

В будущем логику выбора профиля можно расширить в зависимости от типа шага, его параметров или других условий.

Модуль отвечает за управление долговременной памятью проекта с использованием LLM. Содержит две основные функции: `decide_memory_save` — принимает решение о сохранении новой информации во внешнюю память на основе диалога, определяет категорию и форматирует запись; `compress_memory` — сжимает существующую память до заданного лимита по символам, сохраняя приоритетные данные. Используются системные промпты для контроля поведения модели: один для принятия решений о сохранении (возвращается JSON с полями `save`, `category`, `content`), другой — для сжатия памяти с сохранением форматированных записей. Категории имеют иерархию важности: preference > decision > config > agreement. Записи помечаются тегами (PREF, DECISION и др.) и включают временную метку в формате `YYYY-MM-DD HH:MM`. Модуль зависит от `AppConfig` и асинхронного клиента OpenAI.

Модуль предоставляет асинхронные функции для взаимодействия с OpenAI API через `AsyncOpenAI`. Основное назначение — выполнение запросов к модели с использованием настроек из конфигурации приложения.

Ключевые сущности:
- `AppConfig` — объект конфигурации, содержащий параметры по умолчанию.
- `get_openai_config` — извлекает и валидирует параметры OpenAI: API-ключ, модель и базовый URL. Если ключ или модель не заданы, возвращает `None`. Базовый URL по умолчанию — `https://api.openai.com`.
- `build_client` — создаёт асинхронного клиента `AsyncOpenAI` на основе конфигурации. Возвращает кортеж из клиента и имени модели или `None`, если конфигурация неполная.
- `chat_completion` — выполняет запрос к чат-модели с системным и пользовательским сообщениями. Использует фиксированное значение `temperature=0.2`. Возвращает строку с ответом модели или пустую строку при ошибках или отсутствии данных.

Важные настройки:
- `openai_api_key` — обязательный API-ключ.
- `openai_model` — обязательное имя модели (например, `gpt-3.5-turbo`).
- `openai_base_url` — опциональный URL для кастомного эндпоинта (например, при использовании прокси).

# Резюме: Политика безопасности и ограничений

Документ описывает правила безопасного использования вычислительной среды, направленные на предотвращение выполнения ресурсоёмких, опасных или бесполезных операций. Запрещены:

- Бесконечные циклы и тяжёлые вычисления  
- Сетевое сканирование и атаки на сервисы  
- Доступ к чужим данным и системным ресурсам  

Разрешены легальные действия: установка пакетов, запуск скриптов, управление файлами, планирование задач и корректная работа с сетью. Приведены рекомендации по запуску сервисов, использованию инструментов и эффективному расходованию памяти.

Модуль отвечает за построение плана выполнения задачи пользователя в виде последовательности шагов. Использует LLM через системный промпт для генерации структурированного JSON-ответа, описывающего шаги, их типы, зависимости и возможность параллельного выполнения.

Ключевые сущности:
- `PlanStep` — модель шага плана, содержащая идентификатор, заголовок, инструкцию, тип шага (`task` или `ask_user`), зависимости, признак параллельности и данные для уточняющих вопросов.
- `_PLANNER_SYSTEM` — системный промпт, задающий поведение LLM: формат вывода, правила построения плана, условия параллельного выполнения и уточнения у пользователя.
- `plan_steps` — основная асинхронная функция, принимающая конфигурацию, сообщение пользователя и контекст, возвращающая список `PlanStep`.
- `needs_clarification` и `normalize_ask_step` — вспомогательные функции из модулей `heuristics` для определения необходимости уточнения и корректной настройки шагов с вопросами.

Важные настройки и поведение:
- Если LLM возвращает некорректный JSON, используется fallback-план с одним шагом.
- При отсутствии шагов или необходимости уточнения (по эвристике) добавляется шаг `ask_user` с вариантами ответа.
- Идентификаторы шагов гарантируют уникальность через `_ensure_unique_step_ids`, при коллизиях генерируются новые с меткой времени и UUID.
- Поддержка параллельного выполнения: шаги могут быть помечены как `parallelizable` с указанием `parallel_group` и причины, если выполнение безопасно.
- Обработка ответа LLM включает извлечение JSON из текста (с удалением Markdown-разметки и поиска объекта между `{}`).

Используется в цепочке обработки запроса для декомпозиции задачи перед передачей исполнителю.

Файл предоставляет функции для работы с локальным файлом памяти `MEMORY.md`, используемым для хранения временных записей в формате Markdown. Основное назначение — ведение журнала событий с поддержкой тегов, дедупликацией, компрессией по приоритету и ограничением по размеру.  

Ключевые сущности:  
- `MEMORY.md` — файл, хранящий записи в формате `- ГГГГ-ММ-ДД ЧЧ:ММ: [ТЕГ] Текст`.  
- Регулярное выражение `_ENTRY_RE` — парсит записи, извлекая метку времени, тег и текст.  
- Функции `read_memory`, `write_memory`, `append_memory` — чтение, запись и добавление содержимого.  
- `append_memory_tagged` — добавляет запись с тегом, избегая дубликатов (сравнение по нормализованному тексту и тегу).  
- `parse_entries` — разбирает содержимое на структурированные записи.  
- `compact_memory_by_priority` — сжимает память по заданному лимиту в байтах, сохраняя записи в порядке приоритета тегов.  
- `trim_for_context` — обрезает текст по количеству символов с пометкой о тримировании.  
- `memory_size_bytes` — возвращает размер содержимого в байтах.  

Важные настройки:  
- `max_chars=2000` в `trim_for_context` — ограничение на длину контекста.  
- `max_bytes` в `compact_memory_by_priority` — лимит размера памяти при компрессии.  
- `priority` — список тегов, определяющий порядок сохранения записей при сжатии.  

Функции работают с указанием рабочей директории (`cwd`), что позволяет использовать изолированные файлы памяти.

Модуль предоставляет потокобезопасные операции чтения и записи JSON-файлов с использованием системных блокировок. Основное назначение — обеспечение целостности данных при одновременном доступе к файлу из нескольких процессов.

Ключевые функции:
- `read_json_locked` — читает JSON-файл под общей (shared) блокировкой, возвращает содержимое как словарь. При отсутствии файла, ошибке парсинга или пустом содержимом возвращает значение по умолчанию.
- `write_json_locked` — записывает словарь в JSON-файл под эксклюзивной (exclusive) блокировкой с полной перезаписью содержимого.
- `update_json_locked` — выполняет атомарное чтение, модификацию и запись JSON-файла под эксклюзивной блокировкой. Принимает функцию `updater`, которая преобразует текущие данные и возвращает новые.

Все функции автоматически создают родительские директории пути при необходимости. Используется буферизация и синхронизация (`os.fsync`) для надежности записи на диск. Файлы открываются в режиме `a+`, что гарантирует создание файла, если он отсутствует.

Модуль определяет структуры данных для планирования и выполнения задач в системе исполнения. Основные сущности — `PlanStep`, `ExecutorRequest` и `ExecutorResponse`.

`PlanStep` описывает шаг в плане выполнения: уникальный идентификатор, заголовок, инструкцию, тип шага, группу для параллельного выполнения, зависимости, признак параллелизма и дополнительные параметры (инструменты, вопросы с вариантами ответов). Зависимости (`depends_on`) обеспечивают корректное упорядочивание при параллельном выполнении.

`ExecutorRequest` представляет входные данные для исполнителя: идентификатор задачи, цель, контекст, входные параметры, ограничения, разрешённые инструменты, ожидаемые выходы, дедлайн и профиль исполнения. Поле `corr_id` может использоваться для корреляции запросов.

`ExecutorResponse` — ответ от исполнителя: статус выполнения (одно из: `ok`, `needs_input`, `error`, `timeout`, `blocked`, `partial`), краткое резюме, список выходов, вызовы инструментов и следующие вопросы (если требуется ввод).

Функции `validate_request` и `validate_response` обеспечивают базовую валидацию обязательных полей и допустимых значений.

Модуль предоставляет основные компоненты для работы агента: ядро исполнения, реестр инструментов и вспомогательные функции для выполнения команд. Включает класс `AgentRunner` для управления жизненным циклом агента, `ToolRegistry` для регистрации и управления инструментами, а также функции `execute_shell_command`, `pop_pending_command` и `set_approval_callback` для взаимодействия с командами оболочки и обработки подтверждений. Основное назначение — объединение логики исполнения и инструментария в единую точку доступа.

# ReAct Агент — Краткое резюме

## Назначение
Файл реализует ReAct-агента (Reasoning + Action), взаимодействующего с OpenAI API для выполнения задач с использованием инструментов, управления памятью, чат-историей и поддержкой песочницы. Агент способен рассуждать, вызывать инструменты, отслеживать контекст и сохранять состояние между сессиями.

## Основные компоненты
- **`ReActAgent`** — основной класс, управляющий циклом рассуждений и действий, вызовом инструментов и обработкой ограничений.
- **`AgentRunner`** — фасад для запуска агента, проверяющий конфигурацию и возвращающий результат выполнения.
- **`AgentRunResult`** — результат выполнения: `output`, `status`, `tool_calls`.
- **`PluginToolRegistry`** — реестр инструментов, обеспечивающий их вызов и фильтрацию по `allowed_tools`.

## Управление состоянием
- **Сессии**: хранятся в `SESSION.json` в изолированной директории (`_sandbox`), восстанавливаются/сохраняются с блокировкой (`read_json_locked`/`write_json_locked`).
- **История**: разделена по `task_id` (`history_by_task`), поддерживается миграция старых данных.
- **Память**: хранится в `MEMORY.md`, ограничена по размеру (`MAX_MEMORY_CHARS`), включается в промпт.
- **Чат**: история ограничена `MAX_CHAT_MESSAGES`, сохраняется через `save_chat_message`.

## Конфигурация
- **OpenAI**: `OPENAI_API_KEY`, `OPENAI_MODEL`, `OPENAI_BASE_URL` — настраиваются через переменные окружения или `AppConfig`.
- **Пути**: `_shared_dir`, `_chats_dir` — определяются на основе `AGENT_SANDBOX_ROOT`.
- **Ограничения**:
  - `AGENT_MAX_ITERATIONS` — макс. число итераций.
  - `AGENT_MAX_BLOCKED` — порог блокировок до остановки.
  - `AGENT_MAX_HISTORY` — макс. длина истории.

## Системный промпт
Динамически формируется из `system.txt` с подстановкой:
- `{{cwd}}`, `{{date}}`, `{{tools}}`, `{{userPorts}}`
- Содержимое памяти, история чата, контекст (`request_context`, `constraints`, `corr_id`)

## Особенности
- Поддержка `tool_choice="auto"` — модель решает, когда вызывать инструменты.
- Обработка ошибок парсинга аргументов инструментов с попыткой восстановления.
- Блокировка команд через префикс `BLOCKED:`, с предупреждением агенту.
- Логирование через `log_global` — отладка, аудит, трассировка итераций.
- Фильтрация инструментов по `allowed_tools` — безопасность и контроль.

## Статусы выполнения
- `ok` — успешно
- `error` — ошибка (некорректная конфигурация, неизвестный инструмент)
- `blocked` — превышено число заблокированных действий
- `partial` — частичный успех инструментов
- `timeout` — достигнут лимит итераций

## Назначение классов
| Класс | Назначение |
|------|-----------|
| `ReActAgent` | Основная логика агента: цикл ReAct, вызов инструментов, обработка блокировок |
| `AgentRunner` | Точка входа, проверка конфигурации, запуск агента |
| `PluginToolRegistry` | Регистрация и выполнение инструментов |

Файл содержит вспомогательные функции для обработки шагов планирования и определения необходимости уточнения входного запроса. Основная логика построена на анализе текста и конфигурации приложения.

Функция `needs_clarification` проверяет, требует ли текст уточнения, на основе наличия вопросительного знака или ключевых слов из конфигурации (`clarification_keywords`). Проверка активируется только при включённой опции `clarification_enabled` в `AppConfig`.

Функция `normalize_ask_step` нормализует объект `PlanStep`, устанавливая значения по умолчанию для полей `ask_question` и `ask_options`, если они не заданы или содержат недостаточно вариантов ответа.

Ключевые сущности: `AppConfig`, `PlanStep`.  
Важные настройки: `clarification_enabled`, `clarification_keywords` — определяют поведение механизма уточнения.

# Оркестратор выполнения задач — Краткое резюме

## Назначение
Файл реализует оркестратор задач, управляющий пошаговым выполнением на основе пользовательского ввода, планирования, исполнения и взаимодействия с инструментами. Центральная логика сосредоточена в классе `OrchestratorRunner`.

## Ключевые сущности
- **`OrchestratorRunner`** — основной класс, управляющий жизненным циклом задачи: планирование, выполнение, состояние.
- **`PlanStep`** — шаг плана с полями: `id`, `instruction`, `depends_on`, `parallelizable`, `parallel_group`, `step_type`, `ask_question`.
- **`Executor` / `Dispatcher`** — компоненты для выполнения шагов и маршрутизации инструментов.
- **`ExecutorRequest` / `ExecutorResponse`** — интерфейс взаимодействия с исполнителем.
- **`profile`** — конфигурация профиля (инструменты, настройки).

## Основные функции и методы
- **`plan_steps`** — генерация плана на основе контекста и запроса.
- **`_order_steps_safely`** — валидация и упорядочивание шагов, проверка зависимостей.
- **`_next_batch`** — определение следующей группы исполняемых шагов с поддержкой параллелизма (по `parallel_group` и `parallelizable`).
- **`_execute_step`** — запуск шага, обработка ответов, запросов к пользователю.
- **`_apply_step_result`** — обновление статусов выполнения шагов.
- **`_maybe_update_memory`** — управление памятью: сохранение, сжатие (LLM или по приоритетам), ограничение размера.

## Хранение и безопасность
- **`SESSION.json`** — хранение истории сессий (макс. 50 записей).
- **Память** — текстовый файл в `cwd`, ограничен `memory_max_kb`, сжимается до `memory_compact_target_kb`.
- **Потокобезопасность** — блокирующие операции (`read_json_locked`, `update_json_locked`).
- **Логирование** — через `self._log`, с корреляцией `corr_id = {session.id}:{step.id}`.

## Настройки и ограничения
- `replan_count`: макс. 2 перепланирования (на уточнения от пользователя).
- `max_chars=2000`: лимит контекста памяти.
- `max_items=50`: макс. число записей в истории.
- Параллельное выполнение — только для безопасных операций (чтение), если `parallelizable_reason` не содержит "read" — запрещено для записи/редактирования.

## Особенности поведения
- Динамическое выполнение графа с зависимостями (`depends_on`).
- При `ask_user` — запрос уточнения и возможное перепланирование.
- Статусы: `"ok"`, `"partial"` — успех; `"blocked"` — ошибка зависимостей или циклов.
- Стабильный порядок выполнения по исходному `order`.
- Интеграция: `record_message`, `resolve_question`, `clear_session_cache`, `get_plugin_commands`, `get_plugin_ui`.

Определяет профиль исполнителя (`ExecutorProfile`) для управления доступом к инструментам и настройками выполнения.  
Ключевая сущность — `ExecutorProfile`, представляющая конфигурацию с именем, списком разрешённых инструментов, таймаутом (в миллисекундах) и максимальным числом попыток.  
По умолчанию создаётся профиль "default" через функцию `build_default_profile`, который включает все доступные инструменты из `ToolRegistry`.  
Использует настройки приложения (`AppConfig`) и реестр инструментов для формирования профиля.

Класс `Executor` отвечает за выполнение задач агента в изолированной среде с поддержкой инструментов, обработкой ошибок и повторными попытками. Основан на `AgentRunner` и использует `ToolRegistry` для управления доступными инструментами. Поддерживает диалог с пользователем через `ask_user`, обработку таймаутов и временных сбоев с экспоненциальным отступом.

Ключевые сущности:
- `ExecutorRequest` / `ExecutorResponse` — валидируемые входные и выходные данные.
- `ExecutorProfile` — определяет политики выполнения: `allowed_tools`, `max_retries`, `timeout_ms`.
- `ToolRegistry` — предоставляет и выполняет инструменты, включая `ask_user`.
- `AgentRunner` — непосредственно запускает логику агента (ReAct).

Важные настройки:
- `workdir` в конфиге — корневая директория для песочниц.
- `session_workspace` — изолированная директория на сессию.
- `max_retries` и `timeout_ms` из профиля — контроль устойчивости и времени выполнения.
- Обработка `asyncio.TimeoutError`, `ConnectionError` и подобных как временных ошибок.
- Логирование с привязкой к `corr_id` и замером времени выполнения.

Методы управления:
- `record_message`, `resolve_question`, `clear_session_cache` — работа с состоянием сессии.
- `get_plugin_commands`, `get_plugin_ui` — интеграция с интерфейсом бота через разрешённые инструменты.

# Конфигурация фильтрации команд — краткое резюме

Конфигурационный файл предназначен для **детектирования и блокировки потенциально опасных команд** в shell-окружениях, CI/CD-пайплайнах и изолированных средах выполнения. Основная цель — **предотвращение утечек секретов, экзфильтрации данных, повышения привилегий, обхода изоляции и выполнения вредоносных операций**.

## Основные категории угроз
- `env_leak` — утечка переменных окружения (`env`, `printenv`, `$SECRET`).
- `sensitive_files` — чтение конфиденциальных файлов (`.env`, `id_rsa`, `.pem`, `credentials`).
- `docker_secrets` — доступ к `/run/secrets`, `/var/run/secrets`.
- `exfiltration` — кодирование и передача данных (`base64`, `openssl`, `curl`, `nc`, DNS-экстракция).
- `code_env_access` — доступ к секретам через код (Python: `os.environ`, `dotenv`, `open`).
- `network_scan` — сканирование сети (`nmap`, `masscan`, `zmap`).
- `dos` — ресурсоёмкие команды (`dd`, `yes`, `fallocate`, бесконечные циклы, Python-вычисления).
- `crypto_mining` — запуск майнеров (`xmrig`, `minerd`).
- `process_kill` — принудительное завершение процессов (`kill -9`, `xkill`).
- `privilege` — попытки повышения привилегий (`sudo`, `apt`, `chroot`).
- `escape` — побег из контейнера (`docker`, `nsenter`, `unshare`, `/proc`).
- `cloud` — доступ к метаданным облака (169.254.169.254, `curl` к внутренним сервисам).
- `obfuscation` — обфускация команд (`chr()`, `reversed`, `IFS`, hex-кодирование).
- `filter_bypass` — обход фильтров (`/dev/tcp`, ANSI-C quoting, brace expansion).
- `code_execution` — выполнение кода (`exec`, `eval`, `importlib`, `LD_PRELOAD`).
- `recon` — разведка (`dig`, `nslookup`, `host`).
- `attack_tool` — использование инструментов атак (SQLmap, Metasploit, Cobalt Strike).
- `persistent` — создание персистентности (`crontab`, `systemctl`).
- `large_install` — установка тяжёлых пакетов (TensorFlow, PyTorch, Go, Rust).
- `dangerous_download` — загрузка и выполнение скриптов (`curl | bash`).
- `cross-user` — доступ к чужим рабочим областям (`../`, `/workspace`, `_shared/`).

## Ключевые параметры правил
- `id` — уникальный идентификатор правила.
- `category` — тип угрозы.
- `pattern` — регулярное выражение для сопоставления.
- `flags` — флаги (например, `i` — регистронезависимость).
- `reason` — пояснение блокировки.

## Назначение
Обеспечение безопасности, стабильности и контролируемости среды выполнения за счёт централизованного управления запрещёнными паттернами. Используется в secure shell, песочницах, CI/CD и облачных платформах.

Модуль реализует загрузчик плагинов `PluginLoader` для динамической подгрузки классов, наследующих `ToolPlugin`, из Python-файлов в указанной директории. Основная цель — обнаружение и инициализация плагинов, исключая системные и базовые файлы (`__init__.py`, `base.py`). Поддерживаются только `.py` файлы, из которых загружаются модули через `importlib.util`. Классы плагинов должны быть унаследованы от `ToolPlugin` и не совпадать с ним напрямую. Экземпляры успешно загруженных классов добавляются в результирующий список. Ошибки при загрузке модулей или инициализации плагинов логируются с помощью `logging.exception`. Важные настройки: путь к директории с плагинами, исключённые файлы, безопасная загрузка модулей с регистрацией в `sys.modules`.

# Резюме: Назначение и функциональность файла

Файл предназначен для безопасного выполнения shell-команд и обработки внешних запросов в изолированном рабочем окружении. Обеспечивает контроль доступа, защиту от утечек данных, проверку соответствия политикам безопасности и интеграцию с внешними сервисами.

## Основные функции
- **Выполнение команд**: `execute_shell_command` с таймаутами, обрезкой вывода и очисткой ANSI-кодов.
- **Проверка безопасности**: 
  - Блокировка опасных паттернов (`check_command`, `BLOCKED_PATTERNS_PATH`).
  - Защита от выхода за пределы рабочей директории (`_check_workspace_isolation`, `_resolve_within_workspace`).
  - Обнаружение чувствительных файлов и данных (`_is_sensitive_file`, `_contains_dangerous_code`).
- **Поддержка утверждений**: Хранение ожидающих команд (`PendingCommand`, `_PENDING_COMMANDS`) и callback-уведомления (`set_approval_callback`).

## Интеграции и внешние сервисы
- **Веб-поиск**: `search_web_impl` с поддержкой Tavily, Jina, Z.AI и прокси.
- **Извлечение контента**: `fetch_page_impl` с резервным переключением между сервисами, возврат в формате Markdown.
- **Безопасность HTTP-запросов**: Блокировка метаданных облаков (AWS/GCP/Azure), таймауты (`WEB_FETCH_TIMEOUT_MS`), прокси (`PROXY_URL`).

## Настройки и параметры
- **Таймауты**: `GREP_TIMEOUT_MS`, `TOOL_TIMEOUT_MS`, `WEB_FETCH_TIMEOUT_MS`.
- **Ограничение вывода**: `OUTPUT_TRIM_LEN`, `OUTPUT_HEAD_LEN`, `OUTPUT_TAIL_LEN`.
- **Чувствительные данные**: `SENSITIVE_FILES`, `SENSITIVE_PATTERNS`.
- **Ключи API**: `TAVILY_API_KEY`, `JINA_API_KEY`, `ZAI_API_KEY`.

## Особенности
- Возвращает структурированные ответы (`success`, `error`, `output`).
- Использует логирование для отладки и отказоустойчивости.
- Поддерживает фоновые процессы и резервные стратегии при ошибках.
- Результаты веб-запросов сохраняются в Markdown (например, `MEMORY.md`).

**Цель**: Обеспечить безопасную, контролируемую и отказоустойчивую работу с командной строкой и внешними ресурсами в изолированной среде.

# Краткое резюме

Данный документ представляет собой техническую документацию, объединяющую несколько частей, описывающих архитектуру, функциональность и использование системы. В документации рассматриваются основные компоненты системы, их взаимодействие, интерфейсы и процессы. Описаны требования, принципы работы, примеры использования и рекомендации по интеграции. Документ предназначен для разработчиков, инженеров и технических специалистов, обеспечивающих развертывание и сопровождение решения.

Определяет структуры данных для описания и ответа инструментов (tools) в системе взаимодействия с ИИ-моделями.  

`ToolSpec` описывает спецификацию инструмента: имя, описание, параметры в формате JSON Schema, таймаут выполнения (по умолчанию 120 секунд), уровень риска (`low` по умолчанию), необходимость подтверждения (`requires_approval`), теги и возможность параллельного выполнения (`parallelizable`). Поддерживает преобразование в форматы OpenAI и Google через методы `to_openai_tool` и `to_google_tool`.  

`ToolResponse` представляет ответ от инструмента: флаг успеха, опциональный вывод, сообщение об ошибке и дополнительные метаданные.  

Используется для стандартизации описания и обработки внешних инструментов в AI-агентах.

# ToolRegistry — Реестр инструментов и менеджер плагинов

Класс `ToolRegistry` обеспечивает централизованное управление инструментами (плагинами) для агента, включая их регистрацию, хранение, валидацию, выполнение и доступ. Поддерживает локальные плагины, удалённые MCP-инструменты (Model Control Protocol), а также генерацию совместимых спецификаций для ИИ-моделей (OpenAI, Google).

## Основные функции

- **Регистрация и загрузка**:
  - `_load_plugins`: загружает локальные плагины из директории `plugins`.
  - `ensure_mcp_loaded`: асинхронно обнаруживает и кэширует MCP-инструменты.
  - `register`: регистрирует плагин с проверкой уникальности имени и валидацией параметров.

- **Доступ к инструментам**:
  - `get_definitions`: возвращает спецификации инструментов в формате OpenAI/Google.
  - `get_plugin_commands`: извлекает команды плагинов с проверкой уникальности.
  - `_filter_allowed`: фильтрует инструменты по списку `allowed_tools` (`"All"`, `"None"`).

- **Выполнение и управление**:
  - `execute`, `execute_many`: запуск инструментов с таймаутом (`TOOL_TIMEOUT_MS`) и обработкой ошибок.
  - `execute_parallel_or_sequential`: определяет режим выполнения (параллельно/последовательно) на основе флага `parallelizable`.
  - `any_awaiting_input`, `cancel_all_inputs`: управление состоянием ожидания ввода.

- **Интерфейс и обработчики**:
  - `build_bot_commands`, `build_bot_ui`: формируют команды и UI-элементы бота.
  - `get_message_handlers`, `get_inline_handlers`: собирают обработчики сообщений и inline-запросов.
  - Поддержка callback-обработчиков через `callback_query_handler`.

- **Валидация и нормализация**:
  - `_validate_and_normalize_command`, `_validate_and_normalize_handler`: проверяют и дополняют метаданные.
  - `_validate_args`: валидация аргументов по JSON-схеме из `ToolSpec`.

## Состояние и сервисы

Плагины получают доступ к общим сервисам через `services`:
- `pending_questions`, `recent_messages`, `task_store`, `scheduler_tasks`, `user_tasks`.

## Важные компоненты

- `MCPManager`: управление MCP-серверами и кэширование инструментов.
- `PluginLoader`: загрузка локальных плагинов.
- `MCPRemoteToolPlugin`: представление удалённых MCP-инструментов.

## Настройки и поведение

- `TOOL_TIMEOUT_MS`: глобальный таймаут выполнения инструментов.
- Автоматическая нормализация имён через `get_function_prefix`.
- Обнаружение опечаток: `get_missing_suggestions` с использованием `difflib`.
- Синглтон-реализация: `_REGISTRY_SINGLETON`, инициализируется через `get_tool_registry`.

## Утилиты

- `record_message`: хранит последние 20 ID сообщений для управления контекстом.
- `resolve_question`: разрешает ожидающие вопросы через `Future`.
- `close_all`: корректно завершает все плагины с логированием ошибок.

## Назначение

`ToolRegistry` обеспечивает:
- Единый интерфейс для всех инструментов.
- Безопасное и контролируемое выполнение.
- Гибкую настройку доступности и интерфейса.
- Поддержку расширяемости через плагины и MCP.

Переменные конфигурации, задающие таймауты и ограничения на объём вывода для различных операций.  
`TOOL_TIMEOUT_MS` — максимальное время выполнения инструмента (120 секунд).  
`GREP_TIMEOUT_MS` — таймаут операции поиска (30 секунд).  
`WEB_FETCH_TIMEOUT_MS` — таймаут получения данных из веба (90 секунд).  
`OUTPUT_TRIM_LEN` — максимальная длина обрезанного вывода (3000 символов).  
`OUTPUT_HEAD_LEN` — длина начальной части вывода при обрезке (1500 символов).  
`OUTPUT_TAIL_LEN` — длина конечной части вывода при обрезке (1000 символов).  
Используются для контроля производительности и объёма данных в обработке инструментов.

Плагин инструмента для интеграции с удалёнными MCP-сервисами через стандартный интерфейс взаимодействия с инструментами. Обеспечивает регистрацию и выполнение вызовов к MCP-инструментам, управляемым через `MCPManager`.  

Ключевые сущности:  
- `MCPRemoteToolPlugin` — реализация плагина, предоставляющего доступ к удалённому MCP-инструменту.  
- `MCPToolInfo` — описание инструмента (имя, схема ввода, описание).  
- `MCPManager` — менеджер, отвечающий за выполнение вызовов к MCP-серверам.  

Особенности:  
- Использует `_normalize_schema` для приведения входной схемы к валидному JSON Schema формату с корневым типом `object`.  
- Результаты выполнения обрабатываются через `_render_mcp_result`, извлекающий текст из `content` или сериализующий ответ в JSON.  
- Идентификатор плагина формируется как `MCP[<server_name>]`, префиксы функций отключены для сохранения оригинальных имён инструментов.  
- Таймаут выполнения — 30 секунд, выполнение не параллелизуется.  

Параметры спецификации (`ToolSpec`):  
- `name` — имя инструмента в реестре.  
- `description` — описание из `MCPToolInfo` или сгенерированное.  
- `parameters` — нормализованная схема входных данных.  
- `parallelizable` — `False`.  
- `timeout_ms` — 30000.  

При сбое вызова ошибка логируется и возвращается в структурированном виде.

Плагин инструмента для поиска текста или регулярных выражений в файлах с использованием `grep`. Позволяет искать определения, вхождения или паттерны кода в указанной директории или файле. Поддерживает контекст вывода, нечувствительность к регистру, фильтрацию по типу файлов и исключение чувствительных директорий и файлов (например, `node_modules`, `.git`, `.env`, ключи).  

Ключевые параметры:
- `pattern` — обязательный поисковый запрос или регулярное выражение.
- `path` — путь для поиска (по умолчанию — текущая директория).
- `context_before`, `context_after` — количество строк до и после совпадения.
- `files_only` — возвращать только пути к файлам, содержащим совпадения.
- `ignore_case` — выполнить поиск без учёта регистра.

Автоматически блокирует запросы, содержащие потенциально опасные ключевые слова (например, `password`, `token`, `secret`). Использует безопасное разрешение путей в пределах рабочей области. Результат ограничивается 200 строками. Время выполнения ограничено через `GREP_TIMEOUT_MS`.

Инструмент `show_me_diagrams` для генерации и рендеринга диаграмм с использованием PlantUML. Поддерживает два режима: `generate` — генерация PlantUML-кода на основе описания с помощью LLM (через OpenAI API), и `render` — прямой рендеринг переданного PlantUML-кода в PNG. Поддерживаемые типы диаграмм: `gantt_chart`, `mind_map`, `flowchart`, `project_timeline`, `infographic`, `org_chart`, `process_diagram`.

Ключевые параметры:
- `action`: `generate` или `render` (обязательный)
- `diagram_type`: тип диаграммы (для `generate`)
- `description`: описание диаграммы (для `generate`)
- `plantuml_code`: PlantUML-код (для `render`)
- `title`: заголовок диаграммы (опционально)

Требуется наличие `plantuml.jar` в той же директории, что и скрипт, и установленного Java. Для генерации кода требуется `OPENAI_API_KEY`. Результат — путь к PNG-файлу и исходный PlantUML-код. Файлы сохраняются во временной директории. Таймаут выполнения — 120 секунд.

Инструмент для поиска изображений и GIF-файлов через DuckDuckGo Images. Предоставляет асинхронный интерфейс выполнения запросов с последующим извлечением URL найденных изображений. Поддерживает параметры поиска: текстовый запрос, тип контента (photo/gif), регион и максимальное количество результатов. Результаты перемешиваются перед выбором случайного изображения. Использует библиотеку `duckduckgo-search`, которая должна быть установлена. В случае ошибки или отсутствия результатов возвращает соответствующее сообщение. Основные параметры: `query` (обязательный), `type`, `region`, `max_results`. Инструмент параллелизуем.

Инструмент `read_file` предназначен для безопасного чтения содержимого файлов в рамках рабочей области. Позволяет читать файлы по указанному пути с возможностью задать смещение (номер начальной строки) и ограничение на количество возвращаемых строк. Перед использованием проверяет доступ к файлу: разрешает доступ только в пределах текущей рабочей директории, блокирует чтение чувствительных файлов и файлов из чужих рабочих пространств. Поддерживает чтение отсутствующих или пустых файлов с соответствующим информированием. Основные параметры: `path` (обязательный), `offset`, `limit`. Используется в цепочках инструментов, где требуется анализ исходного кода или данных перед редактированием.

Плагин инструмента для асинхронного получения содержимого файлов из репозитория GitHub по указанному пути. Поддерживает выборку как отдельных файлов, так и содержимого директорий с ограничением на количество обрабатываемых файлов.  

Ключевые сущности:  
- `GitHubAnalysisTool` — реализация плагина, наследующая `ToolPlugin`.  
- `ToolSpec` — описание инструмента: имя `github_analysis`, параметры `owner`, `repo`, `path`, `max_files`.  
- Обязательные параметры: `owner`, `repo`.  
- `max_files` — ограничение от 1 до 20 файлов (по умолчанию 5).  

Авторизация осуществляется через токен, который берётся из переменной окружения `GITHUB_TOKEN` или из конфигурации плагина. Запросы к API GitHub выполняются синхронно в отдельном потоке через `asyncio.to_thread`.  

Поддерживается декодирование контента из base64 или загрузка по `download_url`. Результат включает имена файлов и их содержимое, объединённые с разделителем. В случае ошибки возвращается сообщение об ошибке.

Инструмент для выполнения запросов к WolframAlpha с получением кратких текстовых ответов. Используется для вычислений, научных данных, статистики и других точных ответов на основе структурированной базы знаний. Поддерживает выполнение через асинхронный интерфейс с синхронным вызовом API в отдельном потоке. Требует наличие переменной окружения `WOLFRAM_APP_ID`. Запросы рекомендуется передавать на английском языке для лучшей точности. Основной метод — `execute`, принимающий параметр `query`. Используется простой HTTP-запрос к `/v1/result`, возвращающий plain text. Таймаут выполнения — 60 секунд.

# `DialogMixin` — Миксин для управления диалогами в Telegram-ботах

`DialogMixin` — это базовый класс-миксин, обеспечивающий удобную реализацию многошаговых диалогов и обработку inline-кнопок в Telegram-ботах. Он интегрируется с `ToolPlugin`, расширяя его функциональность для поддержки интерактивных сценариев.

## Основные возможности

- **Управление диалогами**: отслеживание состояния, таймауты, автоматическая отмена.
- **Поддержка шагов**: определение последовательных этапов диалога с обработкой текста и callback-запросов.
- **Автономные действия**: обработка нажатий кнопок вне активного диалога.
- **Изоляция контекстов**: безопасное разделение диалогов между плагинами через `plugin_id`.
- **Интеграция с `ToolPlugin`**: реализация методов `awaiting_input`, `cancel_input`, `get_commands`, `handle_message`, `handle_callback`.

## Ключевые методы и сущности

### Диалоговые кнопки и действия
- `dialog_button(text, data)` — создаёт кнопку для перехода к следующему шагу диалога (`callback_data: dlg:{plugin_id}:{data}`).
- `action_button(text, action, payload=None)` — кнопка для автономного действия (`callback_data: cb:{plugin_id}:{action}` или с payload).
- `parse_callback_payload(callback_query)` — извлекает полезную нагрузку из `callback_data`.

### Определение логики
- `dialog_steps()` — словарь шагов диалога и их обработчиков (по сообщениям и/или колбэкам).
- `callback_handlers()` — обработчики для автономных действий (вне диалога).
- `step_hint(step)` — возвращает подсказку при некорректном вводе.

### Обработка событий
- `handle_message(update)` — обрабатывает текстовые сообщения в активном диалоге, проверяет отмену (`CANCEL_WORDS`), перенаправляет на шаг.
- `handle_callback(update)` — обрабатывает нажатия кнопок в диалоге.
- `_dispatch_callback(update)` — центральный маршрутизатор callback-запросов:
  - `dlg_cancel:{pid}` — отмена диалога.
  - `dlg:{pid}:...` — продолжение диалога.
  - `cb:{pid}:{action}` — вызов автономного действия.

### Вспомогательные методы
- `start_dialog(chat_id, step=None)` — запуск диалога.
- `end_dialog(chat_id)` — завершение диалога.
- `get_dialog(chat_id)` — получение текущего состояния диалога.
- `set_step(chat_id, step)` — переход к указанному шагу.
- `_on_cancel_button(update)` — обработка отмены, уведомление пользователя.
- `_ensure_agent_enabled()` — проверка активности агента.

### Фильтрация и безопасность
- `_dialog_active_filter()` — фильтр для обработки только активных диалогов.
- `extra_message_filters()` — расширяемый фильтр для медиа и других типов сообщений (по умолчанию — блокировка).
- `get_message_handlers()` — возвращает обработчики сообщений при активном диалоге.

## Особенности
- Использование `DialogState` для хранения состояния на уровне чата.
- Автоматическая отмена диалога при таймауте или отключении агента.
- Перехват и логирование ошибок в обработчиках; при ошибках диалог завершается.
- Поддержка `show_alert` при неизвестных действиях.
- Совместимость с системой команд бота через `get_commands()`.

## Рекомендации по использованию
- Наследуйтесь от `DialogMixin` **первым** в списке родителей, чтобы его методы правильно переопределяли поведение `ToolPlugin`.
- Уникальный `plugin_id` обеспечивает изоляцию диалогов между плагинами.

Инструмент `list_directory` предназначен для безопасного просмотра содержимого директории в рамках рабочей области агента. Поддерживает указание пути через параметр `path`, по умолчанию используется текущая директория (`cwd`). Реализует защиту от доступа к системным и привилегированным директориям, таким как `/etc`, `/root`, `/.ssh` и другим. Проверяет расположение запрашиваемого пути относительно рабочей директории, блокируя доступ к чужим пользовательским пространствам. Выполняет команду `ls -la` через `subprocess`, возвращает содержимое в случае успеха или сообщение об ошибке. Все пути нормализуются и проверяются с помощью вспомогательных функций из `helpers`. Ключевые параметры: `path` — строка с путём к директории.

Инструмент `ask_user` предназначен для взаимодействия с пользователем через интерфейс с кнопками выбора. Используется, когда агенту требуется подтверждение или выбор из нескольких вариантов. Возвращает текст выбранного пользователем варианта.

Ключевая сущность — `AskUserTool`, реализующая интерфейс `ToolPlugin`. Описание инструмента определяется через `ToolSpec`, включая обязательные параметры:  
- `question` (строка) — вопрос, отображаемый пользователю;  
- `options` (массив строк, от 2 до 4 элементов) — варианты ответов в виде кнопок.

Инструмент не поддерживает параллельное выполнение (`parallelizable=False`).  

В процессе выполнения:  
- Генерируется уникальный `question_id` на основе времени и UUID;  
- Создаётся `Future` для асинхронного ожидания ответа;  
- Отправляется запрос пользователю через `bot._send_ask_question`;  
- Ожидается ответ в течение 120 секунд; при таймауте возвращается ошибка.

Состояние ожидания хранится в `self.services["pending_questions"]`, что позволяет обрабатывать ответ при его поступлении.

# TextDocumentQATool — Документация

## Назначение
Инструмент `TextDocumentQATool` реализует Telegram-бота для управления текстовыми документами и диалогового взаимодействия с ними на основе LLM. Позволяет пользователям загружать, просматривать, задавать вопросы по содержимому и удалять документы.

## Основные функции
- **`upload`** — загрузка документа (имя + содержимое), сохранение в `.txt` и метаданных в `.meta`.
- **`list`** — отображение списка доступных документов.
- **`ask`** — задание вопроса по содержимому документа с использованием ИИ.
- **`delete`** — удаление документа и связанного метафайла по `document_id`.

## Хранение данных
- Файлы сохраняются в директории, определяемой через `AGENT_SANDBOX_ROOT`, `config.defaults.workdir` или `cwd`.
- Документы: `{doc_id}.txt` (содержимое), `{doc_id}.meta` (имя).
- `doc_id` генерируется как SHA1-хеш содержимого.

## Диалоговый интерфейс
Интегрирован с `DialogMixin`, поддерживает пошаговый ввод:
- `wait_name` — ввод имени документа.
- `wait_content` — ввод текста документа.
- `wait_doc_select` — выбор документа из списка.
- `wait_query` — ввод вопроса.

Управление состоянием через `set_step` / `get_dialog`.

## Интеграция с LLM
- Используется `AsyncOpenAI` для асинхронных запросов.
- Модель: `gpt-4o-mini` (настраивается через `OPENAI_MODEL`).
- Ключ API: `OPENAI_API_KEY` (обязательный).
- Базовый URL: `OPENAI_BASE_URL` (опционально, например, для прокси).
- Параметры: `temperature=0.2`, `max_tokens=800`.
- Контекст ограничивается 12000 символами.
- Промпт включает системное сообщение и пользовательский вопрос.

## Ответы
Возвращаются в формате JSON:
```json
{ "success": true, "output": "..." }
```
или
```json
{ "success": false, "error": "..." }
```

## Интерфейс
- Меню с меткой «Документы».
- Обработка команд через callback-запросы (`_cb_*`).
- Формирование клавиатуры: `_build_doc_list_keyboard()`.

## Ограничения
- Таймаут выполнения: 120 секунд.
- Нет поддержки параллельных сессий.
- Логика ответа на вопрос (`ask`) частично реализована.

## Зависимости
- Переменные окружения: `OPENAI_API_KEY`, `OPENAI_BASE_URL`, `OPENAI_MODEL`.
- Асинхронная работа с OpenAI API.

Инструмент `manage_message` позволяет агенту управлять собственными недавними сообщениями в текущем диалоге: удалять (последнее или по индексу) и редактировать последнее сообщение. Поддерживает три действия через параметр `action`: `delete_last`, `delete_by_index`, `edit_last`. Для удаления по индексу используется параметр `index`, для редактирования — `new_text`. Индексация сообщений ведётся от 0 (самое старое) до -1 (последнее). Инструмент взаимодействует с ботом через контекст (`bot._delete_message`, `bot._edit_message`) и отслеживает идентификаторы сообщений в хранилище `services.recent_messages`. Операции ограничены только сообщениями агента в текущем чате. В случае ошибок возвращает подробное описание сбоев, включая проблемы с доступом, сроком жизни сообщения или валидностью индекса.

Инструмент `send_file` позволяет отправлять файлы из рабочей директории в чат. Предназначен для обмена результатами работы, например, созданными скриптами, отчётами или данными. Путь к файлу может быть относительным или абсолютным. Файл проверяется на наличие в рабочей области, его размер (не более 50 МБ), а также на чувствительность — запрещены отправка файлов с ключевыми словами вроде `.env`, `secrets`, `id_rsa` и другими, связанными с учётными данными. Перед отправкой файл проверяется на существование и ненулевой размер. Поддерживается необязательная подпись (caption). Отправка осуществляется через бота, используя метод `_send_document`. В случае ошибок возвращаются информативные сообщения, включая ограничения по правам доступа (например, запрет на отправку медиа в группе).

Инструмент `CodeInterpreterTool` предоставляет возможность безопасного выполнения ограниченного Python-кода в изолированной среде без доступа к внешним модулям и файловой системе. Основное назначение — интерпретация небольших фрагментов кода, связанных с вычислениями, обработкой данных или тестированием логики, при строгих мерах безопасности.

Ключевые сущности:
- `ToolPlugin` — базовый класс для инструментов агента.
- `ToolSpec` — описание интерфейса инструмента, включая параметры и ограничения.
- `execute` — асинхронный метод выполнения кода с таймаутом.
- `_static_block` — статическая проверка кода на наличие запрещённых конструкций.
- `_run_sync` — синхронное выполнение кода в отдельном процессе.

Важные настройки и ограничения:
- Запрещены: импорты (`import`, `from`), модули `os`, `subprocess`, `socket`, `requests`, операции ввода-вывода (`open`), `eval`, `exec`, дандер-методы.
- Код выполняется в отдельном процессе Python с ограниченным окружением.
- Таймаут выполнения — от 1 до 60 секунд (по умолчанию 20).
- Вывод обрезается с помощью `helpers._trim_output`.
- Временный файл используется для запуска кода, затем удаляется.

Инструмент не параллелизуется и предназначен для безопасного, контролируемого выполнения простых Python-выражений.

# Резюме: Плагинная система с поддержкой диалогов

Базовый класс `ToolPlugin` служит основой для всех плагинов, обеспечивая интеграцию с агентом и Telegram-интерфейсом. Плагины автоматически регистрируются в `ToolRegistry` и доступны как для вызова агентом, так и для взаимодействия с пользователем. Ключевые параметры: `plugin_id` (уникальный ID) и `function_prefix` (префикс инструмента). Работают в приоритетной группе хендлеров (-1) при активной сессии агента.

## Основные методы и контракт
- `get_spec()` — возвращает JSON Schema спецификации инструмента.
- `execute()` — выполняет логику плагина, возвращает `{"success": bool, "output"|"error": str}`.

## Диалоги и интерактивность (`DialogMixin`)
`DialogMixin` (наследуется **до** `ToolPlugin`) обеспечивает поддержку многошаговых диалогов:
- Управление состоянием ввода: `awaiting_input(chat_id)`, `cancel_input(chat_id)`.
- Обработка inline-колбэков: `get_inline_handlers()` возвращает список `{action, handler}`.
- Диалоги привязаны к `chat_id`, позволяя параллельные сессии.

### Диалоговые шаги
Определяются в `dialog_steps()` как словарь или callable. Каждый шаг может содержать:
- `"message"` — обработчик текстового ввода.
- `"callback"` — обработчик колбэк-кнопок.

Управление:
- `start_dialog(chat_id)` — запуск диалога.
- `set_step(chat_id, step_name)` — переход к шагу.
- `end_dialog(chat_id)` — завершение.

Таймаут неактивности — `DIALOG_TIMEOUT` (по умолчанию 300 сек), сбрасывается при `set_step()`.

## Callback-система
Единая маршрутизация через `_dispatch_callback`, проверяющая активность агента. Поддерживаемые типы кнопок:

| Тип | Формат `callback_data` | Назначение |
|-----|------------------------|----------|
| `dlg:` | `dlg:{plugin_id}:{payload}` | Кнопки внутри диалога |
| `cb:` | `cb:{plugin_id}:{action}:{payload?}` | Автономные действия |
| `dlg_cancel:` | `dlg_cancel:{plugin_id}` | Отмена диалога |

### Вспомогательные методы
- `dialog_button(label, payload)` — кнопка в диалоге.
- `action_button(label, action, payload=None)` — автономная кнопка.
- `cancel_markup()` — готовая кнопка «Отмена».
- `parse_callback_payload(update)` — извлечение `payload` из `callback_data`.

Регистрация: все колбэки объединяются в один `CallbackQueryHandler` через `_dialog_callback_commands()`, возвращаемый из `get_commands()`.

## Меню и команды
- `get_menu_label()` — метка верхнего уровня меню.
- `get_menu_actions()` — список действий (метка + action).
- Команды Telegram: определяются в `get_commands()`.

## Обработка ввода
- Перехват сообщений при активном диалоге.
- Автоотмена при вводе слов из `CANCEL_WORDS`.
- Поддержка медиа и других типов — через `extra_message_filters()`.
- Подсказки для шагов — `step_hint(step)`.

## Жизненный цикл и интеграция
- Инициализация: `initialize(config, services)`.
- Завершение: `close()`.
- Доступ к сервисам: `services.config`, `pending_questions`, `task_store`, `scheduler_tasks`, `user_tasks` и др.
- Автоматическая очистка диалогов при смене/закрытии сессии или отключении агента.

## Регистрация плагинов
- Автоматическая загрузка из `agent/plugins/` (исключая `__init__.py`, `base.py`).
- Имена инструментов: `{function_prefix}.{spec.name}`.

## Рекомендации
- Обрабатывайте ошибки в `execute()` локально, возвращая структурированный ответ.
- Для длительных операций увеличьте `DIALOG_TIMEOUT`.
- Плагин не должен напрямую зависеть от `bot.py` — используйте абстракции `ToolPlugin`.

## Пример функциональности
Плагин с двухуровневым меню:
1. Запуск диалога → выбор режима (`fast`/`detailed`) → ввод текста → преобразование в верхний регистр.
2. Показ информации.

Обработчики: `_cb_start`, `_cb_info`, `_on_mode_button`, `_on_mode_text`, `_on_input`.

# TaskManagementTool — Управление задачами в Telegram-боте

## Назначение
Инструмент для управления задачами в Telegram-боте с поддержкой создания, просмотра, обновления и удаления задач. Реализует приоритеты, статусы, дедлайны, теги и уведомления. Данные хранятся в JSON-файле `tasks.json` в директории `_shared` (определяется через `AGENT_SANDBOX_ROOT` или fallback в текущую).

## Ключевые сущности
- **`TaskManagementTool`** — основной класс, наследующий `DialogMixin` и `ToolPlugin`.
- **Задача** — содержит:
  - `task_id`: уникальный ID (на основе временной метки и UUID)
  - `title`, `description` (опционально)
  - `priority`: high / medium / low
  - `status`: pending / in_progress / completed / cancelled
  - `deadline`: строка в формате "YYYY-MM-DD HH:MM"
  - `deadline_ts`: Unix-время дедлайна
  - `last_updated`: временная метка последнего изменения
  - `notify`: флаги уведомлений
- **Хранение**: вложенный словарь `{user_id: {task_id: task_data}}`, где `user_id` — фактически `chat_id`.

## Функциональность
- **Операции**:
  - `create`: создание задачи (с парсингом приоритета, дедлайна и заголовка)
  - `list`: вывод до 50 задач, отсортированных по статусу, дедлайну и приоритету
  - `update`: изменение полей задачи
  - `delete`: удаление по `task_id`
- **Диалоговый ввод**: состояние `wait_text` для добавления задачи, отмена через команды: `отмена`, `cancel`, `выход`, `-`.
- **Интерфейс**: формируется через `_build_tasks_menu` (до 12 задач с кнопками). Поддержка callback-команд: `add`, `refresh`, `view`, `del`, `next`, `view_help`.

## Настройки уведомлений (`_NotifyPolicy`)
- `due_soon_window_sec`: интервал для уведомления о скором дедлайне
- `overdue_repeat_sec`: минимальный интервал между повторами уведомлений о просрочке
- `check_interval_sec`: частота проверки дедлайнов (реализована в `bot.py`)
- Уведомления отправляются однократно при входе в "скоро истекает" и с повтором при просрочке.

## Технические особенности
- Все операции — асинхронные, совместимы с `telegram.ext`.
- Валидация: формат дедлайна, допустимые значения приоритета и статуса.
- Автогенерация `task_id`.
- Изоляция данных по `user_id`.
- Вспомогательные функции: `_load_all_tasks`, `_save_all_tasks`.
- Логирование ошибок при работе с файлом.

Инструмент `MovieInfoTool` предоставляет доступ к информации о фильмах через API The Movie Database (TMDb). Поддерживает два действия: получение фильмов, текущих в прокате (`now_playing`), и поиск фильмов по критериям (`discover`) с возможностью фильтрации по жанру. 

Ключевые параметры:
- `action` (обязательный): тип запроса — `now_playing` или `discover`.
- `genre_id`: идентификатор жанра TMDb для фильтрации.
- `count`: количество возвращаемых фильмов (от 1 до 30, по умолчанию 10).
- `language`: язык локализации (по умолчанию `ru-RU`).
- `region`: регион для фильтрации проката (по умолчанию `RU`).

Требует наличие переменной окружения `TMDB_API_KEY`. Запросы к API выполняются синхронно в отдельном потоке. Результат включает название, дату выхода, рейтинг и краткое описание фильма (обрезанное до 200 символов). Вывод автоматически обрезается для соответствия ограничениям системы. Инструмент поддерживает параллельное выполнение и имеет таймаут 60 секунд.

Инструмент `delete_file` предназначен для удаления файлов в пределах рабочей директории. Является частью системы плагинов инструментов агента и реализует интерфейс `ToolPlugin`. Основное назначение — безопасное удаление файлов с проверкой на принадлежность рабочему пространству.

Ключевые сущности:
- `ToolSpec` — описание инструмента, включая имя, описание и параметры.
- `helpers._resolve_within_workspace` — проверяет и разрешает путь внутри рабочей директории.
- `helpers._is_other_user_workspace` — блокирует доступ к файлам из чужого рабочего пространства.

Параметры:
- `path` (обязательный) — путь к удаляемому файлу, относительный или абсолютный, но должен находиться в workspace.

Особенности:
- Удаление возможно только для файлов, находящихся в текущей рабочей директории (`cwd`).
- При отсутствии файла возвращается ошибка "File not found".
- Попытка удалить файл вне workspace или в чужом workspace блокируется.
- В случае успеха возвращается сообщение `Deleted: <path>`, иначе — описание ошибки.

Инструмент `search_web` предназначен для выполнения поисковых запросов в интернете. Используется для получения актуальной информации: новости, текущие события, определения, цены, погода и другая внешняя информация. Ключевая сущность — класс `SearchWebTool`, наследующий `ToolPlugin`. Основные параметры: `name`, `description`, `parameters` (с обязательным полем `query` типа строка). Уровень риска — средний (`medium`). Выполнение делегируется вспомогательной функции `search_web_impl`, которая использует переданный `config` для настройки поиска. Требует наличия параметра `query` в аргументах.

# Haiper Image-to-Video Tool — Краткое резюме

**Назначение**  
Инструмент для преобразования изображения в видео с использованием внешнего API `api.vsegpt.ru`. Позволяет пользователям через Telegram загружать изображение, задавать текстовый промпт анимации и получать готовое видео в формате MP4.

**Ключевые возможности**
- Поддержка загрузки изображений: как фото, так и документы в Telegram.
- Пошаговый диалог через `DialogMixin`:  
  - `wait_image` — ожидание изображения.  
  - `wait_prompt` — ввод текстового описания анимации.
- Автоматическое определение расширения и кодирование изображения в base64.
- Генерация видео через API `https://api.vsegpt.ru/v1/video` с опросом статуса каждые 10 секунд.
- Отправка результата пользователю как документа в Telegram.

**Основные сущности**
- `HaiperImageToVideoTool`: основной класс, реализует `ToolPlugin` и `DialogMixin`.
- Временные файлы хранятся в `_shared/haiper/<chat_id>` или `/tmp/video_generation`.

**Параметры**
- `image_path` — путь к изображению (обязательный, JPG/PNG).
- `prompt` — описание анимации (опционально, по умолчанию: "animate image").
- `model` / `model_id` — версия модели (по умолчанию: `haiper-2.0`).
- `aspect_ratio` — фиксировано `16:9`.

**Настройки**
- `API_URL`: `https://api.vsegpt.ru/v1/video`
- `DIALOG_TIMEOUT`: 1 час (учитывает длительность генерации).
- `AGENT_SANDBOX_ROOT`: корень для временных файлов (по умолчанию — текущая директория).
- `ZAI_API_KEY`: API-ключ (обязателен, передаётся через окружение или конфиг).

**Процесс работы**
1. Проверка и разрешение пути к изображению.
2. Кодирование изображения в base64.
3. POST-запрос на `/generate` для запуска генерации.
4. Опрос `/status` каждые 10 секунд (до 45 минут).
5. Скачивание MP4 при успехе.
6. Сохранение и возврат пути к видео.

**Таймауты**
- Генерация: до 45 минут.
- HTTP-таймауты: 60 сек (генерация), 30 сек (статус), 120 сек (скачивание).

**Обработка ошибок**
- Полная обработка на всех этапах: загрузка, генерация, отправка.
- При ошибках возвращается словарь: `{"success": false, "error": "описание"}`.

**Особенности**
- Асинхронный вызов с синхронным выполнением в отдельном потоке.
- Поддержка интеграции в агентские системы с песочницей.

Инструмент `run_command` предназначен для выполнения shell-команд в рамках рабочей среды агента. Поддерживает операции с системой, пакетными менеджерами (git, npm, pip) и другими CLI-инструментами. Имеет встроенные механизмы безопасности.

Ключевые сущности:
- `ToolPlugin` — базовый класс плагина.
- `ToolSpec` — описание инструмента: имя, параметры, уровень риска.
- `helpers` — вспомогательные функции проверки и выполнения команд.

Основные параметры:
- `command` (обязательный) — строка с командой для выполнения.

Уровень риска: `high`. Не поддерживает параллельное выполнение (`parallelizable=False`).

Важные проверки:
- Изоляция рабочей области (`_check_workspace_isolation`).
- Попытка выхода за пределы рабочей директории (`_check_command_path_escape`).
- Анализ опасности команды (`check_command`) — блокировка или запрос подтверждения для `rm -rf`, `sudo` и аналогичных.

Если команда потенциально опасна, но не заблокирована — требуется подтверждение пользователя через callback `_APPROVAL_CALLBACK`. Выполнение откладывается до получения подтверждения.

Результат выполнения — словарь с полями `success`, `output`/`error`, при необходимости — флаг `approval_required`.

Инструмент `edit_file` позволяет редактировать файлы путём точной замены текста. Требует указания пути к файлу, текста для поиска (`old_text`) и нового текста (`new_text`). Перед редактированием выполняется ряд проверок безопасности: доступ к рабочей области, чувствительные файлы, символические ссылки, а также анализ на наличие опасного кода в новом содержимом. Поддерживает работу только в пределах рабочей директории (`cwd`), указанной в контексте. Файл должен существовать, а `old_text` — присутствовать в нём дословно. В случае успеха возвращается подтверждение, при ошибках — детализированное сообщение с возможным превью содержимого.

# Краткое резюме

Данный документ представляет собой техническую документацию, объединяющую несколько частей, описывающих архитектуру, функциональность и использование системы. В документации рассматриваются основные компоненты системы, их взаимодействие, интерфейсы и процессы. Описаны требования, принципы работы, примеры использования и рекомендации по интеграции. Документ предназначен для разработчиков, инженеров и технических специалистов, обеспечивающих развертывание и сопровождение решения.

Плагин инструмента для оптимизации пользовательских промптов с использованием модели OpenAI. Назначение — улучшение формулировки исходного запроса для повышения точности и качества ответов модели. Основная сущность — класс `PromptPerfectTool`, реализующий интерфейс `ToolPlugin`.

Ключевые параметры инструмента:
- `original_prompt` (обязательный) — исходный текст промпта, который необходимо оптимизировать.
- `context` (опциональный) — дополнительный контекст, уточняющий задачу.

Инструмент использует настройки из переменных окружения или конфигурации:
- `OPENAI_API_KEY` — API-ключ для доступа к OpenAI (обязателен).
- `OPENAI_BASE_URL` — базовый URL для API (опционально, используется при работе с прокси или локальными эндпоинтами).
- `OPENAI_MODEL` — модель для оптимизации (по умолчанию `gpt-4o-mini`).

В процессе выполнения формируется системное сообщение с инструкцией по улучшению промпта, после чего запрос отправляется в модель. Результат — оптимизированный промпт, возвращаемый в поле `output`. При ошибках возвращается флаг `success: False` и описание проблемы.

Инструмент `auto_tts` для генерации аудио из текста с использованием OpenAI TTS. Позволяет озвучивать текст с выбором голоса, модели, формата вывода и дополнительных инструкций. Результат — путь к сохранённому аудиофайлу в формате mp3, opus, aac, flac, wav или pcm.

Ключевые параметры:
- `text` — текст для озвучивания (обязательный)
- `voice` — голос (допустимые значения: alloy, ash, ballad, coral, echo, sage, shimmer, verse, marin, cedar; по умолчанию: alloy)
- `model` — модель TTS (по умолчанию: gpt-4o-mini-tts)
- `response_format` — формат аудиофайла (по умолчанию: mp3)
- `instructions` — дополнительные инструкции для голоса (опционально)

Требует наличие `OPENAI_API_KEY` в переменных окружения или в конфигурации. Базовый URL для OpenAI может быть задан через `OPENAI_BASE_URL`. Аудиофайлы сохраняются во временной директории `/tmp/tts` (или аналоге для ОС). Инструмент поддерживает параллельное выполнение и имеет таймаут 120 секунд.

Инструмент для генерации изображений по текстовому промпту с использованием HuggingFace Inference API. Реализован как плагин `ToolPlugin` и предоставляет методы для асинхронного выполнения через `execute`. Основан на модели Stable Diffusion, поддерживает указание кастомной модели через параметр `model` (по умолчанию — `HiDream-ai/HiDream-I1-Full`).

Ключевые параметры:
- `prompt` (обязательный) — текстовое описание изображения.
- `model` (опциональный) — идентификатор модели в репозитории HuggingFace.

Для работы требуется токен аутентификации в переменной окружения `STABLE_DIFFUSION_TOKEN`. Изображение сохраняется во временной директории `/tmp/image_generation` (или аналоге для ОС) с расширением `.png`, возвращается путь к файлу.

При первой генерации для "холодной" модели выполняется повторный запрос. Таймаут операции — 300 секунд. Ошибки логируются, возвращаются в виде словаря с `success=False` и описанием проблемы.

Плагин инструмента для делегирования сложных задач во внешний CLI-интерфейс (например, codex/gemini/claude code). Используется, когда задача требует полноценного цикла разработки или выходит за рамки возможностей стандартных инструментов. Основная сущность — `UseCliTool`, реализующая интерфейс `ToolPlugin`. Ключевой параметр выполнения — `task_text`, содержащий описание задачи. Для работы требуется активная сессия CLI, передаваемая через контекст (`ctx["session"]`). В случае успеха возвращает обрезанный вывод сессии, в случае ошибки — сообщение об ошибке. Вывод очищается от ANSI-кодов.

# RemindersTool — Управление напоминаниями в Telegram-боте

## Назначение
Инструмент `RemindersTool` предоставляет функциональность создания, просмотра и удаления пользовательских напоминаний через Telegram-бота. Работает в связке с системой диалогов и обработки callback-запросов.

## Основные возможности
- **Создание напоминаний** по формату `ГГГГ-ММ-ДД ЧЧ:ММ текст`
- **Просмотр списка** активных напоминаний с отображением времени выполнения и оставшегося времени
- **Удаление** напоминаний по ID с проверкой принадлежности
- Поддержка интерактивного интерфейса: кнопки, диалоги, клавиатуры

## Ключевые сущности
- `reminder_id` — уникальный идентификатор напоминания
- `services["scheduler_tasks"]` — хранилище задач с деталями выполнения
- `services["user_tasks"]` — привязка пользователей к их активным напоминаниям

## Поддерживаемые действия (`execute`)
- `set` — запуск диалога создания напоминания
- `list` — отображение списка активных напоминаний
- `delete` — удаление по ID
- `view`, `close_menu` — вспомогательные действия для интерфейса

## Ограничения
- Макс. длительность напоминания: **24 часа (86400 сек)**
- Макс. количество на пользователя: **5 активных напоминаний**
- Формат времени: строго `YYYY-MM-DD HH:MM`
- Отмена ввода: команды `отмена`, `cancel`, `выход`, `-`

## Технические особенности
- Использует `DialogMixin` для пошагового ввода
- Асинхронное выполнение через `asyncio.create_task`
- Автоматическая очистка после срабатывания
- Отправка уведомлений через `bot._send_message`
- Таймаут инструмента: **30 секунд**
- Не поддерживает параллельное выполнение (`parallelizable=False`)

## Интеграция
- Доступ через меню: "Напоминания" → "Список", "Создать"
- Callback-действия: `list`, `set`, `delete`, `view`, `close_menu`
- Динамическое обновление времени в описании инструмента

Инструмент `write_file` предназначен для создания или перезаписи файлов в рабочей директории агента. Обеспечивает безопасную запись с проверкой пути и содержимого. Поддерживает разрешение путей относительно рабочей директории (`cwd`), блокирует запись в чувствительные файлы, чужие рабочие пространства и при обнаружении символических ссылок, ведущих за пределы workspace. Проверяет содержимое на наличие потенциально опасного кода (например, утечки секретов). Требует параметры `path` и `content`. При успешной записи возвращает количество записанных байт. Все операции логируются, ошибки обрабатываются с безопасным возвратом.

Инструмент `search_files` предназначен для поиска файлов в проекте с использованием glob-шаблонов. Позволяет агенту исследовать структуру проекта, находя файлы по заданному пути с поддержкой рекурсии (`**`).  

Ключевые параметры:
- `pattern` — строка с glob-шаблоном (например, `**/*.ts`, `src/**/*.js`), обязательный параметр.

Особенности реализации:
- Запрещены шаблоны с выходом за пределы рабочей директории (`..`) во избежание path traversal.
- Поиск ограничен текущей рабочей директорией (`ctx["cwd"]`), проверяется через `realpath`.
- Исключаются пути внутри `node_modules` и `.git`.
- Пропускаются директории — в результат попадают только файлы.
- Максимальное количество возвращаемых файлов — 200.
- В случае ошибки возвращается сообщение об ошибке, исключения логируются.

Возвращаемый результат:
- При успехе: `{"success": True, "output": "список файлов через \\n"}`.
- При ошибке: `{"success": False, "error": "описание ошибки"}`.

Плагин инструмента для извлечения и парсинга содержимого веб-страницы по заданному URL. Возвращает очищенный текст в формате Markdown. Основан на базовом классе `ToolPlugin` и реализует методы `get_spec` и `execute`. 

Ключевая сущность — `FetchPageTool`, предоставляющий спецификацию инструмента с именем `fetch_page`, обязательным параметром `url` (строка) и уровнем риска `medium`. Выполнение делегирует функции `fetch_page_impl` из модуля `helpers`, передавая URL и конфигурацию инструмента. Требует корректной настройки `self.config` для работы (например, таймауты, заголовки, политики доступа). Используется в агентских сценариях, где необходима загрузка внешнего контента.

Инструмент для извлечения и очистки текстового содержимого веб-страниц по заданному URL. Использует внешний сервис [r.jina.ai](https://r.jina.ai) для получения основного текста без HTML-разметки. В случае недоступности Jina применяется fallback-запрос напрямую к URL.

**Ключевые параметры:**
- `url` (обязательный) — адрес целевой страницы.
- `max_chars` (опциональный, по умолчанию 6000, ограничение от 500 до 20000) — максимальное количество символов в ответе.

**Особенности:**
- Выполняется асинхронно с использованием `asyncio.to_thread` для синхронных HTTP-запросов.
- Автоматически обрезает вывод с помощью `helpers._trim_output`.
- При ошибках возвращает структурированную информацию с флагом `success: False`.
- Поддерживает параллельное выполнение.
- Таймаут операции — 60 секунд.

**Зависимости:** `requests`, внешний API `r.jina.ai`.

Инструмент для извлечения субтитров с YouTube-видео по его `video_id`. Поддерживает выбор языка и автоматическое определение доступных транскрипций (ручные, сгенерированные). Использует библиотеку `youtube-transcript-api`, которая должна быть установлена.

Ключевые параметры:
- `video_id` (обязательный) — идентификатор видео на YouTube.
- `languages` — приоритетный список языков (по умолчанию `['ru', 'en']`).

Инструмент пытается найти транскрипцию в порядке: ручная → автоматическая → любая доступная. Возвращает текст субтитров с указанием языка и типа (ручной/автогенерированный). Поддерживает выполнение в параллельных потоках и имеет таймаут 60 секунд. Ошибки логируются, пустой или отсутствующий `video_id` приводит к ошибке выполнения.

# WebResearchTool — Краткое резюме

Плагин `WebResearchTool` предназначен для асинхронного веб-исследования по смысловому запросу: от генерации мультиязычных поисковых фраз до извлечения, очистки и анализа контента с веб-страниц и PDF.

## Основные возможности
- **Мультиязычная поддержка**: русский (ru), английский (en), китайский (zh).
- **Генерация поисковых запросов** с помощью OpenAI (по умолчанию `gpt-4o-mini`), до 5 фраз на язык.
- **Поиск ссылок** через Jina AI Search API (до `max_results_per_lang`, по умолчанию 10 на язык).
- **Загрузка и очистка контента** с HTML и PDF (включая обработку редиректов и валидацию URL).
- **Извлечение текста** с использованием каскада: `trafilatura` → `BeautifulSoup` → `Jina Reader API` → `pdfminer` (для PDF).
- **Анализ содержимого** с помощью LLM (OpenAI), если включено (`analyze_content=True`), с ограничением в 8000 символов на статью.

## Ключевые сущности
- `JINA_SEARCH_URL`, `JINA_READER_URL` — API-эндпоинты Jina AI.
- `LANG_QUERIES_PROMPTS` — шаблоны промптов для генерации запросов на разных языках.
- `_download_content`, `_extract_pdf_content`, `_get_clean_text_jina` — основные методы обработки.
- `ToolSpec` — описание инструмента с параметрами: `query` (обяз.), `max_results_per_lang` (1–20), `analyze_content` (bool).

## Настройки
- Аутентификация: `JINA_API_KEY`, `OPENAI_API_KEY` (из окружения).
- Поддержка кастомных моделей: `OPENAI_MODEL`, `OPENAI_BIG_MODEL`.
- Таймауты: 180 сек (общий), 20 сек (HTTP), 30 сек (Jina API).
- Заголовки `enhanced_headers` для обхода блокировок.

## Особенности
- Параллельный поиск и загрузка по языкам.
- Round-robin агрегация результатов.
- Fallback-цепочка извлечения текста для надёжности.
- Очистка HTML от шумных тегов (`script`, `style`, `nav`, и др.).
- Логирование ошибок и предупреждений через `logger`.
- Финальный анализ — LLM с температурой 0.3 и лимитом 2000 токенов.

## Выходные данные
- Статистика по языкам (найдено/обработано статей).
- Список источников.
- Аналитическое резюме (при `analyze_content=True`).

Инструмент `schedule_task` позволяет планировать напоминания или выполнение команд с задержкой. Поддерживает три действия: добавление задачи, просмотр списка задач пользователя и отмену задачи по ID. Максимальная задержка — 24 часа, максимум 5 задач на пользователя.

Ключевые параметры:
- `action`: действие (`add`, `list`, `cancel`)
- `type`: тип задачи (`message` — напоминание, `command` — выполнение shell-команды)
- `content`: текст напоминания или команда для выполнения
- `delay_minutes`: задержка в минутах (1–1440)
- `task_id`: идентификатор задачи (требуется для отмены)

Задачи хранятся во внутренних хранилищах `scheduler_tasks` (по ID) и `user_tasks` (по пользователю). При срабатывании отправляется сообщение через бота. Команды выполняются через `helpers.execute_shell_command` с ограничением вывода до 500 символов. Задачи удаляются из хранилища после выполнения или отмены.

Файл реализует инструмент долговременной памяти для агента, позволяющий сохранять, читать и очищать текстовые записи с автоматическим добавлением временных меток. Предназначен для хранения важной информации: контекста проекта, решений, задач и т.п. — с сохранением между сессиями.

Ключевые сущности: `MemoryTool` — основной класс, наследующий `DialogMixin` и `ToolPlugin`, обеспечивает интеграцию с интерфейсом агента и диалоговым взаимодействием. Поддерживает три действия: `read`, `append`, `clear`.

Основные настройки и параметры:
- `MEMORY_FILE` — имя файла для хранения памяти (определяется в `tooling.helpers`).
- Путь к файлу памяти формируется на основе `config.defaults.workdir` или переменной окружения `AGENT_SANDBOX_ROOT`.
- Файл создаётся в подкаталоге `_sandbox` рабочей директории.

Интерфейс:
- В меню доступны действия: «Показать», «Добавить запись», «Очистить».
- Поддержка команд через диалоговый интерфейс и API агента.
- При добавлении записи запрашивается текст через диалог; отмена возможна по ключевым словам.

API-метод `execute` позволяет использовать инструмент в автоматизированных сценариях с параметрами:
- `action` (обязательный): `read`, `append`, `clear`.
- `content`: текст для добавления (только для `append`).

Файл обеспечивает отказоустойчивое чтение и запись с обработкой ошибок, поддерживает русский интерфейс и ограничение длины вывода (до 3500 символов).

Инструмент `ChiefTool` предоставляет доступ к поиску рецептов через API Edamam по заданным ингредиентам или запросу. Поддерживает асинхронное выполнение и параллельный запуск. Для работы требует переменные окружения `EDAMAM_APP_ID` и `EDAMAM_APP_KEY`. Основной метод `execute` принимает параметры `query` (обязательный) и `count` (необязательный, от 1 до 10), возвращает найденные рецепты с названием, источником и ссылкой. Поиск выполняется синхронно в отдельном потоке через `asyncio.to_thread`. Результаты обрезаются и форматируются с помощью вспомогательной функции `_trim_output`. Ключевые параметры: `query`, `count`, `app_id`, `app_key`, `timeout_ms=60000`.

Инструмент `manage_tasks` предназначен для управления списком задач в рамках сессии. Позволяет добавлять, обновлять, просматривать и очищать выполненные задачи, что полезно при планировании многоэтапных операций. Основные сущности — задачи с полями `id`, `content`, `status` и `created_at`. Задачи хранятся в `services.task_store` с привязкой к `session_id`.

Поддерживаемые действия:
- `add`: добавляет новые задачи или обновляет существующие по `id`.
- `update`: изменяет поля `content` или `status` у существующих задач.
- `list`: возвращает отформатированный список всех задач текущей сессии.
- `clear`: удаляет задачи со статусами `completed` или `cancelled`.

Ключевые параметры в `args`: `action` (обязательный), `tasks` (массив задач). Каждая задача должна содержать `id` и `content`. Статус по умолчанию — `pending`. Результат выполнения включает флаг `success` и поле `output` с данными или сообщением. Инструмент не поддерживает параллельное выполнение.

Инструмент `GTTSTextToSpeechTool` реализует генерацию аудио из текста с использованием сервиса Google Text-to-Speech (gTTS). Является плагином инструмента для агента, позволяет асинхронно озвучивать текст на указанном языке и возвращать путь к сохранённому MP3-файлу.

Ключевые сущности:
- `get_spec` — определяет интерфейс инструмента: имя `gtts_text_to_speech`, обязательный параметр `text`, опциональный `lang` (по умолчанию `ru`), формат вывода — путь к файлу.
- `execute` — асинхронно вызывает синхронную функцию озвучки в отдельном потоке, обрабатывает ошибки.
- `_tts_sync` — синхронная логика: генерация речи через `gTTS`, сохранение в временной директории `/tmp/tts` (или `temp` в Windows) с уникальным именем на основе timestamp.

Важные настройки:
- Таймаут выполнения — 90 секунд.
- Поддержка параллельного выполнения (`parallelizable=True`).
- Файлы сохраняются во временной директории ОС в подкаталоге `tts`.
- Требуется установленный пакет `gTTS` (`pip install gTTS`).

Клиент для взаимодействия с MCP (Model Control Protocol) через HTTP, использующий JSON-RPC 2.0 для обмена сообщениями. Предназначен для асинхронного вызова инструментов (tools), их перечисления и инициализации соединения с MCP-сервером.

Основные сущности:
- `HttpMCPClientConfig` — конфигурация клиента: имя, URL сервера, таймаут, заголовки и версия протокола.
- `HttpMCPClient` — основной класс клиента, реализующий логику соединения, отправки запросов и обработки ответов.

Ключевые методы:
- `start()` — инициализирует HTTP-клиент и выполняет `initialize` и `initialized` вызовы.
- `stop()` — закрывает соединение.
- `list_tools()` — возвращает список доступных инструментов с их описанием и схемой входных данных.
- `call_tool()` — вызывает указанный инструмент с заданными аргументами.

Особенности:
- Использует `httpx.AsyncClient` для асинхронных HTTP-запросов.
- Поддерживает JSON-RPC 2.0, включая уведомления (без `id`).
- Автоматически обрабатывает ошибки и пустые ответы.
- При инициализации отправляет `initialize` и `notifications/initialized`, что совместимо с MCP-шлюзом на `127.0.0.1:8888`.

Конфигурационные параметры (`HttpMCPClientConfig`):
- `name` — логическое имя клиента.
- `url` — адрес MCP-сервера.
- `timeout_ms` — таймаут запроса в миллисекундах (по умолчанию 30 000).
- `headers` — дополнительные HTTP-заголовки.
- `protocol_version` — версия MCP-протокола (по умолчанию "2024-11-05").

Клиент для взаимодействия с MCP (Model Control Protocol) сервером через стандартные потоки ввода-вывода. Реализует асинхронное взаимодействие по протоколу JSON-RPC, поддерживает инициализацию, вызов инструментов и получение списка доступных инструментов.

Основные сущности:
- `StdioMCPClient` — основной класс клиента, управляющий подключением к MCP-серверу, отправкой запросов и обработкой ответов.
- `MCPToolInfo` — дата-класс, описывающий метаданные инструмента: имя, описание и схему входных параметров.
- `JsonRpcStream` — обёртка для чтения/записи JSON-RPC сообщений через `stdin`/`stdout`.

Ключевые функции:
- `start()` — запускает процесс MCP-сервера и инициирует handshake (инициализацию).
- `stop()` — останавливает процесс и завершает соединение.
- `list_tools()` — возвращает список доступных инструментов.
- `call_tool()` — вызывает указанный инструмент с заданными аргументами.

Параметры инициализации:
- `name` — имя клиента (для логирования).
- `cmd` — команда для запуска MCP-сервера.
- `cwd` — рабочая директория процесса.
- `env` — переменные окружения.
- `timeout_ms` — таймаут ожидания ответа от сервера.
- `protocol_version` — версия MCP-протокола (по умолчанию "2024-11-05").

Внутренние механизмы:
- Используется `asyncio` для асинхронного обмена сообщениями.
- `_reader_loop` — фоновая задача, обрабатывающая входящие JSON-RPC сообщения.
- `_pending` — словарь ожидающих ответов, сопоставляющий `id` запроса с `Future`.
- `_lock` — обеспечивает потокобезопасность при генерации идентификаторов запросов.

Особенности:
- При неудачной инициализации клиент продолжает работу, полагая, что сервер может поддерживать базовые методы.
- Логирование ошибок выполняется через стандартный модуль `logging`.

Класс `JsonRpcStream` обеспечивает чтение и запись JSON-RPC сообщений с поддержкой двух форматов фрейминга: LSP-совместимого (на основе заголовка `Content-Length`) и NDJSON (по одному JSON-объекту на строку). Используется для обмена сообщениями в асинхронных клиент-серверных взаимодействиях, например, с Language Server Protocol.

Основные сущности:
- `reader` и `writer` — объекты `asyncio.StreamReader` и `asyncio.StreamWriter` для работы с потоком ввода-вывода.
- `write()` — отправляет JSON-объект, используя по умолчанию `Content-Length` фрейминг (если `prefer_content_length=True`), иначе — в формате NDJSON.
- `read()` — читает следующее сообщение, автоматически определяя формат по первому блоку данных: если строка начинается с `Content-Length:`, применяется LSP-фрейминг, иначе — ожидается NDJSON.

Ключевые особенности:
- При чтении `Content-Length` обрабатываются заголовки до пустой строки, затем читается тело указанной длины.
- Некорректные JSON-сообщения или заголовки игнорируются, возвращается `None`.
- Логирование ошибок парсинга выполняется через модуль `logging`.
- Функция `encode_content_length_message` формирует корректный заголовок `Content-Length` и тело сообщения в соответствии с LSP.

Модуль обеспечивает интеграцию MCP-клиента с внешними инструментальными серверами. Предназначен для управления подключением, отправки запросов и обработки ответов от внешних инструментов через MCP (Model Communication Protocol). Ключевые сущности включают клиентское соединение, обработчики инструментов и маршрутизацию запросов. Поддерживает настройку URL сервера, тайм-аутов соединения, аутентификации (при наличии) и списка доступных инструментов. Основные параметры: `server_url`, `timeout`, `headers`, `tools`. Используется для расширения функциональности системы за счёт внешних сервисов — например, баз данных, API или вычислительных модулей.

Класс `MCPManager` управляет подключением и взаимодействием с MCP-серверами (Model Control Protocol), обеспечивая запуск клиентов, кэширование инструментов и вызов методов. Поддерживает два типа транспорта: `stdio` и `http`. Инициализация клиентов происходит лениво и защищена блокировкой. Инструменты кэшируются в JSON-файле по пути `_shared/mcp_tools_cache.json` для ускорения последующих запусков. Методы `list_all_tools`, `call` и `build_registry_name` позволяют получать доступные инструменты, вызывать их и формировать имена, совместимые с ограничениями OpenAI. Ключевые параметры: `enabled`, `transport`, `cmd`, `url`, `timeout_ms`, `headers` — задаются через конфигурацию `AppConfig`.
