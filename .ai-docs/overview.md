# Обзор проекта

# Класс `SessionUI`

Класс `SessionUI` обеспечивает пользовательский интерфейс для управления сессиями через Telegram-бота. Предоставляет функциональность отображения списка сессий, навигации по меню и обработки команд, включая ввод данных от пользователя (например, переименование сессии, установка resume-токена). Взаимодействие осуществляется через callback-кнопки, поддерживается режим ожидания ввода с сохранением контекста.

## Основные компоненты

- **`manager`** — менеджер сессий, отвечающий за доступ, активацию и управление сессиями.
- **`pending_session_rename`**, **`pending_session_resume`** — словари, отслеживающие пользователей, ожидающих ввода (имя сессии или resume-токен).
- **`build_sessions_menu()`** — формирует клавиатуру со списком сессий.
- **`handle_pending_message()`** — обрабатывает текстовые сообщения от пользователей в режиме ожидания.
- **`handle_callback()`** — обрабатывает действия в меню (выбор, активация, статус и др.).

## Поддерживаемые действия

- `sess_pick` — выбор сессии и отображение детального меню.
- `sess_use` — активация сессии.
- `sess_status` — показ состояния сессии (занятость, время работы, очередь и т.д.).
- `sess_rename` — переход в режим ввода нового имени.
- `sess_resume` — установка resume-токена (с ожиданием ввода).
- `sess_clearqueue` — очистка очереди сообщений.
- `sess_state` — просмотр текущего состояния сессии.
- `sess_close` — закрытие сессии.
- `sess_close_menu` — закрытие интерфейса меню.

## Форматирование и вспомогательные функции

- `send_message` — отправка сообщений через бота.
- `format_ts`, `short_label` — утилиты для форматирования временных меток и обрезки текста.
- Информация о сессии выводится в структурированном виде: идентификатор, инструмент, рабочий каталог, токен, время обновления и др.

## Сохранение и хуки

- Изменения сохраняются через `manager._persist_sessions()`.
- Поддерживаются хуки: `on_before_close` (до закрытия) и `on_close` (после закрытия) — для интеграции внешней логики.

Класс обеспечивает полный цикл управления сессиями с проверкой существования, обратной связью и безопасным взаимодействием через Telegram.

# CLI Proxy Telegram Bridge — Краткое резюме

**CLI Proxy Telegram Bridge** — это Telegram-бот для управления CLI-агентами (Codex, Gemini, Qwen, Claude и др.) через удобный интерфейс. Превращает CLI-инструменты в масштабируемые, визуально контролируемые процессы с поддержкой многопользовательской работы, очередей команд и интеграции с Git и ИИ-агентами.

## Основные возможности
- **Многопользовательские сессии**: изолированные контексты выполнения в разных каталогах, состояние сохраняется в `state.json`.
- **Очередь команд**: управление параллельными задачами, предотвращение конфликтов.
- **HTML-вывод**: отображение результатов с поддержкой Markdown, ANSI-цветов и mermaid-диаграмм (в SVG); ошибки — как код.
- **Кэширование справки**: `toolhelp.json` ускоряет доступ к help-информации инструментов.
- **Git-интеграция**: inline-меню с операциями (status, commit, push, merge, rebase, diff), обработка конфликтов.
- **Файловый доступ**: просмотр и отправка файлов через `/files`.
- **Шаблоны задач**: скрытая команда `/preset` для запуска типовых сценариев.

## Режимы работы
- **Agent**: ReAct-агент с доступом к инструментам.
- **Manager**: мультиагентная оркестрация с декомпозицией задач, автоматическим ревью и автокоммитом (`manager_auto_commit`).
> Режимы не могут быть активны одновременно.

## Конфигурация (`config.yaml`)
Основной файл настройки. Поддерживает `${VAR}`-подстановки и приоритет переменных окружения.

### Ключевые параметры:
- `telegram.token`, `whitelist_chat_ids` — безопасность и доступ.
- `defaults.workdir`, `log_path`, `image_temp_dir` — пути и логирование (с ротацией).
- `tools.*` — настройка CLI-инструментов: команды, prompt, resume, help, `image_cmd`, переменные окружения (`env`).
- `openai_api_key`, `zai_api_key`, `tavily_api_key`, `jina_api_key`, `github_token` — ключи API.
- `presets` — шаблоны задач.
- `mcp.*` — TCP-мост для внешних клиентов.
- `manager_*` — лимиты, таймауты, debug-логи (`.manager/`), автовозобновление, автокоммит.

## Обработка вложений
- **Текстовые файлы** (до 500 КБ): объединяются с подписью и передаются в CLI.
- **Изображения**: обрабатываются при наличии `image_cmd`, текст берётся из подписи.

## Команды
- **Видимые в меню**: `/new`, `/sessions`, `/git`, `/files`, `/agent`, `/manager`, `/tools`, `/toolhelp`.
- **Скрытые**: `/dirs`, `/newpath`, `/use`, `/cwd`, `/setprompt`, `/send`, `/resume`, `/close`, `/status`, `/rename`, `/state`, `/clearqueue`, `/queue`, `/preset`, `/metrics`.
- **Прямой ввод**: через `/send` или с префиксом `>`.

## Восстановление состояния
После перезапуска бот восстанавливает:
- Активные сессии.
- Очередь задач.
- Состояние из `state.json` и `toolhelp.json`.

## Автоодобрение (YOLO)
Активируется флагами:
- Gemini: `--approval-mode yolo`
- Qwen: `--yolo`
- Claude: `--dangerously-skip-permissions`
- Codex: `/approvals full` в чате.

---

**Цель**: превратить CLI-инструменты в управляемые, визуализированные и автоматизированные процессы через Telegram.

Файл содержит справочную информацию о доступных slash-командах в различных CLI-инструментах, связанных с ИИ-ассистентами (Codex, Claude, Gemini, Qwen). Каждая запись включает название инструмента, тип (`tool`), текстовое описание с перечнем команд и временной меткой обновления. Основное назначение — быстрое ознакомление с функционалом командной строки каждого инструмента. Ключевые сущности: `codex`, `claude`, `gemini`, `qwen`. Важные команды: `/help`, `/status`, `/new`, `/exit`, `/quit`, `/clear`, `/settings`, `/auth`, `/chat`, `/model`, `/mcp`. Для получения справки в большинстве случаев используется `/help` или `/?`.

# Git-бот в Telegram: Краткое резюме

Git-бот предоставляет упрощённый интерфейс для работы с Git через Telegram, позволяя выполнять основные операции без знания командной строки. Бот запускает стандартные git-команды и отображает их результат.

## Основные функции
- **Просмотр состояния**: `Status`, `Log`, `Diff`, `Summary`
- **Синхронизация**: `Fetch`, `Pull` (с `--ff-only` для безопасности)
- **Коммиты и отправка**: `Commit`, `Push`
- **Управление изменениями**: `Stash`
- **Слияние веток**: `Merge`, `Rebase`
- **Работа с конфликтами**: отображение конфликтующих файлов, кнопки `Abort`, `Continue`, `Позвать агента`

## Особенности
- Автоматическое определение upstream-ветки
- Поддержка приватных репозиториев через **Personal Access Token**
- Токен задаётся в `config.yaml` → `defaults.github_token`
- Операции выполняются в очереди при занятой сессии

## Ограничения
- Нет автоматического разрешения конфликтов (требуется ручное редактирование меток `<<<<<<<`, `=======`, `>>>>>>>`)
- Зависимость от текущего состояния репозитория
- Отсутствие "умного" автомержа

## Рекомендации
- Начинайте с команды `Status`
- Избегайте слияний без проверки состояния
- Используйте `Abort` при неуверенности в действиях
- Убедитесь, что репозиторий находится в корректном состоянии перед операциями

Настраивает централизованное логирование с разделением по уровням и источникам. Основное назначение — инициализация трёх файлов логов: основной (INFO и выше), ошибок (ERROR и выше) и отдельный для модулей с префиксом `agent.*`. Используются ротирующиеся обработчики (`TimedRotatingFileHandler`) с ротацией в полночь по UTC и временем суток 03:00. Каждый лог-файл сохраняет только один архивный файл (`backupCount=1`), при ротации старый удаляется, новый переименовывается с суффиксом `.1`.

Ключевые сущности:
- Основной лог: путь задаётся через параметр `log_path`.
- Файл ошибок: формируется как `<base>_error.log` в той же директории.
- Файл агентов: `<base>_agent.log`, логирует только сообщения от логгеров с именем `agent` и его подчинённых (через `logging.getLogger("agent")`).
- Формат сообщений: для основного и ошибок — `%(asctime)s %(levelname)s %(message)s`, для агентов — с указанием имени логгера `[%(name)s]`.

Особенности:
- Все предыдущие обработчики корневого логгера удаляются перед настройкой.
- Логгирование необработанных исключений в основном потоке и в потоках перехватывается через замену `sys.excepthook` и `threading.excepthook`.
- Кастомные функции `namer` и `rotator` обеспечивают простую схему ротации без временных меток в имени файла, сохраняя только последнюю резервную копию.

# Режим Manager: Краткое резюме

## Назначение
Режим **Manager** предназначен для автономной оркестрации мульти-агентной разработки: автоматической декомпозиции сложной задачи пользователя на подзадачи, их последовательного выполнения, ревью и финального отчёта. Режим активируется командой `/manager` и отключает стандартный Agent-режим.

## Ключевые сущности
- `ManagerOrchestrator` — центральный класс, управляющий полным циклом: декомпозиция, выполнение, ревью, арбитраж, отчёт.
- `DevTask` — единица работы с описанием, критериями приёмки, статусом, зависимостями и попытками.
- `ProjectPlan` — структурированный план проекта, содержащий список задач.
- `ReviewResult` — результат проверки задачи агентом-ревьюером.
- Профили: `developer_profile` (для разработки), `reviewer_profile` (только чтение).
- Персистентность: состояние сохраняется в `MANAGER_PLAN.json`.

## Основные функции
1. **Декомпозиция задачи**:
   - Двухфазный процесс: CLI-анализ проекта → нормализация вывода в JSON через LLM.
   - Использует промпты: `manager_decompose_prompt`, `manager_normalize_prompt`.
   - При сбое — fallback-план с одной задачей.
   - Таймаут: `manager_decompose_timeout_sec` (300 с).

2. **Выполнение и ревью**:
   - `_delegate_develop()`: запуск разработки с таймаутом (`manager_dev_timeout_sec`, 600 с), обрезка отчёта (`manager_dev_report_max_chars`, 8000).
   - `_delegate_review()`: ревью с возвратом JSON; при ошибках — нормализация через `REVIEW_NORMALIZE_SYSTEM`.
   - `_make_decision()`: LLM-арбитраж по критериям приёма (`manager_arbitration_prompt`), независимо от ревью.

3. **Управление состоянием**:
   - Поддержка зависимостей, попыток (`max_attempts`, по умолчанию 3), статусов: `pending`, `in_progress`, `in_review`, `rejected`, `failed`, `blocked`, `approved`.
   - Автоматическая блокировка при падении зависимостей.
   - Восстановление после сбоев: перезапуск с последней активной задачи.

4. **Финализация**:
   - `_compose_final_report()`: генерация итогового Markdown-отчёта (`manager_final_report_prompt`).
   - Авто-коммит в Git при успехе (если `manager_auto_commit=true`).

## Персистентность и восстановление
- План сохраняется в `MANAGER_PLAN.json` (блокировка при доступе).
- Функции: `save_plan`, `load_plan`, `archive_plan` (в `.manager_archive`).
- Поддержка возобновления сессии (`manager_auto_resume=true` по умолчанию).
- Ручной сброс: `/manager reset`.

## Интеграция и управление
- Активация: `/manager`, отключение при `/interrupt` или сбое.
- Маршрутизация через `bot.py` → `manager_orchestrator.run()`.
- Уведомления: прогресс-бары и статусы в Telegram (`_notify_progress()`).

## Настройки (config.yaml)
```yaml
manager_max_tasks: 10
manager_max_attempts: 3
manager_decompose_timeout_sec: 300
manager_dev_timeout_sec: 600
manager_review_timeout_sec: 300
manager_auto_resume: true
manager_auto_commit: true
manager_dev_report_max_chars: 8000
```

## Ограничения (v1)
- Последовательное выполнение (без параллелизма).
- Нет репланирования в процессе.
- Ревью — через встроенный LLM (без отдельной CLI-сессии).
- Работает только в текущей CLI-сессии.

## Планы на v2
- Параллельное выполнение задач.
- Репланирование после групп задач.
- Выделенный ревью-агент (например, Claude).
- Интерактивное редактирование плана.
- Многомодельное голосование при ревью.

## Обработка ошибок
- CLI недоступен → попытка перезапуска → `failed`.
- Ошибки OpenAI → fallback-декомпозиция, ревью без LLM невозможно.
- Пустой вывод CLI → ошибка попытки.
- Каскадные падения → блокировка зависимых задач.
- Ввод пользователя → обработка через очередь/прерывание.

## Тестирование
Покрывает: декомпозицию, выбор задачи, парсинг ревью, хранение, полный цикл (с моками `session.run_prompt`, `chat_completion` и `Executor.run`).

# Конфигурационный файл (YAML)

Конфигурационный файл в формате YAML для настройки Telegram-бота с поддержкой инструментов, внешних сервисов, MCP-серверов и мультиагентного взаимодействия. Загружается через `load_config`, который автоматически подтягивает переменные окружения из `.env`-файла в той же директории. Поддерживает backward compatibility (например, `big_model_to_use` → `openai_big_model`) и сохраняет путь к файлу в итоговой структуре `AppConfig`.

## Основные секции

- **`telegram`** (`TelegramConfig`)  
  Настройки Telegram-бота: `token`, список разрешённых `chat_id`.

- **`tools`** (`ToolConfig`)  
  Описание внешних инструментов: команды, режимы выполнения, регулярные выражения для определения состояний, переменные окружения, автоматические команды.

- **`defaults`** (`DefaultsConfig`)  
  Глобальные настройки:  
  - Рабочая директория, таймауты, лимиты памяти и вывода  
  - Параметры API: OpenAI, Zai, Tavily, Jina, GitHub  
  - Логирование, обработка изображений, уточняющие вопросы  
  - Поведение менеджера задач

- **`mcp`** (`MCPConfig`)  
  Встроенный MCP-сервер: включение, `host`, `port`, `token`.

- **`mcp_clients`** (`MCPClientServerConfig`)  
  Клиенты для подключения к внешним MCP-серверам: имя, команда запуска, транспорт (`stdio`/`http`), URL, окружение, заголовки, таймауты.

- **`mcp_servers`**  
  Альтернативный способ указания внешних MCP-серверов: имя, URL, транспорт (по умолчанию `http`).

- **`presets`** (`PresetConfig`)  
  Пресеты сценариев: имя и шаблон промпта для быстрого запуска.

## Особенности

- Сохранение порядка ключей при записи.
- Поддержка кириллицы (с экранированием при `allow_unicode=False`).
- Используется для инициализации объекта `AppConfig`.

Файл предоставляет функциональность для управления состоянием сессий и активного состояния в виде JSON-файла. Основное назначение — хранение, загрузка и обновление данных о сессиях, включая идентификатор сессии, используемый инструмент, рабочую директорию, токен возобновления, краткое описание, имя и временные метки.

Ключевые сущности:
- `SessionState` — дата-класс, описывающий состояние сессии: `session_id`, `tool`, `workdir`, `resume_token`, `summary`, `updated_at`, `name`.
- `ActiveState` — дата-класс для хранения активной сессии: `tool`, `workdir`, `updated_at`, `session_id`.

Состояние хранится в JSON-файле с двумя основными секциями:
- `_sessions` — словарь сессий, где ключ — `session_id`, значение — данные сессии (предпочтительный формат).
- `_active` — информация об активной сессии.

Поддерживается миграция с устаревшего формата, где сессии хранились по ключу `{tool}::{workdir}` на верхнем уровне. Такие записи обрабатываются как fallback при отсутствии данных в `_sessions`.

Ключевые функции:
- `load_state` / `save_state` — загрузка и сохранение состояния сессий с поддержкой нового и старого форматов.
- `get_state` — получение состояния по `session_id` или по комбинации `tool` и `workdir` (если совпадение уникально).
- `load_active_state` / `set_active_state` / `clear_active_state` — управление активной сессией.
- `update_state` — обновление состояния (устаревшее, используется только при отсутствии `_sessions`).
- `delete_state` — удаление устаревшей записи по ключу `tool::workdir`.

Файл обеспечивает совместимость с предыдущими версиями, предотвращает конфликты при совпадающих `tool` и `workdir`, использует потокобезопасные операции чтения/записи и корректно обрабатывает ошибки ввода-вывода.

Файл определяет реестр команд для бота, возвращая список словарей с описанием каждой команды. Каждая команда содержит имя (`name`), описание (`desc`), ссылку на обработчик (`handler`) и флаг `menu`, указывающий, должна ли команда отображаться в основном меню. Реестр используется для регистрации доступных команд в интерфейсе бота, обеспечивая централизованное управление функционалом. Основные сущности — это команды для управления сессиями, файлами, Git, агентами, инструментами и метриками. Команды с `menu=True` доступны через меню, остальные предназначены для прямого вызова.

Класс `Metrics` предназначен для сбора и отслеживания метрик работы приложения в режиме реального времени. Основные сущности — счётчики событий и временные отметки. Поддерживает инкремент счётчиков по ключу, фиксацию вывода и формирование текстового снимка состояния. Ключевые счётчики: `messages`, `commands`, `outputs`, `errors`, `queued`. При каждом вызове `observe_output` обновляется количество символов последнего вывода и временная метка. Метод `snapshot` возвращает строку с общим временем работы, значениями счётчиков и информацией о последнем выводе (время, сколько прошло, размер в символах).

Класс `MCPBridge` реализует асинхронный TCP-сервер для взаимодействия с ботом через текстовые JSON-запросы. Сервер ожидает подключений, принимает входящие сообщения, проверяет токен авторизации, выполняет обработку текстового запроса через `bot_app.run_prompt_raw` и возвращает результат. Поддерживает построчную передачу данных, где каждое сообщение завершается символом новой строки.

Ключевые сущности:  
- `config.mcp.enabled` — включение/отключение сервера.  
- `config.mcp.host`, `config.mcp.port` — параметры привязки сервера.  
- `config.mcp.token` — опциональный токен для аутентификации.  

Формат запроса:  
```json
{"token": "токен", "prompt": "текст запроса", "session_id": "идентификатор сессии"}
```

Формат ответа:  
```json
{"ok": true, "output": "результат"}  
{"ok": false, "error": "описание ошибки"}
```

Сервер корректно завершает работу при вызове `stop()`, закрывая все соединения. Ошибки обработки логируются с помощью `logging.exception`.

# Telegram-бот для управления агентом: Краткое резюме

## Назначение
Конфигурируемое Telegram-приложение для управления агентом с поддержкой сессий, песочницы, Git-операций и плагинов. Основано на `python-telegram-bot`, обеспечивает асинхронную обработку команд, файлов, диалогов и интеграцию с MCP.

## Ключевые компоненты
- **`SessionManager`** — управление жизненным циклом сессий.
- **`OrchestratorRunner` / `ManagerOrchestrator`** — выполнение и координация задач агента и менеджера.
- **`GitOps`** — выполнение Git-операций (клонирование, коммиты).
- **`MCPBridge`** — интеграция с внешней системой MCP.
- **`SessionUI`** — интерфейс для управления сессиями через inline-кнопки.
- **`Metrics`** — сбор и учёт метрик использования.

## Основные функции
- Асинхронная обработка команд, сообщений, вложений и callback-запросов.
- Поддержка сессий с очередями, блокировками (`run_lock`) и буферизацией ввода.
- Управление агентом и менеджером: включение, остановка, прерывание, очереди задач.
- Интерактивное меню: выбор сессий, плагинов, состояний, навигация по файловой системе.
- Работа с файлами: отправка, загрузка, удаление, пагинация, ограничение по размеру.
- Поддержка Git: клонирование репозиториев, ввод сообщений коммитов.
- Интеграция с плагинами: приоритетная обработка, фильтрация по состоянию агента.

## Конфигурация и настройки
- **`CONFIG_PATH`** — путь к `config.yaml`.
- **`.env`** — загрузка переменных окружения.
- **`telegram.whitelist_chat_ids`** — ограничение доступа.
- **`sandbox_root` / `AGENT_SANDBOX_ROOT`** — корневая директория песочницы.
- **`dirs_root`** — корень для пользовательских директорий.
- **`workdir`** — рабочая директория по умолчанию.
- **`image_max_mb`, `image_temp_dir`** — ограничения и хранение изображений.

## Обработка вывода и логирование
- **ANSI → HTML** — рендеринг с порогом `_HTML_PROCESS_THRESHOLD_CHARS` (100K).
- **Суммаризация** — при превышении `_SUMMARY_PREPARE_THRESHOLD_CHARS` (20K).
- **Логи**: `bot.log`, `bot_error.log`, `agent.log` с ротацией (ежедневно, 3 файла).
- **`agent_logger`** — отдельный логгер для компонентов агента.
- Перехват исключений через `sys.excepthook` и `threading.excepthook`.

## Особенности
- Поддержка MarkdownV2 с экранированием.
- Отправка сообщений с повторами при сетевых ошибках (до 5 попыток).
- Потокобезопасная обработка HTML и суммаризации через `ProcessPoolExecutor`.
- Автоматическая очистка временных файлов и песочницы.
- Интеграция с `config.yaml` и `.env`.
- Динамическое управление inline-кнопками и пагинацией.
- Сохранение состояния сессий через `manager._persist_sessions()`.

## Команды
- `/new`, `/use`, `/close`, `/sessions` — управление сессиями.
- `/agent`, `/manager` — включение/выключение компонентов.
- `/status`, `/state` — просмотр состояния.
- `/send`, `/cwd`, `/git`, `/files`, `/toolhelp` — работа с инструментами и файлами.
- `/queue`, `/clearqueue`, `/interrupt` — управление очередями и задачами.

## Запуск
- Точка входа: `__main__`.
- Инициализация: загрузка `.env`, `config.yaml`, построение приложения через `build_app`.
- Режим: polling.
- Обработка ошибок и пост-инициализация встроены в `Application`.

## Безопасность
- Проверка путей через `is_within_root`.
- Аутентификация по `whitelist_chat_ids`.
- Очистка активных диалогов при смене сессии.
- Проверка доступности инструментов через `shutil.which`.

# Асинхронный модуль генерации резюме и сообщений коммитов с OpenAI

Модуль предоставляет асинхронные функции для краткого резюмирования текстов (например, логов, диалогов) и генерации сообщений коммитов с использованием OpenAI API. Основной акцент — на сохранении ключевой информации из конца текста и предсказуемом выводе.

## Ключевые возможности
- **Асинхронная обработка** с использованием `AsyncOpenAI`.
- **Кэширование клиентов** по парам `(api_key, base_url)` для повышения производительности и избежания утечек соединений.
- **Адаптивные настройки** длины вывода и контекста в зависимости от объёма и языка входного текста.
- **Нормализация текста** в отдельном потоке (`asyncio.to_thread`) для неблокирующей работы.

## Основные функции
- `summarize_text()` — возвращает краткое резюме или `None`, если конфигурация недоступна.
- `summarize_text_with_reason()` — то же, с возвратом причины при ошибке.
- `suggest_commit_message_async()` — генерирует однострочное сообщение коммита (~80 символов).
- `suggest_commit_message_detailed_async()` — возвращает заголовок и тело с до 4 пунктов.
- `_summarize_with_cfg()` — внутренняя логика резюмирования с динамическими параметрами.
- `_tail_digest()` — извлекает значимые строки из конца текста (например, по маркерам: "добавил", "исправил").

## Настройки
- **Модель**: выбирается из `OPENAI_BIG_MODEL` или `OPENAI_MODEL` (через env).
- **API ключ и URL**: `OPENAI_API_KEY`, `OPENAI_BASE_URL` (по умолчанию `https://api.openai.com`).
- **Токены**: `max_tokens` рассчитывается динамически (~4 символа на токен для русского).
- **Длина вывода**: `max_chars` — ограничение с обрезкой и суффиксом `...(обрезано)...`.
- **Температура**: `0.2` — низкая случайность для сжатого и предсказуемого вывода.
- **Обрезка входа**: до 12000 символов.
- **Форматирование**: `_strip_cli_preamble` удаляет префиксы вроде "User:".

## Обработка ошибок и отказоустойчивость
- Таймауты: `httpx.Timeout` (подключение, чтение, запись).
- Обработка HTTP-статусов, сетевых ошибок и исключений.
- Поддержка синхронных вызовов через `asyncio.run` при отсутствии event loop.

## Требования
- `OPENAI_API_KEY` и указанная модель.
- Библиотеки: `openai`, `httpx`, `asyncio`.

# Класс `GitOps` — Работа с Git в Telegram-боте

Класс `GitOps` предоставляет асинхронный интерфейс для выполнения Git-операций через Telegram-бота, интегрированный с системой сессий (`SessionManager`) и поддерживающий интерактивное взаимодействие через inline-кнопки и callback-запросы.

## Основные возможности
- Выполнение Git-команд: `commit`, `fetch`, `pull`, `merge`, `rebase`, `diff`, `log`, `stash`, `push`.
- Интерактивное управление операциями: выбор веток, подтверждение действий, разрешение конфликтов.
- Автоматическое формирование сообщений коммита (с поддержкой OpenAI при наличии API-ключа).
- Отображение статуса репозитория, истории, отставания/опережения относительно upstream.
- Генерация HTML-отчётов и отправка справки из `git.md`.

## Ключевые сущности
- `Session` — активная сессия пользователя.
- `SessionManager` — управление сессиями.
- `config.github_token` — токен для аутентификации в Git (через `GIT_ASKPASS`).
- Внутренние состояния по `chat_id`:  
  - `git_branch_menu`, `git_pending_ref`, `git_pull_target`, `pending_git_commit` — хранение промежуточных данных операций.

## Основные методы
- **`_run_git()`** — асинхронное выполнение Git-команд с перехватом вывода.
- **`git_env()`**, `_ensure_git_askpass()` — безопасная передача токена аутентификации.
- **`build_git_keyboard()`** — построение основного меню и вспомогательных клавиатур (выбор ветки, подтверждение, конфликты).
- **Проверки состояния**:  
  - `ensure_git_session()`, `ensure_git_repo()`, `ensure_git_not_busy()` — валидация окружения и блокировка параллельных операций.
- **Анализ репозитория**:  
  - `_git_current_branch`, `_git_upstream`, `_git_ahead_behind`, `_git_in_progress`, `_git_conflict_files`.
- **Формирование отчётов**:  
  - `_git_status_text`, `_git_commit_context`, `_build_commit_body`, `_sanitize_commit_message`.

## Обработка событий
- `handle_callback()` — обработка inline-действий: `git_status`, `git_fetch`, `git_pull`, `git_help`, `git_confirm_merge` и др.
- `handle_pending_commit_message()` — обработка ввода сообщения коммита, включая отмену и валидацию.
- Поддержка разрешения конфликтов: показ `diff`, вызов агента, продолжение/отмена операции.

## Безопасность и настройки
- Токен GitHub передаётся через временный `GIT_ASKPASS`-скрипт.
- Все операции асинхронны, не блокируют бота.
- Вывод команд обрезается до 4000 символов.
- Временные HTML-файлы удаляются после отправки.
- Кодировка: UTF-8 с игнорированием ошибок декодирования.

## Зависимости
- Git должен быть доступен в `PATH`.
- Требуется `github_token` в конфиге для приватных репозиториев.
- Наличие файлов: `git.md` (справка), права на чтение/запись в рабочей директории.

Файл содержит функции для работы с файловой системой в контексте Telegram-бота, позволяя пользователю навигацию по каталогам через интерфейс с кнопками. Основное назначение — безопасное отображение и выбор директорий с поддержкой пагинации и ограничением доступа к корневому каталогу.

Ключевые сущности: словари `dirs_menu`, `dirs_base`, `dirs_page`, `dirs_root`, хранящие состояние каталогов для каждого `chat_id`; функции `prepare_dirs` и `build_dirs_keyboard` для подготовки списка директорий и построения интерактивной клавиатуры.

Функция `prepare_dirs` проверяет доступ к каталогу, читает поддиректории, сохраняет состояние и возвращает сообщение об ошибке или `None` при успехе. Параметр `allow_empty` позволяет обрабатывать отсутствие подкаталогов без ошибки.

Функция `build_dirs_keyboard` формирует `InlineKeyboardMarkup` с кнопками для выбора каталога, навигации (вверх, назад, далее), а также действиями: использовать текущий каталог, создать каталог, выполнить git clone или ввести путь вручную. Используется пагинация по 10 элементов на страницу. Каждая кнопка генерирует callback-данные для обработки в боте.

Модуль для управления справочной информацией по инструментам (tool help) в формате JSON-файла. Основное назначение — хранение, обновление и чтение описаний инструментов с меткой времени последнего изменения.

Ключевая сущность — `ToolHelpEntry`, dataclass, содержащий поля: `tool` (название инструмента), `content` (текст справки), `updated_at` (временная метка обновления в формате Unix time).

Основные функции:
- `load_toolhelp(path)` — загружает данные из JSON-файла по указанному пути, возвращает словарь `tool_name → ToolHelpEntry`.
- `save_toolhelp(path, data)` — сохраняет словарь с записями в JSON-файл с отступами и поддержкой Unicode.
- `update_toolhelp(path, tool, content)` — добавляет или обновляет запись для инструмента, автоматически устанавливая текущее время как `updated_at`.
- `get_toolhelp(path, tool)` — возвращает объект `ToolHelpEntry` для указанного инструмента или `None`, если не найден.

Файл хранится в формате JSON с ключами: `tool`, `content`, `updated_at`. При отсутствии файла или пустом содержимом возвращается пустой словарь.

Файл предоставляет утилиты для чтения и загрузки переменных окружения из `.env`-файлов. Основные функции:

- `parse_dotenv(text: str) -> Dict[str, str]` — разбирает строку с содержимым `.env`-файла, возвращает словарь пар ключ-значение. Поддерживает:
  - игнорирование пустых строк и комментариев (начинающихся с `#`);
  - ключи и значения в формате `KEY=value`;
  - опциональный префикс `export `;
  - значения в одинарных или двойных кавычках (кавычки удаляются);
  - inline-комментарии только при наличии пробела перед `#` (например, `KEY=value # comment`), не затрагивает `#` внутри значений или кавычек.

- `load_dotenv(path: str, override: bool = False) -> Dict[str, str]` — загружает переменные из файла по указанному пути в `os.environ`. Если `override=False`, существующие переменные окружения не перезаписываются. Возвращает словарь загруженных переменных.

- `load_dotenv_near(path: str, filename: str = ".env", override: bool = False)` — удобная функция для загрузки `.env`-файла из директории, указанной в `path`.

Поддерживает стандартные сценарии использования: чтение защищённых переменных, обработку кавычек, избежание перезаписи существующих значений. Используется, например, для конфигурации приложений на основе локальных файлов окружения.

Список зависимостей Python-пакетов для реализации Telegram-бота с расширенными функциями обработки текста, медиа и веб-контента. Основное назначение — поддержка бота, взаимодействующего с OpenAI API, выполняющего поиск в интернете, конвертацию текста в речь, извлечение текста из PDF, YouTube-транскрипций, веб-страниц и форматирование Markdown для Telegram.

Ключевые сущности:
- `python-telegram-bot` — основа для построения Telegram-бота.
- `openai` — интеграция с моделями OpenAI (например, GPT).
- `duckduckgo-search` — выполнение веб-поиска.
- `gTTS` — преобразование текста в речь.
- `youtube-transcript-api` — извлечение субтитров с YouTube.
- `pdfminer.six`, `beautifulsoup4`, `trafilatura` — парсинг PDF и веб-страниц.
- `md2tgmd` — конвертация Markdown-подобного текста в формат, совместимый с Telegram (HTML-разметка).
- `PyYAML` — работа с YAML-конфигурациями.
- `httpx`, `requests` — HTTP-запросы (асинхронные и синхронные).
- `markdown-it-py` с плагинами — парсинг и обработка Markdown.
- `pexpect`, `ansi2html` — обработка командной строки и преобразование ANSI-цветов в HTML.

Важные настройки и особенности:
- Версии пакетов зафиксированы, кроме `openai`, `httpx`, `beautifulsoup4`, `trafilatura`, `pdfminer.six`, где допускается обновление (указаны минимальные версии).
- Поддержка асинхронных операций через `httpx` и `python-telegram-bot==20.7`.
- Подготовка к генерации ответов с внешними данными: поиск, цитирование, озвучка, форматирование.

Модуль предоставляет тонкую обёртку для работы с вводом-выводом через Telegram с поддержкой повторных попыток при сетевых ошибках. Основное назначение — надёжная отправка и редактирование сообщений, а также отправка документов и удаление сообщений с обработкой временных сбоев сети.

Ключевая сущность — класс `TelegramIO`, инкапсулирующий логику повторных попыток при взаимодействии с API Telegram. Поддерживает до 5 попыток отправки с экспоненциальной задержкой (начиная с 2 секунд). Обрабатываются исключения `NetworkError` и `TimedOut`, остальные ошибки логируются и приводят к отказу.

Поддерживаемые операции:
- `send_message` — отправка текстового сообщения с опциональным сохранением идентификатора через переданную функцию `record_message`.
- `send_document` — отправка файла с подтверждением успеха.
- `delete_message` — удаление сообщения по ID.
- `edit_message` — редактирование текста существующего сообщения.

Параметр `record_message` (опциональный) — функция, вызываемая при успешной отправке сообщения для сохранения соответствия `chat_id` и `message_id`.

# Резюме: Утилиты обработки текста с ANSI, Markdown и Mermaid

Модуль предоставляет набор вспомогательных функций для преобразования терминального вывода (с ANSI-кодами, Mermaid-диаграммами и служебными метками) в чистый, валидный HTML, готовый к отображению в браузере.

## Основные возможности
- **Обработка ANSI-кодов**:  
  - `strip_ansi()` — удаление ANSI-последовательностей.  
  - `ansi_to_html()` — преобразование ANSI-размеченного текста в HTML с цветами, жирным шрифтом, списками и таблицами.  
  - Цвета (30–37, 90–97) сопоставляются с HTML-цветами через `_ANSI_FG_COLORS`.  
  - Используются регулярные выражения `_ANSI_RE` и `_LOOSE_ANSI_RE`.

- **Поддержка Mermaid**:  
  - `_MERMAID_BLOCK_RE` выделяет блоки Mermaid.  
  - `_render_mermaid_svg()` рендерит диаграммы через внешний сервис [mermaid.ink](https://mermaid.ink).

- **Нормализация текста**:  
  - `normalize_text()` удаляет строки с префиксом `mcp:` (через `_MCP_LINE_RE`) и устраняет дублирование блоков.  
  - `build_preview()` — обрезка текста с пометкой усечения.

- **Работа с HTML и файлами**:  
  - `escape_html_text()` — экранирование HTML-символов.  
  - `make_html_file()` — создание временного HTML-файла.  
  - `is_within_root()` — проверка безопасного пути в файловой системе.

- **Сборка и обработка команд**:  
  - `build_command()` — подстановка значений (`{prompt}`, `{resume}`, `{image}`) в шаблон с фильтрацией неактуальных флагов.  
  - `resolve_env_value()` — раскрытие переменных окружения.

- **Детекция сессий и приглашений**:  
  - `detect_prompt_regex()` — определение приглашения ввода по последним строкам.  
  - `detect_resume_regex()` — поиск идентификаторов сессии (thread_id, conversation_id и др.) по жёстко заданным шаблонам.

## Вспомогательные функции
- `sandbox_*` — работа с путями в песочнице.  
- `_TICK_OR_TIME_RE` — извлечение временных меток.

## Зависимости и особенности
- Модули: `os`, `re`, `html`, `tempfile`.  
- Глобальное состояние (`out`, `fg_color`, `bold`, `open_span`) — требует осторожности при использовании в многопоточной среде.  
- Регулярные выражения и шаблоны частично зашиты в код.

Результат — структурированный HTML с инлайн-стилями, поддержкой цветов, диаграмм и безопасной подстановкой данных.

# Управление сессиями выполнения инструментов

Файл реализует асинхронное управление сессиями выполнения внешних инструментов (tools) с поддержкой headless и интерактивных режимов. Основные компоненты — классы `Session` и `SessionManager`.

## Основные сущности

### `Session`
Отвечает за жизненный цикл сессии:
- Хранит состояние: ID, `ToolConfig`, рабочую директорию, флаги активности, очередь команд, процессы и метаданные (git-состояние, временные метки, данные агента).
- Поддерживает два режима выполнения:
  - **Headless**: через `asyncio.subprocess`, с безопасным чтением вывода и обработкой таймаутов.
  - **Интерактивный**: через `pexpect`, с ожиданием приглашений (`prompt_regex`) и возобновлением по токену (`resume_token`).
- Обеспечивает:
  - Асинхронное выполнение с защитой от зависаний (проверка PID, принудительное завершение).
  - Обработку сигналов (`SIGINT`, `SIGTERM`, `SIGKILL`) и graceful shutdown (`grace_sec`).
  - Отслеживание активности по выводу и тикетам (`extract_tick_tokens`).
  - Автоматическое выполнение команд (`auto_commands`) при инициализации.
  - Поддержку изображений через `image_cmd` (если доступно).
- Логирует выполнение, ошибки и диагностику состояния процесса.

### `SessionManager`
Централизованное управление сессиями:
- Создание, активация, переключение, восстановление и закрытие сессий.
- Хранение сессий по уникальному ID (предотвращение конфликтов при совпадении tool + workdir).
- Автоматическая генерация ID и поддержка счётчика.
- Сохранение и восстановление состояния:
  - Сериализация в файл по пути `config.defaults.state_path`.
  - Валидация при восстановлении (наличие инструмента и директории).
  - Отдельное хранение активной сессии (`active_session_id`).
- Уведомления об изменениях через `_fire_session_change()`.

## Ключевые параметры

| Параметр | Описание |
|--------|--------|
| `tool.mode` | Режим выполнения: `headless` или `interactive` |
| `tool.cmd`, `tool.headless_cmd`, `tool.interactive_cmd` | Шаблоны команд запуска |
| `tool.env` | Переменные окружения (с разрешением через `resolve_env_value`) |
| `tool.prompt_regex`, `tool.resume_regex` | Регулярные выражения для приглашения и токена возобновления |
| `tool.auto_commands` | Команды, выполняемые при старте сессии |
| `idle_timeout_sec` | Таймаут бездействия перед завершением сессии |
| `resume_token` | Токен для возобновления сессии |
| `state_path` | Путь к файлу сохранения состояния сессий |

## Особенности реализации

- **Асинхронность и отказоустойчивость**: Использование `asyncio` и `pexpect`, обработка ошибок через `try/except`.
- **Сериализация**: Очередь сообщений нормализуется (строки → `{text, dest}`), состояние сохраняется целиком.
- **Автоконфигурация**: Функции `detect_prompt_regex`, `detect_resume_regex`, `save_config` обновляют настройки динамически.
- **Интеграции**: Поддержка `config`, `pexpect`, обработка окружения и help-команд (`run_tool_help`).

## Назначение
Обеспечивает устойчивое, многорежимное выполнение инструментов с сохранением состояния между перезапусками, корректным управлением активной сессией и гибкой конфигурацией.

Конфигурационный файл для Telegram-бота, управляющего CLI-агентами (Codex, Claude, Gemini, Qwen) в headless-режиме. Определяет параметры подключения к Telegram, настройки инструментов, режимы работы, переменные окружения, пути и таймауты. Поддерживает мультиагентную оркестровку (режим manager), включая автоматическое выполнение, резюмирование и коммиты в Git. Включает фильтрацию чатов через `whitelist_chat_ids`, настройки обработки изображений, логирования, временных файлов и памяти. Доступ к MCP-серверам (внешние инструменты) настраивается через `mcp_servers` с указанием URL. Пресеты позволяют быстро запускать типовые команды (тесты, линтер). Ключевые параметры: `token`, `workdir`, `idle_timeout_sec`, `manager_auto_commit`, `image_max_mb`, `clarification_keywords`, `env` для API-ключей, `cmd` и `resume_cmd` для кастомизации вызовов агентов.

Преобразует текст для корректного отображения в Telegram с использованием MarkdownV2. Основная логика — попытка использовать библиотеку `md2tgmd` для точного экранирования специальных символов и нормализации Markdown-разметки. При отсутствии или ошибке `md2tgmd` применяется резервный метод, экранирующий все специальные символы MarkdownV2: `_ * [ ] ( ) ~ ` > # + - = | { } . ! \`. Символы экранируются двойным обратным слэшем. Функция безопасно обрабатывает `None`, возвращая пустую строку. Основная сущность — регулярное выражение `_MDV2_RE`, определяющее подлежащие экранированию символы.

Класс `Dispatcher` отвечает за выбор профиля исполнителя (`ExecutorProfile`) для каждого шага плана (`PlanStep`). На текущий момент поддерживается только один профиль по умолчанию, инициализируемый на основе конфигурации приложения (`AppConfig`) и реестра инструментов (`ToolRegistry`). 

Ключевые сущности:
- `AppConfig` — конфигурация приложения.
- `ToolRegistry` — реестр доступных инструментов.
- `ExecutorProfile` — профиль исполнителя, определяющий поведение при выполнении шага.
- `PlanStep` — шаг плана, для которого выбирается профиль.

Важные настройки:
- Инициализация профиля по умолчанию через `build_default_profile`.
- Логирование инициализации и выбора профиля на уровне `INFO`.

В будущем логику выбора профиля можно расширить в зависимости от типа шага, его параметров или других условий.

Модуль отвечает за управление долговременной памятью проекта: определяет, какие сведения стоит сохранить, и сжимает память при превышении лимита. Основные функции — `decide_memory_save` и `compress_memory`. Первая анализирует диалог и решает, нужно ли сохранить информацию в одной из категорий: preference, decision, config, agreement (по убыванию приоритета), возвращая тег и содержание записи. Вторая сжимает существующую память до заданного количества символов, сохраняя формат записей и приоритет по категориям. Использует LLM через `chat_completion` с жёстко заданными системными промптами. Формат сохраняемых записей: `- YYYY-MM-DD HH:MM: [TAG] текст`. Чувствительные и временные данные не сохраняются.

Модуль предоставляет асинхронные функции для взаимодействия с OpenAI API через `AsyncOpenAI`. Основное назначение — выполнение запросов к модели с использованием настроек из `AppConfig`.

Ключевые сущности:
- `get_openai_config` — извлекает из конфигурации API-ключ, модель и базовый URL; возвращает `None`, если обязательные параметры отсутствуют.
- `build_client` — создаёт экземпляр `AsyncOpenAI` на основе конфигурации; возвращает клиент и имя модели или `None`.
- `chat_completion` — выполняет асинхронный запрос к чат-модели с системным и пользовательским сообщением; поддерживает опциональный `response_format`.

Важные настройки:
- `openai_api_key`, `openai_model`, `openai_base_url` — задаются в `config.defaults`; последний по умолчанию равен `https://api.openai.com`.
- Температура фиксирована на уровне `0.2`.
- Используется `chat.completions.create` с двумя сообщениями: `system` и `user`.
- При отсутствии ответа или ошибке возвращается пустая строка.

# Резюме: Политика безопасности и ограничений

Документ описывает правила безопасного использования вычислительной среды, направленные на предотвращение выполнения ресурсоёмких, опасных или бесполезных операций. Запрещены:

- Бесконечные циклы и тяжёлые вычисления  
- Сетевое сканирование и атаки на сервисы  
- Доступ к чужим данным и системным ресурсам  

Разрешены легальные действия: установка пакетов, запуск скриптов, управление файлами, планирование задач и корректная работа с сетью. Приведены рекомендации по запуску сервисов, использованию инструментов и эффективному расходованию памяти.

Модуль отвечает за построение плана выполнения задачи пользователя в виде последовательности шагов. Использует LLM для генерации структурированного плана в формате JSON, который затем парсится и валидируется. Основная функция — `plan_steps`, возвращающая список объектов `PlanStep`, описывающих действия, уточнения или параллельные задачи.

Ключевые сущности:  
- `PlanStep` — модель шага с полями: `id`, `title`, `instruction`, `step_type`, `depends_on`, `parallelizable`, `parallel_group`, `ask_question`, `ask_options`.  
- `step_type` может быть `task` (обычный шаг) или `ask_user` (требует уточнения у пользователя).  
- При необходимости уточнения автоматически добавляется шаг с `ask_user`, если это не предусмотрено LLM.  
- Поддержка параллельного выполнения через флаги `parallelizable` и `parallel_group`, с обязательным обоснованием в `parallelizable_reason`.  

Важные настройки и поведение:  
- Запрос к LLM отправляется с системным промптом `_PLANNER_SYSTEM`, требующим строгий JSON-формат ответа.  
- Нестабильный вывод LLM обрабатывается через `_extract_json_object`, извлекающий JSON из текста или код-фен.  
- Гарантируется уникальность `id` шагов через `_ensure_unique_step_ids` с использованием временных меток и UUID.  
- Если LLM возвращает пустой или невалидный JSON, используется fallback-план с одним шагом.  
- Дополнительная проверка на необходимость уточнения через `needs_clarification` из модуля эвристик.

# Резюме документации

Файл содержит системные промпты и шаблоны для автоматизации управления разработкой ПО с использованием ИИ-ассистентов. Обеспечивает автономный цикл: анализ проекта, декомпозиция задач, реализация и ревью.

## Основные компоненты

- **`DECOMPOSE_INSTRUCTION`** — промпт для анализа проекта и генерации плана задач. Выход: строгий JSON с `project_analysis` и списком атомарных задач (описание, критерии приёмки, зависимости).
- **`DECOMPOSE_NORMALIZE_SYSTEM`** — нормализует неструктурированный ответ в валидный JSON, восстанавливает пропущенные ID и критерии.
- **`DEV_INSTRUCTION_TEMPLATE`** — задание для ИИ-разработчика: описание задачи, контекст, критерии приёмки, указание на автономное выполнение с отчётом.
- **`REVIEW_INSTRUCTION_TEMPLATE`** — шаблон проверки реализации: анализ отчёта, соответствие ТЗ и критериям приёмки.

## Ключевые настройки

- Максимум 10 задач в декомпозиции (`{max_tasks}`).
- Обязательный строгий JSON-формат ответов без дополнительного текста.
- Полная автономность: запрет на уточнения у пользователя.
- Все вызовы LLM используют модель из `defaults.openai_model`.

## Статус ревью

```json
{
  "approved": false,
  "summary": "Не удалось проверить выполнение критериев из-за отсутствия данных.",
  "comments": "Не предоставлены описание задачи, отчёт разработчика, файлы или тесты для анализа. Требуется дополнительная информация для проведения ревью.",
  "files_reviewed": [],
  "tests_passed": null
}
```

Файл предоставляет функции для работы с локальным файлом памяти `MEMORY.md`, используемым для хранения временных записей в формате Markdown. Основное назначение — ведение журнала событий с поддержкой тегов, дедупликацией, компрессией по приоритету и ограничением по размеру.  

Ключевые сущности:  
- `MEMORY.md` — файл, хранящий записи в формате `- ГГГГ-ММ-ДД ЧЧ:ММ: [ТЕГ] Текст`.  
- Регулярное выражение `_ENTRY_RE` — парсит записи, извлекая метку времени, тег и текст.  
- Функции `read_memory`, `write_memory`, `append_memory` — чтение, запись и добавление содержимого.  
- `append_memory_tagged` — добавляет запись с тегом, избегая дубликатов (сравнение по нормализованному тексту и тегу).  
- `parse_entries` — разбирает содержимое на структурированные записи.  
- `compact_memory_by_priority` — сжимает память по заданному лимиту в байтах, сохраняя записи в порядке приоритета тегов.  
- `trim_for_context` — обрезает текст по количеству символов с пометкой о тримировании.  
- `memory_size_bytes` — возвращает размер содержимого в байтах.  

Важные настройки:  
- `max_chars=2000` в `trim_for_context` — ограничение на длину контекста.  
- `max_bytes` в `compact_memory_by_priority` — лимит размера памяти при компрессии.  
- `priority` — список тегов, определяющий порядок сохранения записей при сжатии.  

Функции работают с указанием рабочей директории (`cwd`), что позволяет использовать изолированные файлы памяти.

Файл предоставляет функции для управления жизненным циклом проектного плана в виде JSON-файла. Основное назначение — загрузка, сохранение, архивирование и удаление плана разработки, представленного структурой `ProjectPlan`, включая вложенные сущности `DevTask` и `ProjectAnalysis`.

Ключевые сущности:  
- `ProjectPlan` — основной объект плана проекта с целями, задачами, анализом и статусом.  
- `DevTask` — отдельная задача разработки с критериями приёмки, зависимостями и историей выполнения.  
- `ProjectAnalysis` — анализ состояния проекта, включающий выполненные и оставшиеся задачи.

Основные функции:  
- `load_plan` — загружает план из `MANAGER_PLAN.json`, возвращает `None`, если файл отсутствует.  
- `save_plan` — атомарно сохраняет план в файл с обновлением временных меток `created_at` и `updated_at`.  
- `delete_plan` — удаляет текущий файл плана (используется при сбросе).  
- `archive_plan` — перемещает текущий план в архив с временной меткой и статусом, возвращает путь к архивному файлу или `None` при ошибке.

Файл плана хранится в корне рабочей директории, архивные копии — в поддиректории `.manager_archive`. Все операции сопровождаются обработкой исключений и логированием ошибок.

Модуль предоставляет потокобезопасные операции чтения и записи JSON-файлов с использованием системных блокировок. Основное назначение — обеспечение целостности данных при одновременном доступе к файлу из нескольких процессов.

Ключевые функции:
- `read_json_locked` — читает JSON-файл под общей (shared) блокировкой, возвращает содержимое как словарь. При отсутствии файла, ошибке парсинга или пустом содержимом возвращает значение по умолчанию.
- `write_json_locked` — записывает словарь в JSON-файл под эксклюзивной (exclusive) блокировкой с полной перезаписью содержимого.
- `update_json_locked` — выполняет атомарное чтение, модификацию и запись JSON-файла под эксклюзивной блокировкой. Принимает функцию `updater`, которая преобразует текущие данные и возвращает новые.

Все функции автоматически создают родительские директории пути при необходимости. Используется буферизация и синхронизация (`os.fsync`) для надежности записи на диск. Файлы открываются в режиме `a+`, что гарантирует создание файла, если он отсутствует.

Файл определяет основные сущности и контракты для системы планирования и исполнения задач, ориентированной на управление разработкой и выполнение агентных операций. Включает модели данных для шагов плана, запросов и ответов исполнителя, а также структуры для режима управления проектами (Manager mode).

Ключевые сущности:
- `PlanStep` — описание шага в плане, включая зависимости, тип, возможность параллельного выполнения и разрешённые инструменты.
- `ExecutorRequest` — входные данные для исполнителя: цель, контекст, ограничения, ожидаемые выходы и профиль исполнения.
- `ExecutorResponse` — ответ от исполнителя с результатами, вызовами инструментов и следующими вопросами.
- `DevTask` — задача разработки с критериями приёма, статусом, зависимостями и историей проверок.
- `ProjectPlan` — план проекта, содержащий список задач, анализ состояния и общий статус.
- `ProjectAnalysis` — анализ текущего состояния проекта: выполненные и оставшиеся задачи.
- `ReviewResult` — результат ревью задачи: одобрение, комментарии, результаты тестов.

Важные настройки и правила:
- Параллельное выполнение шагов (`parallelizable`) требует явного указания и обоснования.
- Зависимости между шагами задаются через `depends_on` для безопасного исполнения.
- Валидация запросов и ответов осуществляется через `validate_request` и `validate_response`.
- Поддержка режима диалога с пользователем через `ask_question` и `ask_options` в `PlanStep`.
- Ограничение числа попыток выполнения задачи через `max_attempts` в `DevTask`.

Модуль предоставляет основные компоненты для работы агента: ядро исполнения, реестр инструментов и вспомогательные функции для выполнения команд. Включает класс `AgentRunner` для управления жизненным циклом агента, `ToolRegistry` для регистрации и управления инструментами, а также функции `execute_shell_command`, `pop_pending_command` и `set_approval_callback` для взаимодействия с командами оболочки и обработки подтверждений. Основное назначение — объединение логики исполнения и инструментария в единую точку доступа.

# ReAct Агент — Краткое резюме

## Назначение
Файл реализует агентскую систему на основе архитектуры **ReAct (Reasoning + Acting)**, предназначенную для выполнения пользовательских задач с использованием LLM (через OpenAI API) и набора инструментов (tools). Агент поддерживает диалог, управление памятью, историей чата, работу в песочнице и циклическое выполнение действий с логированием.

## Ключевые сущности
- **`ReActAgent`** — основной класс, управляющий циклом рассуждений и действий: анализирует ответы модели, вызывает инструменты, обрабатывает результаты.
- **`AgentRunner`** — фасад для запуска агента, управляет сессиями и проверкой конфигурации.
- **`AgentRunResult`** — результат выполнения: ответ, статус, список вызванных инструментов.
- **`PluginToolRegistry`** — реестр доступных инструментов, фильтруемых по `allowed_tools`.
- **Сессия (`session`)** — состояние агента, хранится в `SESSION.json` в изолированной директории.
- **`working`** — временный буфер текущей итерации (вызовы/результаты инструментов).

## Основные функции
- `_load_session` / `_save_session` — потокобезопасное чтение/запись сессии.
- `_build_messages` — формирование цепочки сообщений с системным промптом, памятью, историей и текущим контекстом.
- `_call_openai` — вызов модели с ограничением инструментов.
- `run` — основной цикл агента: итеративная обработка до ответа или лимита.

## Конфигурация и настройки
- **Максимумы:**
  - `AGENT_MAX_ITERATIONS` — лимит итераций ReAct.
  - `AGENT_MAX_BLOCKED` — лимит блокировок команд.
  - `AGENT_MAX_HISTORY` — лимит записей в истории.
  - `MAX_CHAT_MESSAGES`, `MAX_MEMORY_CHARS` — ограничения на чат и память.
- **Пути и окружение:**
  - `AGENT_SANDBOX_ROOT` — корень песочницы.
  - `_shared_dir`, `_chats_dir` — директории данных.
  - `MEMORY_FILE` — файл памяти (`MEMORY.md`).
- **OpenAI:**
  - `OPENAI_API_KEY`, `OPENAI_MODEL`, `OPENAI_BASE_URL` — настраиваются через `AppConfig` или переменные окружения.
- **Системный промпт:**
  - Загружается из `system.txt`, подставляются `{{cwd}}`, `{{date}}`, `{{tools}}`, `{{userPorts}}`, память и история.

## Особенности
- **Логирование:** глобальное через `log_global`, детальное через `_log`.
- **Блокировка команд:** команды с `BLOCKED:` игнорируются, превышение `AGENT_MAX_BLOCKED` останавливает выполнение.
- **Обработка ошибок:** прерывание при трёх неудачных попытках подряд.
- **Поддержка контекста:** в промпт добавляются `request_context`, `constraints`, `corr_id` для трассировки.
- **Интеграция:** требует валидного `OPENAI_API_KEY` и `OPENAI_MODEL`.

## Назначение файлов
- `system.txt` — шаблон системного промпта.
- `SESSION.json` — состояние сессии.
- `MEMORY.md` — контекстная память агента.

Файл содержит вспомогательные функции для обработки шагов планирования и определения необходимости уточнения входного запроса. Основная логика построена на анализе текста и конфигурации приложения.

Функция `needs_clarification` проверяет, требует ли текст уточнения, на основе наличия вопросительного знака или ключевых слов из конфигурации (`clarification_keywords`). Проверка активируется только при включённой опции `clarification_enabled` в `AppConfig`.

Функция `normalize_ask_step` нормализует объект `PlanStep`, устанавливая значения по умолчанию для полей `ask_question` и `ask_options`, если они не заданы или содержат недостаточно вариантов ответа.

Ключевые сущности: `AppConfig`, `PlanStep`.  
Важные настройки: `clarification_enabled`, `clarification_keywords` — определяют поведение механизма уточнения.

# Оркестратор выполнения пользовательских задач — Краткое резюме

## Назначение
Файл реализует **оркестратор выполнения многошаговых пользовательских задач**, координирующий планирование, выполнение шагов, взаимодействие с пользователем и генерацию итогового ответа. Основной класс — `OrchestratorRunner`, управляющий циклом обработки в асинхронной среде.

## Ключевые сущности
- `PlanStep` — структура шага плана с зависимостями, типом и ID.
- `Executor` — выполнение шагов через инструменты.
- `Dispatcher` — маршрутизация и управление выполнением.
- `ExecutorRequest` / `ExecutorResponse` — ввод/вывод исполнителя (статус, результат, ошибки).
- `session_store`, `memory_store` — хранение сессий (с блокировками) и контекстной памяти.
- `tool_registry` — реестр доступных инструментов.
- `bot` — отправка сообщений и вложений.
- `session`, `context`, `dest` — данные сессии и назначения.

## Основные функции
- Асинхронное выполнение шагов с поддержкой **параллелизма** (при явном указании).
- Управление **зависимостями** между шагами (выполнение только после успешного завершения предшественников).
- **Динамическое перепланирование** после каждого шага (до 25 итераций).
- Обработка `ask_user` — запрос уточнений от пользователя (до 2 раз).
- Сбор **артефактов** (файлов) и их отправка отдельными сообщениями.
- Финальный ответ генерируется через LLM с использованием Markdown и кратких итогов.

## Настройки и ограничения
- Рабочая директория: изолированная (`workdir` из `AppConfig`).
- Память: до 2000 символов, компрессия при превышении (`memory_max_kb`, `memory_compact_target_kb`).
- История оркестратора: последние 25 записей.
- JSON-контекст финального ответа: до 40 000 символов.
- `SESSION.json`: до 50 записей, с блокировкой при доступе.
- Ограничение на перепланирования: 25, на уточнения: 2.
- Блокировка параллельного выполнения для файловых операций без явного разрешения.

## Особенности
- Восстановление состояния сессии из `SESSION.json`.
- Адаптивное обновление памяти: `_maybe_update_memory` с приоритезацией по тегам или LLM-сжатием.
- Компактное представление выходных данных (обрезка >5000 символов).
- Финальный ответ отправляется асинхронно, не блокируя цикл.
- Поддержка профилей: ограничения по инструментам, настройки UI и плагинов.
- Логирование: статусы, метрики, длина ответов, обновления сессии.

## Завершение работы
Оркестратор останавливается при:
- Отсутствии шагов для выполнения.
- Превышении лимита перепланирований.
- Критических ошибках или явном завершении задачи.

Модуль определяет профили исполнителей (`ExecutorProfile`) — конфигурации с набором разрешённых инструментов, таймаутами и количеством попыток. Используется для управления доступом и ограничениями при выполнении задач в зависимости от роли (например, default, reviewer, developer).

Ключевая сущность — `ExecutorProfile`, датакласс с полями:  
- `name` — имя профиля  
- `allowed_tools` — список имён разрешённых инструментов  
- `timeout_ms` — максимальное время выполнения в миллисекундах  
- `max_retries` — количество попыток повтора при ошибках  

Функции формирования профилей:  
- `build_default_profile` — профиль по умолчанию с доступом ко всем инструментам и увеличенным таймаутом (600 сек), подходит для сложных задач.  
- `build_reviewer_profile` — профиль для ревьюера: только безопасные, идемпотентные инструменты (чтение файлов, поиск, запуск команд), таймаут задаётся через конфиг (`manager_review_timeout_sec`), одна попытка.  
- `build_developer_profile` — заготовка для разработчика, не предоставляет инструментов (выполнение через CLI), используется для симметрии интерфейсов, таймаут настраивается через `manager_dev_timeout_sec`.  

Зависит от `AppConfig` (настройки приложения) и `ToolRegistry` (реестр доступных инструментов). Фильтрация инструментов по наличию выполняется через вспомогательную функцию `_available`.

Класс `Executor` отвечает за выполнение задач агента в изолированной среде с поддержкой инструментов, обработкой ошибок и повторными попытками. Основан на `AgentRunner` и использует `ToolRegistry` для управления доступными инструментами. Поддерживает диалог с пользователем через `ask_user`, обработку таймаутов и временных сбоев с экспоненциальным отступом.

Ключевые сущности:
- `ExecutorRequest` / `ExecutorResponse` — валидируемые входные и выходные данные.
- `ExecutorProfile` — определяет политики выполнения: `allowed_tools`, `max_retries`, `timeout_ms`.
- `ToolRegistry` — предоставляет и выполняет инструменты, включая `ask_user`.
- `AgentRunner` — непосредственно запускает логику агента (ReAct).

Важные настройки:
- `workdir` в конфиге — корневая директория для песочниц.
- `session_workspace` — изолированная директория на сессию.
- `max_retries` и `timeout_ms` из профиля — контроль устойчивости и времени выполнения.
- Обработка `asyncio.TimeoutError`, `ConnectionError` и подобных как временных ошибок.
- Логирование с привязкой к `corr_id` и замером времени выполнения.

Методы управления:
- `record_message`, `resolve_question`, `clear_session_cache` — работа с состоянием сессии.
- `get_plugin_commands`, `get_plugin_ui` — интеграция с интерфейсом бота через разрешённые инструменты.

# Модуль управления проектом (Manager Orchestrator)

Модуль реализует оркестратор управления проектом в режиме менеджера, координирующего выполнение задач через взаимодействие с исполнителем (агентом). Центральный класс — `ManagerOrchestrator`, управляющий жизненным циклом проектного плана на основе целей пользователя.

## Ключевые сущности
- `ProjectPlan` — структурированный план проекта с задачами, статусами и зависимостями.
- `DevTask` — отдельная задача разработки с попытками, зависимостями и статусом.
- `Executor` — компонент выполнения и ревью задач.
- `Session` — контекст сессии с рабочей директорией и состоянием.
- `bot` — отправка уведомлений пользователю (при наличии `chat_id`).

## Основные функции
- `run` — основная точка входа: загружает или создаёт план и запускает цикл обработки.
- `_start_new_plan` — инициализация плана по пользовательскому запросу с fallback-механизмами при ошибках парсинга.
- `_run_loop` — асинхронный цикл выполнения: выбор задачи, разработка, ревью, решение, повтор или завершение.
- `_next_ready_task` — определяет следующую готовую задачу с учётом зависимостей и статусов.
- `_is_plan_blocked` — проверка блокировки плана (все невыполненные задачи — `blocked`/`failed`).
- `format_manager_status` — формирует читаемый отчёт о состоянии плана.
- `_notify_plan` — отправка сводки по плану в чат.
- `_compose_final_report` — генерация итогового отчёта через LLM.
- `_auto_commit` — автоматический git-коммит после успешного выполнения задачи с генерацией сообщения через LLM.
- `pause`, `reset` — приостановка и сброс сессии с архивацией плана.

## Логика работы
1. **Инициализация плана**:  
   - Декомпозиция запроса через CLI с таймаутом (`manager_decompose_timeout_sec`).  
   - При неудаче — нормализация через агента (с постепенным ужесточением).  
   - Результат валидируется и приводится к единой структуре (`_payload_to_plan`).

2. **Выполнение плана**:  
   - Цикл `_run_loop` обрабатывает задачи до завершения или ошибки.  
   - Учитываются зависимости: провал зависимой задачи → статус `blocked`.  
   - Поддержка повторных попыток для статусов из `RETRIABLE_STATUSES`.  
   - Ограничения: `manager_max_tasks`, `manager_max_attempts` — защита от бесконечных циклов.

3. **Состояния и восстановление**:  
   - План сохраняется после каждого шага (`save_plan`).  
   - При перезапуске: `in_progress`, `in_review` → `pending`; `rejected` → `pending` или `failed`.  
   - `needs_resume_choice` — определяет необходимость подтверждения возобновления.

4. **Интеграции и уведомления**:  
   - Использует `openai_client`, `manager_store`, `manager_prompts`, `tooling.registry`.  
   - Отправка статусов и отчётов через `bot`.  
   - Автокоммит в git: анализ изменений, генерация сообщения (`COMMIT_MESSAGE_SYSTEM`), фиксация.

## Настройки
- `manager_auto_resume` — автоматическое возобновление плана.
- `manager_auto_commit` — включение автоматического коммита.
- `manager_debug_log` — сохранение отладочных данных в `.manager/`.
- `defaults.openai_model` — модель LLM для всех вызовов.
- `manager_dev_timeout_sec`, `manager_dev_report_max_chars` — таймауты и лимиты.

## Вспомогательные функции
- `_extract_json_object` — извлечение JSON из текста/Markdown.
- `_debug_write` — запись отладочных промптов и ответов.
- `_truncate_report` — обрезка длинных текстов с сохранением контекста.
- `_run_git` — выполнение git-команд.

## Особенности
- Обнаружение дедлоков и каскадных блокировок.
- Архивация завершённого плана и отправка итогового отчёта.
- Поддержка отладочного режима с детальным логированием.

# Конфигурация фильтрации команд — краткое резюме

Конфигурационный файл предназначен для **детектирования и блокировки потенциально опасных команд** в shell-окружениях, CI/CD-пайплайнах и изолированных средах выполнения. Основная цель — **предотвращение утечек секретов, экзфильтрации данных, повышения привилегий, обхода изоляции и выполнения вредоносных операций**.

## Основные категории угроз
- `env_leak` — утечка переменных окружения (`env`, `printenv`, `$SECRET`).
- `sensitive_files` — чтение конфиденциальных файлов (`.env`, `id_rsa`, `.pem`, `credentials`).
- `docker_secrets` — доступ к `/run/secrets`, `/var/run/secrets`.
- `exfiltration` — кодирование и передача данных (`base64`, `openssl`, `curl`, `nc`, DNS-экстракция).
- `code_env_access` — доступ к секретам через код (Python: `os.environ`, `dotenv`, `open`).
- `network_scan` — сканирование сети (`nmap`, `masscan`, `zmap`).
- `dos` — ресурсоёмкие команды (`dd`, `yes`, `fallocate`, бесконечные циклы, Python-вычисления).
- `crypto_mining` — запуск майнеров (`xmrig`, `minerd`).
- `process_kill` — принудительное завершение процессов (`kill -9`, `xkill`).
- `privilege` — попытки повышения привилегий (`sudo`, `apt`, `chroot`).
- `escape` — побег из контейнера (`docker`, `nsenter`, `unshare`, `/proc`).
- `cloud` — доступ к метаданным облака (169.254.169.254, `curl` к внутренним сервисам).
- `obfuscation` — обфускация команд (`chr()`, `reversed`, `IFS`, hex-кодирование).
- `filter_bypass` — обход фильтров (`/dev/tcp`, ANSI-C quoting, brace expansion).
- `code_execution` — выполнение кода (`exec`, `eval`, `importlib`, `LD_PRELOAD`).
- `recon` — разведка (`dig`, `nslookup`, `host`).
- `attack_tool` — использование инструментов атак (SQLmap, Metasploit, Cobalt Strike).
- `persistent` — создание персистентности (`crontab`, `systemctl`).
- `large_install` — установка тяжёлых пакетов (TensorFlow, PyTorch, Go, Rust).
- `dangerous_download` — загрузка и выполнение скриптов (`curl | bash`).
- `cross-user` — доступ к чужим рабочим областям (`../`, `/workspace`, `_shared/`).

## Ключевые параметры правил
- `id` — уникальный идентификатор правила.
- `category` — тип угрозы.
- `pattern` — регулярное выражение для сопоставления.
- `flags` — флаги (например, `i` — регистронезависимость).
- `reason` — пояснение блокировки.

## Назначение
Обеспечение безопасности, стабильности и контролируемости среды выполнения за счёт централизованного управления запрещёнными паттернами. Используется в secure shell, песочницах, CI/CD и облачных платформах.

Модуль реализует загрузчик плагинов `PluginLoader` для динамической подгрузки классов, наследующих `ToolPlugin`, из Python-файлов в указанной директории. Основная цель — обнаружение и инициализация плагинов, исключая системные и базовые файлы (`__init__.py`, `base.py`). Поддерживаются только `.py` файлы, из которых загружаются модули через `importlib.util`. Классы плагинов должны быть унаследованы от `ToolPlugin` и не совпадать с ним напрямую. Экземпляры успешно загруженных классов добавляются в результирующий список. Ошибки при загрузке модулей или инициализации плагинов логируются с помощью `logging.exception`. Важные настройки: путь к директории с плагинами, исключённые файлы, безопасная загрузка модулей с регистрацией в `sys.modules`.

# Резюме: Назначение и функциональность файла

Файл реализует безопасное выполнение команд и работу с внешними данными в изолированной среде с контролем доступа. Основные задачи — проверка команд на соответствие политикам безопасности, санитизация вывода, ограничение объёма данных и поддержка безопасного доступа к веб-ресурсам.

## Ключевые функции
- **Проверка команд**: `check_command` анализирует команды на соответствие блокирующим шаблонам из `BLOCKED_PATTERNS_PATH`, с учётом типа чата.
- **Изоляция рабочей области**: `_check_workspace_isolation`, `_check_command_path_escape` предотвращают выход за пределы выделённой директории.
- **Санитизация вывода**: `sanitize_output`, `_trim_output`, `_trim_fetch_output` ограничивают и очищают вывод команд и веб-запросов.
- **Выполнение команд**: `execute_shell_command` — асинхронное выполнение shell-команд с таймаутами, фоновым режимом и логированием.
- **Подтверждение команд**: `PendingCommand`, `_PENDING_COMMANDS`, `set_approval_callback`, `pop_pending_command` управляют командами, требующими подтверждения.
- **Загрузка веб-контента**: Поддержка нескольких провайдеров (`proxy`, `tavily`, `jina`, `zai`) и резервный метод через `trafilatura`. Обеспечивает извлечение и структурирование текста с веб-страниц.

## Настройки безопасности
- **Чувствительные файлы**: `SENSITIVE_FILES` включает `.env*`, `id_rsa`, `secrets.yaml`, `*.pem`, `credentials.*` и др. Проверяется содержимое и пути на наличие секретов.
- **Блокировка URL**: Список `blocked` предотвращает доступ к опасным ресурсам (например, метаданным облака).
- **Таймауты**: `TOOL_TIMEOUT_MS`, `WEB_FETCH_TIMEOUT_MS`, `GREP_TIMEOUT_MS`.
- **Ограничения вывода**: `OUTPUT_TRIM_LEN`, `OUTPUT_HEAD_LEN`, `OUTPUT_TAIL_LEN`, `FETCH_MAX_CHARS`.

## Интеграции и провайдеры
- Активируются через переменные окружения: `PROXY_URL`, `TAVILY_API_KEY`, `JINA_API_KEY`, `ZAI_API_KEY`.
- Резервный метод — прямой HTTP-запрос + обработка через `trafilatura`.

## Формат вывода
Функции возвращают объект вида:
```json
{ "success": true, "output": "..." }  // или { "error": "..." }
```
Совместимо с инструментальным интерфейсом агента.

## Дополнительно
- `MEMORY_FILE = "MEMORY.md"` — указание на файл памяти (используется в других модулях).

# Краткое резюме

Данный документ представляет собой техническую документацию, объединяющую несколько частей, описывающих архитектуру, функциональность и использование системы. В документации рассматриваются основные компоненты системы, их взаимодействие, интерфейсы и процессы. Описаны требования, принципы работы, примеры использования и рекомендации по интеграции. Документ предназначен для разработчиков, инженеров и технических специалистов, обеспечивающих развертывание и сопровождение решения.

Определяет структуры данных для описания и ответа инструментов (tools) в системе взаимодействия с ИИ-моделями.  

`ToolSpec` описывает спецификацию инструмента: имя, описание, параметры в формате JSON Schema, таймаут выполнения (по умолчанию 120 секунд), уровень риска (`low` по умолчанию), необходимость подтверждения (`requires_approval`), теги и возможность параллельного выполнения (`parallelizable`). Поддерживает преобразование в форматы OpenAI и Google через методы `to_openai_tool` и `to_google_tool`.  

`ToolResponse` представляет ответ от инструмента: флаг успеха, опциональный вывод, сообщение об ошибке и дополнительные метаданные.  

Используется для стандартизации описания и обработки внешних инструментов в AI-агентах.

# ToolRegistry — Реестр инструментов и менеджер плагинов

Класс `ToolRegistry` обеспечивает централизованное управление инструментами (плагинами) для агента, включая их регистрацию, хранение, валидацию, выполнение и доступ. Поддерживает локальные плагины, удалённые MCP-инструменты (Model Control Protocol), а также генерацию совместимых спецификаций для ИИ-моделей (OpenAI, Google).

## Основные функции

- **Регистрация и загрузка**:
  - `_load_plugins`: загружает локальные плагины из директории `plugins`.
  - `ensure_mcp_loaded`: асинхронно обнаруживает и кэширует MCP-инструменты.
  - `register`: регистрирует плагин с проверкой уникальности имени и валидацией параметров.

- **Доступ к инструментам**:
  - `get_definitions`: возвращает спецификации инструментов в формате OpenAI/Google.
  - `get_plugin_commands`: извлекает команды плагинов с проверкой уникальности.
  - `_filter_allowed`: фильтрует инструменты по списку `allowed_tools` (`"All"`, `"None"`).

- **Выполнение и управление**:
  - `execute`, `execute_many`: запуск инструментов с таймаутом (`TOOL_TIMEOUT_MS`) и обработкой ошибок.
  - `execute_parallel_or_sequential`: определяет режим выполнения (параллельно/последовательно) на основе флага `parallelizable`.
  - `any_awaiting_input`, `cancel_all_inputs`: управление состоянием ожидания ввода.

- **Интерфейс и обработчики**:
  - `build_bot_commands`, `build_bot_ui`: формируют команды и UI-элементы бота.
  - `get_message_handlers`, `get_inline_handlers`: собирают обработчики сообщений и inline-запросов.
  - Поддержка callback-обработчиков через `callback_query_handler`.

- **Валидация и нормализация**:
  - `_validate_and_normalize_command`, `_validate_and_normalize_handler`: проверяют и дополняют метаданные.
  - `_validate_args`: валидация аргументов по JSON-схеме из `ToolSpec`.

## Состояние и сервисы

Плагины получают доступ к общим сервисам через `services`:
- `pending_questions`, `recent_messages`, `task_store`, `scheduler_tasks`, `user_tasks`.

## Важные компоненты

- `MCPManager`: управление MCP-серверами и кэширование инструментов.
- `PluginLoader`: загрузка локальных плагинов.
- `MCPRemoteToolPlugin`: представление удалённых MCP-инструментов.

## Настройки и поведение

- `TOOL_TIMEOUT_MS`: глобальный таймаут выполнения инструментов.
- Автоматическая нормализация имён через `get_function_prefix`.
- Обнаружение опечаток: `get_missing_suggestions` с использованием `difflib`.
- Синглтон-реализация: `_REGISTRY_SINGLETON`, инициализируется через `get_tool_registry`.

## Утилиты

- `record_message`: хранит последние 20 ID сообщений для управления контекстом.
- `resolve_question`: разрешает ожидающие вопросы через `Future`.
- `close_all`: корректно завершает все плагины с логированием ошибок.

## Назначение

`ToolRegistry` обеспечивает:
- Единый интерфейс для всех инструментов.
- Безопасное и контролируемое выполнение.
- Гибкую настройку доступности и интерфейса.
- Поддержку расширяемости через плагины и MCP.

Переменные конфигурации, задающие таймауты и ограничения на объём вывода для различных операций.  
`TOOL_TIMEOUT_MS` — максимальное время выполнения инструмента (120 секунд).  
`GREP_TIMEOUT_MS` — таймаут операции поиска (30 секунд).  
`WEB_FETCH_TIMEOUT_MS` — таймаут получения данных из веба (90 секунд).  
`OUTPUT_TRIM_LEN` — максимальная длина обрезанного вывода (3000 символов).  
`OUTPUT_HEAD_LEN` — длина начальной части вывода при обрезке (1500 символов).  
`OUTPUT_TAIL_LEN` — длина конечной части вывода при обрезке (1000 символов).  
Используются для контроля производительности и объёма данных в обработке инструментов.

Плагин инструмента для интеграции с удалёнными MCP-сервисами через стандартный интерфейс взаимодействия с инструментами. Обеспечивает регистрацию и выполнение вызовов к MCP-инструментам, управляемым через `MCPManager`.  

Ключевые сущности:  
- `MCPRemoteToolPlugin` — реализация плагина, предоставляющего доступ к удалённому MCP-инструменту.  
- `MCPToolInfo` — описание инструмента (имя, схема ввода, описание).  
- `MCPManager` — менеджер, отвечающий за выполнение вызовов к MCP-серверам.  

Особенности:  
- Использует `_normalize_schema` для приведения входной схемы к валидному JSON Schema формату с корневым типом `object`.  
- Результаты выполнения обрабатываются через `_render_mcp_result`, извлекающий текст из `content` или сериализующий ответ в JSON.  
- Идентификатор плагина формируется как `MCP[<server_name>]`, префиксы функций отключены для сохранения оригинальных имён инструментов.  
- Таймаут выполнения — 30 секунд, выполнение не параллелизуется.  

Параметры спецификации (`ToolSpec`):  
- `name` — имя инструмента в реестре.  
- `description` — описание из `MCPToolInfo` или сгенерированное.  
- `parameters` — нормализованная схема входных данных.  
- `parallelizable` — `False`.  
- `timeout_ms` — 30000.  

При сбое вызова ошибка логируется и возвращается в структурированном виде.

Плагин инструмента для поиска текста или регулярных выражений в файлах с использованием `grep`. Позволяет искать определения, вхождения или паттерны кода в указанной директории или файле. Поддерживает контекст вывода, нечувствительность к регистру, фильтрацию по типу файлов и исключение чувствительных директорий и файлов (например, `node_modules`, `.git`, `.env`, ключи).  

Ключевые параметры:
- `pattern` — обязательный поисковый запрос или регулярное выражение.
- `path` — путь для поиска (по умолчанию — текущая директория).
- `context_before`, `context_after` — количество строк до и после совпадения.
- `files_only` — возвращать только пути к файлам, содержащим совпадения.
- `ignore_case` — выполнить поиск без учёта регистра.

Автоматически блокирует запросы, содержащие потенциально опасные ключевые слова (например, `password`, `token`, `secret`). Использует безопасное разрешение путей в пределах рабочей области. Результат ограничивается 200 строками. Время выполнения ограничено через `GREP_TIMEOUT_MS`.

Инструмент `show_me_diagrams` для генерации и рендеринга диаграмм с использованием PlantUML. Поддерживает два режима: `generate` — генерация PlantUML-кода на основе описания с помощью LLM (через OpenAI API), и `render` — прямой рендеринг переданного PlantUML-кода в PNG. Поддерживаемые типы диаграмм: `gantt_chart`, `mind_map`, `flowchart`, `project_timeline`, `infographic`, `org_chart`, `process_diagram`.

Ключевые параметры:
- `action`: `generate` или `render` (обязательный)
- `diagram_type`: тип диаграммы (для `generate`)
- `description`: описание диаграммы (для `generate`)
- `plantuml_code`: PlantUML-код (для `render`)
- `title`: заголовок диаграммы (опционально)

Требуется наличие `plantuml.jar` в той же директории, что и скрипт, и установленного Java. Для генерации кода требуется `OPENAI_API_KEY`. Результат — путь к PNG-файлу и исходный PlantUML-код. Файлы сохраняются во временной директории. Таймаут выполнения — 120 секунд.

Инструмент для поиска изображений и GIF-файлов через DuckDuckGo Images. Предоставляет асинхронный интерфейс выполнения запросов с последующим извлечением URL найденных изображений. Поддерживает параметры поиска: текстовый запрос, тип контента (photo/gif), регион и максимальное количество результатов. Результаты перемешиваются перед выбором случайного изображения. Использует библиотеку `duckduckgo-search`, которая должна быть установлена. В случае ошибки или отсутствия результатов возвращает соответствующее сообщение. Основные параметры: `query` (обязательный), `type`, `region`, `max_results`. Инструмент параллелизуем.

Инструмент `read_file` предназначен для безопасного чтения содержимого файлов в рамках рабочей области. Позволяет читать файлы по указанному пути с возможностью задать смещение (номер начальной строки) и ограничение на количество возвращаемых строк. Перед использованием проверяет доступ к файлу: разрешает доступ только в пределах текущей рабочей директории, блокирует чтение чувствительных файлов и файлов из чужих рабочих пространств. Поддерживает чтение отсутствующих или пустых файлов с соответствующим информированием. Основные параметры: `path` (обязательный), `offset`, `limit`. Используется в цепочках инструментов, где требуется анализ исходного кода или данных перед редактированием.

Плагин инструмента для асинхронного получения содержимого файлов из репозитория GitHub по указанному пути. Поддерживает выборку как отдельных файлов, так и содержимого директорий с ограничением на количество обрабатываемых файлов.  

Ключевые сущности:  
- `GitHubAnalysisTool` — реализация плагина, наследующая `ToolPlugin`.  
- `ToolSpec` — описание инструмента: имя `github_analysis`, параметры `owner`, `repo`, `path`, `max_files`.  
- Обязательные параметры: `owner`, `repo`.  
- `max_files` — ограничение от 1 до 20 файлов (по умолчанию 5).  

Авторизация осуществляется через токен, который берётся из переменной окружения `GITHUB_TOKEN` или из конфигурации плагина. Запросы к API GitHub выполняются синхронно в отдельном потоке через `asyncio.to_thread`.  

Поддерживается декодирование контента из base64 или загрузка по `download_url`. Результат включает имена файлов и их содержимое, объединённые с разделителем. В случае ошибки возвращается сообщение об ошибке.

Инструмент для выполнения запросов к WolframAlpha с получением кратких текстовых ответов. Используется для вычислений, научных данных, статистики и других точных ответов на основе структурированной базы знаний. Поддерживает выполнение через асинхронный интерфейс с синхронным вызовом API в отдельном потоке. Требует наличие переменной окружения `WOLFRAM_APP_ID`. Запросы рекомендуется передавать на английском языке для лучшей точности. Основной метод — `execute`, принимающий параметр `query`. Используется простой HTTP-запрос к `/v1/result`, возвращающий plain text. Таймаут выполнения — 60 секунд.

# Резюме: Система диалогов и инструментов для Telegram-бота

Базовый класс `ToolPlugin` и миксин `DialogMixin` предоставляют унифицированную архитектуру для реализации плагинов с поддержкой инструментов, интерактивных диалогов и интеграции с Telegram.

## Основные компоненты

- **`ToolPlugin`** — абстрактный базовый класс, определяющий:
  - Интерфейс для описания (`get_spec`) и выполнения инструментов (`execute`).
  - Жизненный цикл: `initialize()`, `close()`.
  - Интеграцию с Telegram: меню, обработчики сообщений и inline-колбэков.
  - Протокол ожидания ввода: `awaiting_input()`, `cancel_input()`.

- **`DialogMixin`** — добавляет управление диалогами:
  - Состояния через `start_dialog()`, `end_dialog()`, `get_dialog()`, `set_step()`.
  - Автоматическое завершение по таймауту (`DIALOG_TIMEOUT = 300` сек).
  - Отмена диалога по словам из `CANCEL_WORDS` или кнопке «Отмена».
  - Вспомогательные методы: `_ensure_agent_enabled()`, `_plugin_id_safe()`.

## Диалоговые сущности

- **`dialog_button`** — кнопка, привязанная к шагу диалога: `dlg:{plugin_id}:{data}`.
- **`action_button`** — кнопка автономного действия: `cb:{plugin_id}:{action}[:{payload}]`.
- **`parse_callback_payload`** — извлечение payload из `callback_data`.

## Обработка событий

- **`handle_message`** — перехватывает сообщения при активном диалоге, проверяет отмену, передаёт в обработчик шага.
- **`handle_callback`** — центральный обработчик нажатий, маршрутизирует по типу:
  - `_dispatch_callback` разделяет запросы на:
    - `dlg_cancel:` — отмена диалога (`_on_cancel_button`).
    - `dlg:` — шаги диалога.
    - `cb:` — автономные действия.
- **`_dialog_callback_commands`** — регистрирует единый `CallbackQueryHandler` с фильтрацией по префиксу и ID плагина.
- **`_dialog_active_filter`** — фильтр для сообщений: только при активном диалоге, без команд.

## Конфигурация и расширение

- **`dialog_steps`** — словарь шагов диалога и их обработчиков (сообщения/колбэки).
- **`callback_handlers`** — сопоставление действий (`action`) с асинхронными обработчиками.
- **`step_hint`** — подсказка при некорректном вводе.
- **`extra_message_filters`** — расширение фильтрации (по умолчанию — блокировка всех вложений).

## Особенности

- Единый обработчик колбэков с префиксной маршрутизацией.
- Автоматическое завершение диалога при ошибке, таймауте или отключении агента.
- Поддержка автономных действий с payload.
- Плагины с диалогами должны наследоваться от `DialogMixin` первым для корректного MRO.

Назначение: упрощение построения интерактивных сценариев в Telegram-ботах с чётким разделением состояний, безопасной обработкой ввода и гибкой маршрутизацией событий.

Инструмент `list_directory` предназначен для безопасного просмотра содержимого директории в рамках рабочей области агента. Поддерживает указание пути через параметр `path`, по умолчанию используется текущая директория (`cwd`). Реализует защиту от доступа к системным и привилегированным директориям, таким как `/etc`, `/root`, `/.ssh` и другим. Проверяет расположение запрашиваемого пути относительно рабочей директории, блокируя доступ к чужим пользовательским пространствам. Выполняет команду `ls -la` через `subprocess`, возвращает содержимое в случае успеха или сообщение об ошибке. Все пути нормализуются и проверяются с помощью вспомогательных функций из `helpers`. Ключевые параметры: `path` — строка с путём к директории.

Инструмент `ask_user` предназначен для взаимодействия с пользователем через интерфейс с кнопками выбора. Используется, когда агенту требуется подтверждение или выбор из нескольких вариантов. Возвращает текст выбранного пользователем варианта.

Ключевая сущность — `AskUserTool`, реализующая интерфейс `ToolPlugin`. Описание инструмента определяется через `ToolSpec`, включая обязательные параметры:  
- `question` (строка) — вопрос, отображаемый пользователю;  
- `options` (массив строк, от 2 до 4 элементов) — варианты ответов в виде кнопок.

Инструмент не поддерживает параллельное выполнение (`parallelizable=False`).  

В процессе выполнения:  
- Генерируется уникальный `question_id` на основе времени и UUID;  
- Создаётся `Future` для асинхронного ожидания ответа;  
- Отправляется запрос пользователю через `bot._send_ask_question`;  
- Ожидается ответ в течение 120 секунд; при таймауте возвращается ошибка.

Состояние ожидания хранится в `self.services["pending_questions"]`, что позволяет обрабатывать ответ при его поступлении.

# TextDocumentQATool — Документация

## Назначение
Инструмент `TextDocumentQATool` реализует Telegram-бота для управления текстовыми документами и диалогового взаимодействия с ними на основе LLM. Позволяет пользователям загружать, просматривать, задавать вопросы по содержимому и удалять документы.

## Основные функции
- **`upload`** — загрузка документа (имя + содержимое), сохранение в `.txt` и метаданных в `.meta`.
- **`list`** — отображение списка доступных документов.
- **`ask`** — задание вопроса по содержимому документа с использованием ИИ.
- **`delete`** — удаление документа и связанного метафайла по `document_id`.

## Хранение данных
- Файлы сохраняются в директории, определяемой через `AGENT_SANDBOX_ROOT`, `config.defaults.workdir` или `cwd`.
- Документы: `{doc_id}.txt` (содержимое), `{doc_id}.meta` (имя).
- `doc_id` генерируется как SHA1-хеш содержимого.

## Диалоговый интерфейс
Интегрирован с `DialogMixin`, поддерживает пошаговый ввод:
- `wait_name` — ввод имени документа.
- `wait_content` — ввод текста документа.
- `wait_doc_select` — выбор документа из списка.
- `wait_query` — ввод вопроса.

Управление состоянием через `set_step` / `get_dialog`.

## Интеграция с LLM
- Используется `AsyncOpenAI` для асинхронных запросов.
- Модель: `gpt-4o-mini` (настраивается через `OPENAI_MODEL`).
- Ключ API: `OPENAI_API_KEY` (обязательный).
- Базовый URL: `OPENAI_BASE_URL` (опционально, например, для прокси).
- Параметры: `temperature=0.2`, `max_tokens=800`.
- Контекст ограничивается 12000 символами.
- Промпт включает системное сообщение и пользовательский вопрос.

## Ответы
Возвращаются в формате JSON:
```json
{ "success": true, "output": "..." }
```
или
```json
{ "success": false, "error": "..." }
```

## Интерфейс
- Меню с меткой «Документы».
- Обработка команд через callback-запросы (`_cb_*`).
- Формирование клавиатуры: `_build_doc_list_keyboard()`.

## Ограничения
- Таймаут выполнения: 120 секунд.
- Нет поддержки параллельных сессий.
- Логика ответа на вопрос (`ask`) частично реализована.

## Зависимости
- Переменные окружения: `OPENAI_API_KEY`, `OPENAI_BASE_URL`, `OPENAI_MODEL`.
- Асинхронная работа с OpenAI API.

Инструмент `manage_message` позволяет агенту управлять собственными недавними сообщениями в текущем диалоге: удалять (последнее или по индексу) и редактировать последнее сообщение. Поддерживает три действия через параметр `action`: `delete_last`, `delete_by_index`, `edit_last`. Для удаления по индексу используется параметр `index`, для редактирования — `new_text`. Индексация сообщений ведётся от 0 (самое старое) до -1 (последнее). Инструмент взаимодействует с ботом через контекст (`bot._delete_message`, `bot._edit_message`) и отслеживает идентификаторы сообщений в хранилище `services.recent_messages`. Операции ограничены только сообщениями агента в текущем чате. В случае ошибок возвращает подробное описание сбоев, включая проблемы с доступом, сроком жизни сообщения или валидностью индекса.

Инструмент `send_file` позволяет отправлять файлы из рабочей директории в чат. Предназначен для обмена результатами работы, например, созданными скриптами, отчётами или данными. Путь к файлу может быть относительным или абсолютным. Файл проверяется на наличие в рабочей области, его размер (не более 50 МБ), а также на чувствительность — запрещены отправка файлов с ключевыми словами вроде `.env`, `secrets`, `id_rsa` и другими, связанными с учётными данными. Перед отправкой файл проверяется на существование и ненулевой размер. Поддерживается необязательная подпись (caption). Отправка осуществляется через бота, используя метод `_send_document`. В случае ошибок возвращаются информативные сообщения, включая ограничения по правам доступа (например, запрет на отправку медиа в группе).

Инструмент `CodeInterpreterTool` предоставляет возможность безопасного выполнения ограниченного Python-кода в изолированной среде на локальной машине. Основное назначение — интерпретация и выполнение фрагментов кода, не требующих импорта сторонних модулей или доступа к системным ресурсам. Инструмент включает статическую проверку кода на наличие потенциально опасных конструкций и выполняет код в отдельном процессе с ограничением по времени.

Ключевые сущности:  
- `ToolPlugin` — базовый класс для инструментов агента.  
- `ToolSpec` — описание интерфейса инструмента, включая параметры и поведение.  
- `_static_block` — проверка кода по регулярным выражениям на запрещённые конструкции (импорты, `os`, `subprocess`, `open`, `eval`, `exec`, дандер-методы и др.).  
- `_run_sync` — выполнение кода в отдельном процессе Python через временный файл, с ограниченным окружением и перехватом вывода.

Важные настройки и параметры:  
- `code` (обязательный) — строка с Python-кодом для выполнения.  
- `timeout_sec` — таймаут выполнения (по умолчанию 20 секунд, ограничение от 1 до 60 секунд).  
- `parallelizable=False` — инструмент не поддерживает параллельное выполнение.  
- `timeout_ms=60_000` — максимальное время ожидания ответа от инструмента.  

Выход содержит `output` при успехе или `error` при сбое, включая блокировку по правилам фильтрации. Результат обрезается с помощью `helpers._trim_output` для предотвращения передачи избыточных данных.

# Резюме: Плагинная система с поддержкой диалогов

Базовый класс `ToolPlugin` служит основой для всех плагинов, обеспечивая интеграцию с агентом и Telegram-интерфейсом. Плагины автоматически регистрируются в `ToolRegistry` и доступны как для вызова агентом, так и для взаимодействия с пользователем. Ключевые параметры: `plugin_id` (уникальный ID) и `function_prefix` (префикс инструмента). Работают в приоритетной группе хендлеров (-1) при активной сессии агента.

## Основные методы и контракт
- `get_spec()` — возвращает JSON Schema спецификации инструмента.
- `execute()` — выполняет логику плагина, возвращает `{"success": bool, "output"|"error": str}`.

## Диалоги и интерактивность (`DialogMixin`)
`DialogMixin` (наследуется **до** `ToolPlugin`) обеспечивает поддержку многошаговых диалогов:
- Управление состоянием ввода: `awaiting_input(chat_id)`, `cancel_input(chat_id)`.
- Обработка inline-колбэков: `get_inline_handlers()` возвращает список `{action, handler}`.
- Диалоги привязаны к `chat_id`, позволяя параллельные сессии.

### Диалоговые шаги
Определяются в `dialog_steps()` как словарь или callable. Каждый шаг может содержать:
- `"message"` — обработчик текстового ввода.
- `"callback"` — обработчик колбэк-кнопок.

Управление:
- `start_dialog(chat_id)` — запуск диалога.
- `set_step(chat_id, step_name)` — переход к шагу.
- `end_dialog(chat_id)` — завершение.

Таймаут неактивности — `DIALOG_TIMEOUT` (по умолчанию 300 сек), сбрасывается при `set_step()`.

## Callback-система
Единая маршрутизация через `_dispatch_callback`, проверяющая активность агента. Поддерживаемые типы кнопок:

| Тип | Формат `callback_data` | Назначение |
|-----|------------------------|----------|
| `dlg:` | `dlg:{plugin_id}:{payload}` | Кнопки внутри диалога |
| `cb:` | `cb:{plugin_id}:{action}:{payload?}` | Автономные действия |
| `dlg_cancel:` | `dlg_cancel:{plugin_id}` | Отмена диалога |

### Вспомогательные методы
- `dialog_button(label, payload)` — кнопка в диалоге.
- `action_button(label, action, payload=None)` — автономная кнопка.
- `cancel_markup()` — готовая кнопка «Отмена».
- `parse_callback_payload(update)` — извлечение `payload` из `callback_data`.

Регистрация: все колбэки объединяются в один `CallbackQueryHandler` через `_dialog_callback_commands()`, возвращаемый из `get_commands()`.

## Меню и команды
- `get_menu_label()` — метка верхнего уровня меню.
- `get_menu_actions()` — список действий (метка + action).
- Команды Telegram: определяются в `get_commands()`.

## Обработка ввода
- Перехват сообщений при активном диалоге.
- Автоотмена при вводе слов из `CANCEL_WORDS`.
- Поддержка медиа и других типов — через `extra_message_filters()`.
- Подсказки для шагов — `step_hint(step)`.

## Жизненный цикл и интеграция
- Инициализация: `initialize(config, services)`.
- Завершение: `close()`.
- Доступ к сервисам: `services.config`, `pending_questions`, `task_store`, `scheduler_tasks`, `user_tasks` и др.
- Автоматическая очистка диалогов при смене/закрытии сессии или отключении агента.

## Регистрация плагинов
- Автоматическая загрузка из `agent/plugins/` (исключая `__init__.py`, `base.py`).
- Имена инструментов: `{function_prefix}.{spec.name}`.

## Рекомендации
- Обрабатывайте ошибки в `execute()` локально, возвращая структурированный ответ.
- Для длительных операций увеличьте `DIALOG_TIMEOUT`.
- Плагин не должен напрямую зависеть от `bot.py` — используйте абстракции `ToolPlugin`.

## Пример функциональности
Плагин с двухуровневым меню:
1. Запуск диалога → выбор режима (`fast`/`detailed`) → ввод текста → преобразование в верхний регистр.
2. Показ информации.

Обработчики: `_cb_start`, `_cb_info`, `_on_mode_button`, `_on_mode_text`, `_on_input`.

# TaskManagementTool — Управление задачами в Telegram-боте

## Назначение
Инструмент для управления задачами в Telegram-боте с поддержкой создания, просмотра, обновления и удаления задач. Реализует приоритеты, статусы, дедлайны, теги и уведомления. Данные хранятся в JSON-файле `tasks.json` в директории `_shared` (определяется через `AGENT_SANDBOX_ROOT` или fallback в текущую).

## Ключевые сущности
- **`TaskManagementTool`** — основной класс, наследующий `DialogMixin` и `ToolPlugin`.
- **Задача** — содержит:
  - `task_id`: уникальный ID (на основе временной метки и UUID)
  - `title`, `description` (опционально)
  - `priority`: high / medium / low
  - `status`: pending / in_progress / completed / cancelled
  - `deadline`: строка в формате "YYYY-MM-DD HH:MM"
  - `deadline_ts`: Unix-время дедлайна
  - `last_updated`: временная метка последнего изменения
  - `notify`: флаги уведомлений
- **Хранение**: вложенный словарь `{user_id: {task_id: task_data}}`, где `user_id` — фактически `chat_id`.

## Функциональность
- **Операции**:
  - `create`: создание задачи (с парсингом приоритета, дедлайна и заголовка)
  - `list`: вывод до 50 задач, отсортированных по статусу, дедлайну и приоритету
  - `update`: изменение полей задачи
  - `delete`: удаление по `task_id`
- **Диалоговый ввод**: состояние `wait_text` для добавления задачи, отмена через команды: `отмена`, `cancel`, `выход`, `-`.
- **Интерфейс**: формируется через `_build_tasks_menu` (до 12 задач с кнопками). Поддержка callback-команд: `add`, `refresh`, `view`, `del`, `next`, `view_help`.

## Настройки уведомлений (`_NotifyPolicy`)
- `due_soon_window_sec`: интервал для уведомления о скором дедлайне
- `overdue_repeat_sec`: минимальный интервал между повторами уведомлений о просрочке
- `check_interval_sec`: частота проверки дедлайнов (реализована в `bot.py`)
- Уведомления отправляются однократно при входе в "скоро истекает" и с повтором при просрочке.

## Технические особенности
- Все операции — асинхронные, совместимы с `telegram.ext`.
- Валидация: формат дедлайна, допустимые значения приоритета и статуса.
- Автогенерация `task_id`.
- Изоляция данных по `user_id`.
- Вспомогательные функции: `_load_all_tasks`, `_save_all_tasks`.
- Логирование ошибок при работе с файлом.

Инструмент `MovieInfoTool` предоставляет доступ к информации о фильмах через API The Movie Database (TMDb). Поддерживает два действия: получение фильмов, текущих в прокате (`now_playing`), и поиск фильмов по критериям (`discover`) с возможностью фильтрации по жанру. 

Ключевые параметры:
- `action` (обязательный): тип запроса — `now_playing` или `discover`.
- `genre_id`: идентификатор жанра TMDb для фильтрации.
- `count`: количество возвращаемых фильмов (от 1 до 30, по умолчанию 10).
- `language`: язык локализации (по умолчанию `ru-RU`).
- `region`: регион для фильтрации проката (по умолчанию `RU`).

Требует наличие переменной окружения `TMDB_API_KEY`. Запросы к API выполняются синхронно в отдельном потоке. Результат включает название, дату выхода, рейтинг и краткое описание фильма (обрезанное до 200 символов). Вывод автоматически обрезается для соответствия ограничениям системы. Инструмент поддерживает параллельное выполнение и имеет таймаут 60 секунд.

Инструмент `delete_file` предназначен для удаления файлов в пределах рабочей директории. Является частью системы плагинов инструментов агента и реализует интерфейс `ToolPlugin`. Основное назначение — безопасное удаление файлов с проверкой на принадлежность рабочему пространству.

Ключевые сущности:
- `ToolSpec` — описание инструмента, включая имя, описание и параметры.
- `helpers._resolve_within_workspace` — проверяет и разрешает путь внутри рабочей директории.
- `helpers._is_other_user_workspace` — блокирует доступ к файлам из чужого рабочего пространства.

Параметры:
- `path` (обязательный) — путь к удаляемому файлу, относительный или абсолютный, но должен находиться в workspace.

Особенности:
- Удаление возможно только для файлов, находящихся в текущей рабочей директории (`cwd`).
- При отсутствии файла возвращается ошибка "File not found".
- Попытка удалить файл вне workspace или в чужом workspace блокируется.
- В случае успеха возвращается сообщение `Deleted: <path>`, иначе — описание ошибки.

Инструмент `search_web` предназначен для выполнения поисковых запросов в интернете. Используется для получения актуальной информации: новости, текущие события, определения, цены, погода и другая внешняя информация. Ключевая сущность — класс `SearchWebTool`, наследующий `ToolPlugin`. Основные параметры: `name`, `description`, `parameters` (с обязательным полем `query` типа строка). Уровень риска — средний (`medium`). Выполнение делегируется вспомогательной функции `search_web_impl`, которая использует переданный `config` для настройки поиска. Требует наличия параметра `query` в аргументах.

# Haiper Image-to-Video Tool — Краткое резюме

**Назначение**  
Инструмент для преобразования изображения в видео с использованием внешнего API `api.vsegpt.ru`. Позволяет пользователям через Telegram загружать изображение, задавать текстовый промпт анимации и получать готовое видео в формате MP4.

**Ключевые возможности**
- Поддержка загрузки изображений: как фото, так и документы в Telegram.
- Пошаговый диалог через `DialogMixin`:  
  - `wait_image` — ожидание изображения.  
  - `wait_prompt` — ввод текстового описания анимации.
- Автоматическое определение расширения и кодирование изображения в base64.
- Генерация видео через API `https://api.vsegpt.ru/v1/video` с опросом статуса каждые 10 секунд.
- Отправка результата пользователю как документа в Telegram.

**Основные сущности**
- `HaiperImageToVideoTool`: основной класс, реализует `ToolPlugin` и `DialogMixin`.
- Временные файлы хранятся в `_shared/haiper/<chat_id>` или `/tmp/video_generation`.

**Параметры**
- `image_path` — путь к изображению (обязательный, JPG/PNG).
- `prompt` — описание анимации (опционально, по умолчанию: "animate image").
- `model` / `model_id` — версия модели (по умолчанию: `haiper-2.0`).
- `aspect_ratio` — фиксировано `16:9`.

**Настройки**
- `API_URL`: `https://api.vsegpt.ru/v1/video`
- `DIALOG_TIMEOUT`: 1 час (учитывает длительность генерации).
- `AGENT_SANDBOX_ROOT`: корень для временных файлов (по умолчанию — текущая директория).
- `ZAI_API_KEY`: API-ключ (обязателен, передаётся через окружение или конфиг).

**Процесс работы**
1. Проверка и разрешение пути к изображению.
2. Кодирование изображения в base64.
3. POST-запрос на `/generate` для запуска генерации.
4. Опрос `/status` каждые 10 секунд (до 45 минут).
5. Скачивание MP4 при успехе.
6. Сохранение и возврат пути к видео.

**Таймауты**
- Генерация: до 45 минут.
- HTTP-таймауты: 60 сек (генерация), 30 сек (статус), 120 сек (скачивание).

**Обработка ошибок**
- Полная обработка на всех этапах: загрузка, генерация, отправка.
- При ошибках возвращается словарь: `{"success": false, "error": "описание"}`.

**Особенности**
- Асинхронный вызов с синхронным выполнением в отдельном потоке.
- Поддержка интеграции в агентские системы с песочницей.

Инструмент `run_command` предназначен для выполнения shell-команд в рамках рабочей среды агента. Поддерживает операции с системой, пакетными менеджерами (git, npm, pip) и другими CLI-инструментами. Имеет встроенные механизмы безопасности.

Ключевые сущности:
- `ToolPlugin` — базовый класс плагина.
- `ToolSpec` — описание инструмента: имя, параметры, уровень риска.
- `helpers` — вспомогательные функции проверки и выполнения команд.

Основные параметры:
- `command` (обязательный) — строка с командой для выполнения.

Уровень риска: `high`. Не поддерживает параллельное выполнение (`parallelizable=False`).

Важные проверки:
- Изоляция рабочей области (`_check_workspace_isolation`).
- Попытка выхода за пределы рабочей директории (`_check_command_path_escape`).
- Анализ опасности команды (`check_command`) — блокировка или запрос подтверждения для `rm -rf`, `sudo` и аналогичных.

Если команда потенциально опасна, но не заблокирована — требуется подтверждение пользователя через callback `_APPROVAL_CALLBACK`. Выполнение откладывается до получения подтверждения.

Результат выполнения — словарь с полями `success`, `output`/`error`, при необходимости — флаг `approval_required`.

Инструмент `edit_file` позволяет редактировать файлы путём точной замены текста. Требует указания пути к файлу, текста для поиска (`old_text`) и нового текста (`new_text`). Перед редактированием выполняется ряд проверок безопасности: доступ к рабочей области, чувствительные файлы, символические ссылки, а также анализ на наличие опасного кода в новом содержимом. Поддерживает работу только в пределах рабочей директории (`cwd`), указанной в контексте. Файл должен существовать, а `old_text` — присутствовать в нём дословно. В случае успеха возвращается подтверждение, при ошибках — детализированное сообщение с возможным превью содержимого.

# Краткое резюме

Данный документ представляет собой техническую документацию, объединяющую несколько частей, описывающих архитектуру, функциональность и использование системы. В документации рассматриваются основные компоненты системы, их взаимодействие, интерфейсы и процессы. Описаны требования, принципы работы, примеры использования и рекомендации по интеграции. Документ предназначен для разработчиков, инженеров и технических специалистов, обеспечивающих развертывание и сопровождение решения.

Плагин инструмента для оптимизации пользовательских промптов с использованием модели OpenAI. Назначение — улучшение формулировки исходного запроса для повышения точности и качества ответов модели. Основная сущность — класс `PromptPerfectTool`, реализующий интерфейс `ToolPlugin`.

Ключевые параметры инструмента:
- `original_prompt` (обязательный) — исходный текст промпта, который необходимо оптимизировать.
- `context` (опциональный) — дополнительный контекст, уточняющий задачу.

Инструмент использует настройки из переменных окружения или конфигурации:
- `OPENAI_API_KEY` — API-ключ для доступа к OpenAI (обязателен).
- `OPENAI_BASE_URL` — базовый URL для API (опционально, используется при работе с прокси или локальными эндпоинтами).
- `OPENAI_MODEL` — модель для оптимизации (по умолчанию `gpt-4o-mini`).

В процессе выполнения формируется системное сообщение с инструкцией по улучшению промпта, после чего запрос отправляется в модель. Результат — оптимизированный промпт, возвращаемый в поле `output`. При ошибках возвращается флаг `success: False` и описание проблемы.

Инструмент `auto_tts` для генерации аудио из текста с использованием OpenAI TTS. Позволяет озвучивать текст с выбором голоса, модели, формата вывода и дополнительных инструкций. Результат — путь к сохранённому аудиофайлу в формате mp3, opus, aac, flac, wav или pcm.

Ключевые параметры:
- `text` — текст для озвучивания (обязательный)
- `voice` — голос (допустимые значения: alloy, ash, ballad, coral, echo, sage, shimmer, verse, marin, cedar; по умолчанию: alloy)
- `model` — модель TTS (по умолчанию: gpt-4o-mini-tts)
- `response_format` — формат аудиофайла (по умолчанию: mp3)
- `instructions` — дополнительные инструкции для голоса (опционально)

Требует наличие `OPENAI_API_KEY` в переменных окружения или в конфигурации. Базовый URL для OpenAI может быть задан через `OPENAI_BASE_URL`. Аудиофайлы сохраняются во временной директории `/tmp/tts` (или аналоге для ОС). Инструмент поддерживает параллельное выполнение и имеет таймаут 120 секунд.

Инструмент для генерации изображений по текстовому промпту с использованием HuggingFace Inference API. Реализован как плагин `ToolPlugin` и предоставляет методы для асинхронного выполнения через `execute`. Основан на модели Stable Diffusion, поддерживает указание кастомной модели через параметр `model` (по умолчанию — `HiDream-ai/HiDream-I1-Full`).

Ключевые параметры:
- `prompt` (обязательный) — текстовое описание изображения.
- `model` (опциональный) — идентификатор модели в репозитории HuggingFace.

Для работы требуется токен аутентификации в переменной окружения `STABLE_DIFFUSION_TOKEN`. Изображение сохраняется во временной директории `/tmp/image_generation` (или аналоге для ОС) с расширением `.png`, возвращается путь к файлу.

При первой генерации для "холодной" модели выполняется повторный запрос. Таймаут операции — 300 секунд. Ошибки логируются, возвращаются в виде словаря с `success=False` и описанием проблемы.

Плагин инструмента для делегирования сложных задач во внешний CLI-интерфейс (например, codex/gemini/claude code). Используется, когда задача требует полноценного цикла разработки или выходит за рамки возможностей стандартных инструментов. Основная сущность — `UseCliTool`, реализующая интерфейс `ToolPlugin`. Ключевой параметр выполнения — `task_text`, содержащий описание задачи. Для работы требуется активная сессия CLI, передаваемая через контекст (`ctx["session"]`). В случае успеха возвращает обрезанный вывод сессии, в случае ошибки — сообщение об ошибке. Вывод очищается от ANSI-кодов.

# RemindersTool — Управление напоминаниями в Telegram-боте

## Назначение
Инструмент `RemindersTool` предоставляет функциональность создания, просмотра и удаления пользовательских напоминаний через Telegram-бота. Работает в связке с системой диалогов и обработки callback-запросов.

## Основные возможности
- **Создание напоминаний** по формату `ГГГГ-ММ-ДД ЧЧ:ММ текст`
- **Просмотр списка** активных напоминаний с отображением времени выполнения и оставшегося времени
- **Удаление** напоминаний по ID с проверкой принадлежности
- Поддержка интерактивного интерфейса: кнопки, диалоги, клавиатуры

## Ключевые сущности
- `reminder_id` — уникальный идентификатор напоминания
- `services["scheduler_tasks"]` — хранилище задач с деталями выполнения
- `services["user_tasks"]` — привязка пользователей к их активным напоминаниям

## Поддерживаемые действия (`execute`)
- `set` — запуск диалога создания напоминания
- `list` — отображение списка активных напоминаний
- `delete` — удаление по ID
- `view`, `close_menu` — вспомогательные действия для интерфейса

## Ограничения
- Макс. длительность напоминания: **24 часа (86400 сек)**
- Макс. количество на пользователя: **5 активных напоминаний**
- Формат времени: строго `YYYY-MM-DD HH:MM`
- Отмена ввода: команды `отмена`, `cancel`, `выход`, `-`

## Технические особенности
- Использует `DialogMixin` для пошагового ввода
- Асинхронное выполнение через `asyncio.create_task`
- Автоматическая очистка после срабатывания
- Отправка уведомлений через `bot._send_message`
- Таймаут инструмента: **30 секунд**
- Не поддерживает параллельное выполнение (`parallelizable=False`)

## Интеграция
- Доступ через меню: "Напоминания" → "Список", "Создать"
- Callback-действия: `list`, `set`, `delete`, `view`, `close_menu`
- Динамическое обновление времени в описании инструмента

Инструмент `write_file` предназначен для создания или перезаписи файлов в рабочей директории агента. Обеспечивает безопасную запись с проверкой пути и содержимого. Поддерживает разрешение путей относительно рабочей директории (`cwd`), блокирует запись в чувствительные файлы, чужие рабочие пространства и при обнаружении символических ссылок, ведущих за пределы workspace. Проверяет содержимое на наличие потенциально опасного кода (например, утечки секретов). Требует параметры `path` и `content`. При успешной записи возвращает количество записанных байт. Все операции логируются, ошибки обрабатываются с безопасным возвратом.

Инструмент `search_files` предназначен для поиска файлов в проекте с использованием glob-шаблонов. Позволяет агенту исследовать структуру проекта, находя файлы по заданному пути с поддержкой рекурсии (`**`).  

Ключевые параметры:
- `pattern` — строка с glob-шаблоном (например, `**/*.ts`, `src/**/*.js`), обязательный параметр.

Особенности реализации:
- Запрещены шаблоны с выходом за пределы рабочей директории (`..`) во избежание path traversal.
- Поиск ограничен текущей рабочей директорией (`ctx["cwd"]`), проверяется через `realpath`.
- Исключаются пути внутри `node_modules` и `.git`.
- Пропускаются директории — в результат попадают только файлы.
- Максимальное количество возвращаемых файлов — 200.
- В случае ошибки возвращается сообщение об ошибке, исключения логируются.

Возвращаемый результат:
- При успехе: `{"success": True, "output": "список файлов через \\n"}`.
- При ошибке: `{"success": False, "error": "описание ошибки"}`.

Плагин инструмента для извлечения и парсинга содержимого веб-страницы по заданному URL. Возвращает очищенный текст в формате Markdown. Основан на базовом классе `ToolPlugin` и реализует методы `get_spec` и `execute`. 

Ключевая сущность — `FetchPageTool`, предоставляющий спецификацию инструмента с именем `fetch_page`, обязательным параметром `url` (строка) и уровнем риска `medium`. Выполнение делегирует функции `fetch_page_impl` из модуля `helpers`, передавая URL и конфигурацию инструмента. Требует корректной настройки `self.config` для работы (например, таймауты, заголовки, политики доступа). Используется в агентских сценариях, где необходима загрузка внешнего контента.

Инструмент для извлечения и очистки текстового содержимого веб-страниц по заданному URL. Использует внешний сервис [r.jina.ai](https://r.jina.ai) для получения основного текста без HTML-разметки. В случае недоступности Jina применяется fallback-запрос напрямую к URL.

**Ключевые параметры:**
- `url` (обязательный) — адрес целевой страницы.
- `max_chars` (опциональный, по умолчанию 6000, ограничение от 500 до 20000) — максимальное количество символов в ответе.

**Особенности:**
- Выполняется асинхронно с использованием `asyncio.to_thread` для синхронных HTTP-запросов.
- Автоматически обрезает вывод с помощью `helpers._trim_output`.
- При ошибках возвращает структурированную информацию с флагом `success: False`.
- Поддерживает параллельное выполнение.
- Таймаут операции — 60 секунд.

**Зависимости:** `requests`, внешний API `r.jina.ai`.

Инструмент для извлечения субтитров с YouTube-видео по его `video_id`. Поддерживает выбор языка и автоматическое определение доступных транскрипций (ручные, сгенерированные). Использует библиотеку `youtube-transcript-api`, которая должна быть установлена.

Ключевые параметры:
- `video_id` (обязательный) — идентификатор видео на YouTube.
- `languages` — приоритетный список языков (по умолчанию `['ru', 'en']`).

Инструмент пытается найти транскрипцию в порядке: ручная → автоматическая → любая доступная. Возвращает текст субтитров с указанием языка и типа (ручной/автогенерированный). Поддерживает выполнение в параллельных потоках и имеет таймаут 60 секунд. Ошибки логируются, пустой или отсутствующий `video_id` приводит к ошибке выполнения.

# WebResearchTool — Краткое резюме

Плагин `WebResearchTool` предназначен для проведения асинхронных мультиязычных веб-исследований (поддержка: русский, английский, китайский). На основе пользовательского запроса генерирует уточнённые поисковые фразы с помощью OpenAI, находит релевантные ссылки через Jina AI Search API и при необходимости анализирует их содержимое с использованием LLM.

## Основные возможности
- **Генерация поисковых запросов**: до 5 уточнённых фраз на каждом языке с помощью OpenAI.
- **Поиск статей**: через Jina AI (`s.jina.ai`) с поддержкой языков и ограничением результатов (`max_results_per_lang`, по умолчанию 10).
- **Загрузка и очистка контента**: асинхронное извлечение текста из HTML/PDF с использованием:
  - `trafilatura` (основной),
  - `BeautifulSoup` (fallback),
  - Jina Reader API (`r.jina.ai`) — резервный метод.
- **Анализ содержимого**: агрегация и обработка текста через большую языковую модель (LLM) для формирования структурированного ответа с указанием источников.
- **Автоматическое определение языка**, типа контента и очистка URL.

## Ключевые методы
- `_generate_search_queries_lang`: генерация поисковых запросов на заданном языке.
- `_find_articles_for_language`: параллельный поиск по языку с round-robin объединением результатов.
- `_download_content`: загрузка и очистка контента с поддержкой таймаутов, редиректов и сжатия.
- `_analyze_content_with_llm`: анализ агрегированного текста с помощью LLM.
- `execute`: основной метод, координирующий весь процесс.

## Настройки
- Обязательные: `JINA_API_KEY`, `OPENAI_API_KEY`.
- Опциональные: `OPENAI_BASE_URL`, `OPENAI_MODEL`, `OPENAI_BIG_MODEL`.
- Таймауты: 20 сек (загрузка), 30 сек (Jina API).
- Поддержка кастомных заголовков, логирования, fallback-механизмов при ошибках.

## Результат
- Список релевантных ссылок по языкам.
- Опционально — аналитическое резюме с источниками.
- Отчёт о выполнении (найдено/загружено статей), обработка ошибок на всех этапах.

Плагин устойчив к частичным сбоям и обеспечивает высокую точность и читаемость результатов.

Инструмент `schedule_task` позволяет планировать напоминания или выполнение команд с задержкой. Поддерживает три действия: добавление задачи, просмотр списка задач пользователя и отмену задачи по ID. Максимальная задержка — 24 часа, максимум 5 задач на пользователя.

Ключевые параметры:
- `action`: действие (`add`, `list`, `cancel`)
- `type`: тип задачи (`message` — напоминание, `command` — выполнение shell-команды)
- `content`: текст напоминания или команда для выполнения
- `delay_minutes`: задержка в минутах (1–1440)
- `task_id`: идентификатор задачи (требуется для отмены)

Задачи хранятся во внутренних хранилищах `scheduler_tasks` (по ID) и `user_tasks` (по пользователю). При срабатывании отправляется сообщение через бота. Команды выполняются через `helpers.execute_shell_command` с ограничением вывода до 500 символов. Задачи удаляются из хранилища после выполнения или отмены.

Файл реализует инструмент долговременной памяти для агента, позволяющий сохранять, читать и очищать текстовые записи с автоматическим добавлением временных меток. Предназначен для хранения важной информации: контекста проекта, решений, задач и т.п. — с сохранением между сессиями.

Ключевые сущности: `MemoryTool` — основной класс, наследующий `DialogMixin` и `ToolPlugin`, обеспечивает интеграцию с интерфейсом агента и диалоговым взаимодействием. Поддерживает три действия: `read`, `append`, `clear`.

Основные настройки и параметры:
- `MEMORY_FILE` — имя файла для хранения памяти (определяется в `tooling.helpers`).
- Путь к файлу памяти формируется на основе `config.defaults.workdir` или переменной окружения `AGENT_SANDBOX_ROOT`.
- Файл создаётся в подкаталоге `_sandbox` рабочей директории.

Интерфейс:
- В меню доступны действия: «Показать», «Добавить запись», «Очистить».
- Поддержка команд через диалоговый интерфейс и API агента.
- При добавлении записи запрашивается текст через диалог; отмена возможна по ключевым словам.

API-метод `execute` позволяет использовать инструмент в автоматизированных сценариях с параметрами:
- `action` (обязательный): `read`, `append`, `clear`.
- `content`: текст для добавления (только для `append`).

Файл обеспечивает отказоустойчивое чтение и запись с обработкой ошибок, поддерживает русский интерфейс и ограничение длины вывода (до 3500 символов).

Инструмент `ChiefTool` предоставляет доступ к поиску рецептов через API Edamam по заданным ингредиентам или запросу. Поддерживает асинхронное выполнение и параллельный запуск. Для работы требует переменные окружения `EDAMAM_APP_ID` и `EDAMAM_APP_KEY`. Основной метод `execute` принимает параметры `query` (обязательный) и `count` (необязательный, от 1 до 10), возвращает найденные рецепты с названием, источником и ссылкой. Поиск выполняется синхронно в отдельном потоке через `asyncio.to_thread`. Результаты обрезаются и форматируются с помощью вспомогательной функции `_trim_output`. Ключевые параметры: `query`, `count`, `app_id`, `app_key`, `timeout_ms=60000`.

Инструмент `manage_tasks` предназначен для управления списком задач в рамках сессии. Позволяет добавлять, обновлять, просматривать и очищать выполненные задачи, что полезно при планировании многоэтапных операций. Основные сущности — задачи с полями `id`, `content`, `status` и `created_at`. Задачи хранятся в `services.task_store` с привязкой к `session_id`.

Поддерживаемые действия:
- `add`: добавляет новые задачи или обновляет существующие по `id`.
- `update`: изменяет поля `content` или `status` у существующих задач.
- `list`: возвращает отформатированный список всех задач текущей сессии.
- `clear`: удаляет задачи со статусами `completed` или `cancelled`.

Ключевые параметры в `args`: `action` (обязательный), `tasks` (массив задач). Каждая задача должна содержать `id` и `content`. Статус по умолчанию — `pending`. Результат выполнения включает флаг `success` и поле `output` с данными или сообщением. Инструмент не поддерживает параллельное выполнение.

Инструмент `GTTSTextToSpeechTool` реализует генерацию аудио из текста с использованием сервиса Google Text-to-Speech (gTTS). Является плагином инструмента для агента, позволяет асинхронно озвучивать текст на указанном языке и возвращать путь к сохранённому MP3-файлу.

Ключевые сущности:
- `get_spec` — определяет интерфейс инструмента: имя `gtts_text_to_speech`, обязательный параметр `text`, опциональный `lang` (по умолчанию `ru`), формат вывода — путь к файлу.
- `execute` — асинхронно вызывает синхронную функцию озвучки в отдельном потоке, обрабатывает ошибки.
- `_tts_sync` — синхронная логика: генерация речи через `gTTS`, сохранение в временной директории `/tmp/tts` (или `temp` в Windows) с уникальным именем на основе timestamp.

Важные настройки:
- Таймаут выполнения — 90 секунд.
- Поддержка параллельного выполнения (`parallelizable=True`).
- Файлы сохраняются во временной директории ОС в подкаталоге `tts`.
- Требуется установленный пакет `gTTS` (`pip install gTTS`).

Клиент для взаимодействия с MCP (Model Control Protocol) через HTTP, использующий JSON-RPC 2.0 для обмена сообщениями. Предназначен для асинхронного вызова инструментов (tools), их перечисления и инициализации соединения с MCP-сервером.

Основные сущности:
- `HttpMCPClientConfig` — конфигурация клиента: имя, URL сервера, таймаут, заголовки и версия протокола.
- `HttpMCPClient` — основной класс клиента, реализующий логику соединения, отправки запросов и обработки ответов.

Ключевые методы:
- `start()` — инициализирует HTTP-клиент и выполняет `initialize` и `initialized` вызовы.
- `stop()` — закрывает соединение.
- `list_tools()` — возвращает список доступных инструментов с их описанием и схемой входных данных.
- `call_tool()` — вызывает указанный инструмент с заданными аргументами.

Особенности:
- Использует `httpx.AsyncClient` для асинхронных HTTP-запросов.
- Поддерживает JSON-RPC 2.0, включая уведомления (без `id`).
- Автоматически обрабатывает ошибки и пустые ответы.
- При инициализации отправляет `initialize` и `notifications/initialized`, что совместимо с MCP-шлюзом на `127.0.0.1:8888`.

Конфигурационные параметры (`HttpMCPClientConfig`):
- `name` — логическое имя клиента.
- `url` — адрес MCP-сервера.
- `timeout_ms` — таймаут запроса в миллисекундах (по умолчанию 30 000).
- `headers` — дополнительные HTTP-заголовки.
- `protocol_version` — версия MCP-протокола (по умолчанию "2024-11-05").

Клиент для взаимодействия с MCP (Model Control Protocol) сервером через стандартные потоки ввода-вывода. Реализует асинхронное взаимодействие по протоколу JSON-RPC, поддерживает инициализацию, вызов инструментов и получение списка доступных инструментов.

Основные сущности:
- `StdioMCPClient` — основной класс клиента, управляющий подключением к MCP-серверу, отправкой запросов и обработкой ответов.
- `MCPToolInfo` — дата-класс, описывающий метаданные инструмента: имя, описание и схему входных параметров.
- `JsonRpcStream` — обёртка для чтения/записи JSON-RPC сообщений через `stdin`/`stdout`.

Ключевые функции:
- `start()` — запускает процесс MCP-сервера и инициирует handshake (инициализацию).
- `stop()` — останавливает процесс и завершает соединение.
- `list_tools()` — возвращает список доступных инструментов.
- `call_tool()` — вызывает указанный инструмент с заданными аргументами.

Параметры инициализации:
- `name` — имя клиента (для логирования).
- `cmd` — команда для запуска MCP-сервера.
- `cwd` — рабочая директория процесса.
- `env` — переменные окружения.
- `timeout_ms` — таймаут ожидания ответа от сервера.
- `protocol_version` — версия MCP-протокола (по умолчанию "2024-11-05").

Внутренние механизмы:
- Используется `asyncio` для асинхронного обмена сообщениями.
- `_reader_loop` — фоновая задача, обрабатывающая входящие JSON-RPC сообщения.
- `_pending` — словарь ожидающих ответов, сопоставляющий `id` запроса с `Future`.
- `_lock` — обеспечивает потокобезопасность при генерации идентификаторов запросов.

Особенности:
- При неудачной инициализации клиент продолжает работу, полагая, что сервер может поддерживать базовые методы.
- Логирование ошибок выполняется через стандартный модуль `logging`.

Класс `JsonRpcStream` обеспечивает чтение и запись JSON-RPC сообщений с поддержкой двух форматов фрейминга: LSP-совместимого (на основе заголовка `Content-Length`) и NDJSON (по одному JSON-объекту на строку). Используется для обмена сообщениями в асинхронных клиент-серверных взаимодействиях, например, с Language Server Protocol.

Основные сущности:
- `reader` и `writer` — объекты `asyncio.StreamReader` и `asyncio.StreamWriter` для работы с потоком ввода-вывода.
- `write()` — отправляет JSON-объект, используя по умолчанию `Content-Length` фрейминг (если `prefer_content_length=True`), иначе — в формате NDJSON.
- `read()` — читает следующее сообщение, автоматически определяя формат по первому блоку данных: если строка начинается с `Content-Length:`, применяется LSP-фрейминг, иначе — ожидается NDJSON.

Ключевые особенности:
- При чтении `Content-Length` обрабатываются заголовки до пустой строки, затем читается тело указанной длины.
- Некорректные JSON-сообщения или заголовки игнорируются, возвращается `None`.
- Логирование ошибок парсинга выполняется через модуль `logging`.
- Функция `encode_content_length_message` формирует корректный заголовок `Content-Length` и тело сообщения в соответствии с LSP.

Модуль обеспечивает интеграцию MCP-клиента с внешними инструментальными серверами. Предназначен для управления подключением, отправки запросов и обработки ответов от внешних инструментов через MCP (Model Communication Protocol). Ключевые сущности включают клиентское соединение, обработчики инструментов и маршрутизацию запросов. Поддерживает настройку URL сервера, тайм-аутов соединения, аутентификации (при наличии) и списка доступных инструментов. Основные параметры: `server_url`, `timeout`, `headers`, `tools`. Используется для расширения функциональности системы за счёт внешних сервисов — например, баз данных, API или вычислительных модулей.

Класс `MCPManager` управляет подключением и взаимодействием с MCP-серверами (Model Control Protocol), обеспечивая запуск клиентов, кэширование инструментов и вызов методов. Поддерживает два типа транспорта: `stdio` и `http`. Инициализация клиентов происходит лениво и защищена блокировкой. Инструменты кэшируются в JSON-файле по пути `_shared/mcp_tools_cache.json` для ускорения последующих запусков. Методы `list_all_tools`, `call` и `build_registry_name` позволяют получать доступные инструменты, вызывать их и формировать имена, совместимые с ограничениями OpenAI. Ключевые параметры: `enabled`, `transport`, `cmd`, `url`, `timeout_ms`, `headers` — задаются через конфигурацию `AppConfig`.

Тест проверяет, что при отправке большого объёма вывода в HTML-формате корректно обрезается начало, а отправляется только конец (последние 10 000 символов). Используется заглушка `ansi_to_html` для фиксации переданной строки; ожидается, что ей будет передан хвост вывода (`tail`). Настройки теста включают временный каталог, конфигурацию бота с одним инструментом `dummy`, ограничение на длину вывода и моки для методов отправки сообщений и документов. Тест асинхронный, выполняется через `asyncio.run`.

Файл содержит модульные тесты для метода `_next_ready_task` класса `ManagerOrchestrator`, отвечающего за выбор следующей задачи для выполнения с учётом зависимостей, статусов, попыток и блокировок. Основное внимание уделено логике определения готовности задачи, нормализации статусов после перезапуска и каскадному блокированию зависимых задач.

Ключевые сущности: `DevTask`, `ProjectPlan`, `ManagerOrchestrator`.

Тестируемая логика включает:
- Выбор первой подходящей задачи из списка.
- Пропуск задач со статусом `approved`.
- Обработку зависимостей: задача становится готовой только после успешного завершения всех зависимостей.
- Каскадное блокирование задач при провале зависимостей (статус `blocked`).
- Нормализацию временных статусов (`in_progress`, `in_review`, `rejected`) в `pending` при условии, что количество попыток не исчерпано.
- Перевод задачи в статус `failed`, если количество попыток (`attempt`) достигло `max_attempts`.
- Корректное завершение плана, когда все задачи завершены или заблокированы.

Также проверяется вспомогательный метод `_is_plan_blocked`, определяющий, заблокирован ли весь план (нет ни одной готовой к выполнению задачи).

Тест-файл для проверки логики декомпозиции менеджера: разбор JSON, обработка fallback-сценариев и преобразование полезной нагрузки в план (`payload_to_plan`). Основные тестируемые компоненты:

- `_extract_json_object` — извлекает JSON из строки, корректно обрабатывая Markdown-разметку (с указанием `json` или без), вложенные объекты, текст вокруг JSON и пустые/некорректные входные данные.
- `_truncate_report` — усекает длинные тексты до заданного лимита символов, добавляя уведомление об обрезке; корректно обрабатывает короткие, пустые и `None` значения.
- `_payload_to_plan` (через `ManagerOrchestrator._try_parse_plan`) — преобразует словарь в объект `ProjectPlan`, валидируя структуру, ограничивая количество задач (`max_tasks`), поддерживая альтернативные ключи (`analysis` и `project_analysis`) и возвращая `None` при отсутствии задач.

Ключевые сущности: `ProjectPlan`, `DevTask`, `ManagerOrchestrator`.  
Важные настройки (в `_FakeConfig`): `manager_max_tasks`, `manager_dev_report_max_chars`.  
Тесты обеспечивают устойчивость к разнообразным входным форматам и граничным случаям.

Тестовый файл, проверяющий корректность работы агента в боте без отправки сообщений. Использует временные пути и моки для изоляции среды. Основная цель — убедиться, что при выполнении агента не происходит отправки сообщений через `_send_message` или `_send_document`, даже если агент возвращает финальный ответ.  

Конфигурация `AppConfig` инициализируется с минимальными параметрами: отключён MCP, заданы пути к рабочей директории и файлам состояния, определён инструмент `dummy` в режиме `headless`. Создаётся сессия с включённым агентом. Методы отправки сообщений заменяются моками через `monkeypatch`, а `agent.run` заменяется на заглушку, возвращающую тестовый текст.  

После вызова `app.run_agent` проверяется, что список `sent` остался пустым — подтверждение, что сообщения не отправлялись. Тест асинхронный, запускается через `asyncio.run`.

Тест проверяет корректность установки режима разметки и экранирования текста при отправке сообщений через метод `_send_message` в боте. Основное внимание уделено поведению при использовании MarkdownV2 (`md2=True`): проверяется, что параметр `parse_mode` устанавливается в `"MarkdownV2"`, а текст корректно форматируется. При отключённом `md2` режим разметки не должен передаваться. Используются временная директория (`tmp_path`) и моки для изоляции теста. Тест асинхронный, запускается через `asyncio.run`.

Тест-файл для проверки функциональности реестра инструментов и отдельных плагинов в агентской системе. Основное назначение — верификация корректной регистрации инструментов, выполнения их вызовов и защиты от ошибок в реализациях.  

Ключевые сущности: `ToolRegistry` — реестр инструментов, `search_web`, `run_command`, `CodeInterpreterTool` — примеры инструментов.  

Проверяются следующие аспекты:  
- Имена инструментов регистрируются без префиксов (без точечной нотации).  
- Вызов `search_web` корректно делегируется реализации через `helpers.search_web_impl` с передачей параметров.  
- Метод `_static_block` в `CodeInterpreterTool` безопасен к выполнению и не вызывает исключений при обработке валидного кода.  

Используется `monkeypatch` для изоляции тестов и `asyncio.run` для синхронного выполнения асинхронных вызовов. Конфигурация загружается из `config_example.yaml` через `load_config`.

Тест-файл для проверки выбора модели в веб-исследовательском инструменте `WebResearchTool`. Проверяет приоритет настройки модели: переменная окружения `OPENAI_BIG_MODEL` имеет приоритет над значением из конфигурационного файла. Используются фикстуры `monkeypatch` для мокинга переменных окружения и загрузки конфигурации из `config_example.yaml`. Ключевые сущности: `WebResearchTool`, `load_config`, параметры `openai_big_model` и `big_model_to_use`. Тесты убеждаются, что метод `_get_model(big=True)` возвращает корректное имя модели в зависимости от контекста — конфиг или переменная окружения.

# Резюме документации: Тестирование модуля `OrchestratorRunner`

Файл содержит модульные тесты для `OrchestratorRunner`, направленные на проверку корректности формирования и отправки финального ответа агентом. Основные аспекты:

- **Тестируемые функции**:  
  - Формирование финального ответа с текстом "Готово".  
  - Вызов `send_output` с параметрами `force_html=True`, `send_header=False`.  
  - Неблокирующее выполнение `orchestrator.run` (проверка через таймаут).  
  - Отправка артефактов через `send_document` при наличии `file` в `ExecutorResponse`.

- **Ключевые сущности**:  
  - `OrchestratorRunner` — основной тестируемый класс.  
  - `ExecutorResponse`, `PlanStep` — данные, участвующие в обработке шагов.  
  - `_FakeBot` — заглушка бота для имитации отправки сообщений.

- **Тестовая инфраструктура**:  
  - Используются `tmp_path` для изолированных временных файлов.  
  - Конфигурация инициализируется через `AppConfig` с указанием путей.  
  - Моки и заглушки:  
    - `_execute_step`, `_maybe_update_memory` — фиктивные реализации.  
    - `chat_completion` — возвращает "FINAL".  

- **Сценарии**:  
  - Запуск оркестратора с целевым назначением (например, Telegram).  
  - Проверка, что бот получил ожидаемые документы (включая `artifact_path`).  
  - Подтверждение ассертов по завершении теста.

Тесты обеспечивают изолированное, неблокирующее и детерминированное выполнение с проверкой внешних взаимодействий.

Тест проверяет, что агент продолжает работу после единичного сбоя инструмента. Используется фиктивный реестр инструментов `_FakeToolRegistry`, имитирующий нестабильный инструмент `flaky_tool`, который падает при первом вызове и успешно выполняется при втором. Агент `ReActAgent` настроен с тестовой конфигурацией `AppConfig`, включающей временные пути и заглушки для внешних зависимостей. Метод `_call_openai` заменяется моком, который последовательно возвращает два вызова инструмента, а затем завершающее сообщение без инструментов. Тест убеждается, что агент не прерывается при первой ошибке и в итоге достигает статуса `ok` или `partial` с ожидаемым выводом `"done"`.

Устанавливает путь к корню репозитория, чтобы модули верхнего уровня (например, `bot.py`, `config.py`) были доступны для импорта в тестах. Добавляет корневую директорию проекта в `sys.path`, если она ещё не присутствует. Используется в тестовых файлах для корректного разрешения зависимостей без необходимости установки пакета.

Модуль содержит тесты для функций `parse_dotenv` и `load_dotenv` из `dotenv_loader`, а также проверку интеграции загрузки переменных окружения при чтении конфигурации. Основное назначение — проверка корректности разбора `.env`-файлов с учётом комментариев, кавычек, экранирования и существующих переменных окружения. Ключевые сценарии включают: разбор базовых значений, обработку пробелов и хэшей, поведение при наличии уже установленных переменных (`override=False`/`True`) и автоматическую загрузку `.env` из директории с конфигурационным файлом. Используются временные пути (`tmp_path`) и моки окружения (`monkeypatch`) для изолированного тестирования.

Тест-функции для проверки корректности работы метода `_trim_fetch_output` из модуля `helpers`. Основное назначение — убедиться, что вывод обрезается до допустимого размера (`FETCH_MAX_CHARS`, не более 80k символов) с добавлением уведомления об обрезании, если исходный текст превышает лимит. Первый тест проверяет обрезание и наличие маркера "обрезано" в строке, второй — что короткие строки остаются без изменений. Используется для регрессионной проверки поведения при обработке больших объёмов данных.

Файл содержит тесты для функций хранения и управления проектным планом в модуле `manager_store`. Проверяется корректность сохранения, загрузки, архивирования и удаления объекта `ProjectPlan` с использованием временной директории (`tmp_path`). В тесте участвуют сущности `ProjectPlan`, `ProjectAnalysis` и `DevTask`. Основные проверки включают: полноту данных после сохранения и загрузки, изменение статуса при архивировании, отсутствие плана после архивации и идемпотентность операции удаления. Ключевые параметры — путь к рабочей директории и статус при архивации.

Тест проверяет, что значение таймаута в профиле по умолчанию установлено в 240 секунд (240 000 миллисекунд). Загружает конфигурацию из примера файла `config_example.yaml`, инициализирует реестр инструментов и строит профиль по умолчанию. Основная проверка — соответствие атрибута `timeout_ms` объекта профиля ожидаемому значению. Использует фикстуры и компоненты: `load_config`, `ToolRegistry`, `build_default_profile`.

Тест проверяет, что при суммировании длинного текста (5000 символов) с ограничением по длине результата (`max_chars=500`) используется указанный в конфигурации *крупный* модельный параметр `openai_big_model`. Создаётся временная конфигурация `AppConfig` с моком OpenAI-клиента, который фиксирует, какая модель была вызвана. Убеждается, что в запросе к API использовалась модель `big-model`, а не `openai_model`. Тест использует `monkeypatch` для подмены клиента и `asyncio` для асинхронного выполнения.

Тест проверяет сохранение и восстановление состояния `SessionManager` при включённом режиме менеджера. Использует временный путь (`tmp_path`) для изолированного тестирования файловой системы. Загружает конфигурацию из примера `config_example.yaml`, настраивает путь к состоянию (`state_path`) и рабочую директорию. Создаёт сессию с включённым `manager_enabled` и выключенным `agent_enabled`, затем сохраняет её через `_persist_sessions()`. После инициализации нового экземпляра `SessionManager` с теми же настройками проверяет, что сессия корректно восстановлена и флаг `manager_enabled` сохранён. Основные сущности: `SessionManager`, `Session`, конфигурация `cfg`, временные файлы. Ключевые параметры: `state_path`, `workdir`, `manager_enabled`.

Тест проверяет, что агент корректно обрабатывает ограничение по максимальному количеству итераций, возвращая частичный результат. Используется фиктивная конфигурация `AppConfig` с временной директорией и моком реестра инструментов `_FakeToolRegistry`, который всегда возвращает успешный непустой результат. Метод `_call_openai` заменяется заглушкой, принудительно генерирующей вызов инструмента на каждом шаге, чтобы гарантировать достижение лимита итераций. В результате ожидается статус `partial`, а в выводе — сообщение о превышении лимита и упоминание последних вызовов инструментов. Основная цель — убедиться, что агент не завершается с ошибкой, а возвращает промежуточные результаты при достижении порога итераций.

Тест-функция, проверяющая поведение метода `_interrupt_before_close` в приложении бота. Назначение — убедиться, что прерывание одной сессии не влияет на другие активные сессии. Создаёт экземпляр `BotApp` с временной конфигурацией, запускает два асинхронных задачи-заглушки, ассоциированных с разными сессиями. Методом `_interrupt_before_close` прерывается только первая сессия, после чего проверяется, что соответствующая задача отменена, а вторая задача остаётся активной. Используются временные пути (`tmp_path`) для изоляции теста. В конце выполняется корректная очистка задач через `cancel()` и подавление исключений при завершении.

Тест проверяет корректность работы функции `execute_shell_command` из модуля `agent.tooling.helpers` при выполнении команды без вывода. Имитирует выполнение команды с помощью `subprocess.run`, возвращая заглушку с кодом возврата 1 и пустым выводом. Проверяет, что результат содержит информацию об ошибке, включая отсутствие вывода, упоминание команды (`command=`) и рабочей директории (`cwd=`), а также корректный код возврата в метаданных. Использует `monkeypatch` для подмены `subprocess.run` и `asyncio.run` для запуска асинхронной функции.

Тест проверяет, что при отправке большого объёма вывода (`output`) метод `send_output` передаёт в функцию суммаризации только последние 50 000 символов (хвост). Используется фиктивная реализация суммаризации и заглушки для отправки сообщений в Telegram, чтобы избежать реальных сетевых вызовов и операций ввода-вывода. Настройка `summary_max_chars=200` в `DefaultsConfig` игнорируется, так как логика теста сосредоточена на ограничении в 50 000 символов для передачи в `summarize_text_with_reason`. Тест подтверждает корректность обрезки вывода по хвосту при превышении размера.

Тест проверяет, что бот отправляет текстовый превью вывода, даже если генерация HTML-версии задерживается. Используется временная директория и моки для изоляции. Конфигурация `AppConfig` инициализируется с минимальными настройками, включая dummy-инструмент и отключённый MCP. Основное поведение тестируется при вызове `send_output` с `force_html=True`. Моки имитируют быстрое создание HTML-файла, но блокируют выполнение `ansi_to_html` через `asyncio.Event`. Установлены нулевые таймауты для `_SUMMARY_WAIT_FOR_HTML_S` и `_SUMMARY_TIMEOUT_S`, чтобы превью отправлялось немедленно. События отправки сообщений фиксируются в список `events`. Проверяется, что сообщение (превью) было отправлено до завершения генерации HTML. Задача отменяется для корректного завершения.

Файл содержит тестовую функцию `test_send_message_retries_and_records`, проверяющую поведение метода `send_message` класса `TelegramIO`. Тест убеждается, что при временных сетевых ошибках (`NetworkError`) происходит повторная попытка отправки сообщения, и после успешной отправки вызывается функция записи идентификатора сообщения.

Ключевые сущности:
- `TelegramIO` — класс, инкапсулирующий взаимодействие с Telegram API.
- `record_message` — колбэк, вызываемый для сохранения соответствия `chat_id` и `message_id`.
- `_Bot` — мок бота, имитирующий `send_message` с выбросом `NetworkError` первые два раза.
- `asyncio.sleep` заменяется на заглушку `_fast_sleep`, чтобы ускорить повторные попытки.

Важные настройки:
- Повторные попытки отправки сообщения при `NetworkError`.
- Колбэк `record_message` фиксирует успешную отправку.
- Используется `monkeypatch` для изоляции теста и контроля поведения `asyncio.sleep`.

Тест проверяет:
- Метод `send_message` вызывается ровно 3 раза (2 неудачи, 1 успех).
- После успеха возвращается объект сообщения с `message_id = 123`.
- Колбэк `record_message` корректно вызывается с аргументами `(777, 123)`.

Файл содержит юнит-тесты для функций `format_manager_status` и `needs_resume_choice` из модуля управления агентом.  

**Назначение**:  
Проверка корректности форматирования статуса менеджера проекта с отображением эмодзи, зависимостей и комментариев к задачам, а также логики определения необходимости подтверждения возобновления работы.

**Ключевые сущности**:  
- `ProjectPlan` — описание плана проекта с задачами.  
- `DevTask` — задача разработки с полями: статус, зависимости, попытки выполнения, комментарии ревью.  
- `format_manager_status` — формирует читаемое представление статуса плана (с эмодзи ✅/❌, зависимостями, комментариями).  
- `needs_resume_choice` — определяет, требуется ли пользовательское подтверждение для возобновления работы (в зависимости от флага `auto_resume` и содержания ввода `user_text`).

**Важные настройки/параметры**:  
- `max_comment_chars` — ограничение длины отображаемых комментариев (в тесте используется 1000).  
- `auto_resume` — флаг автоматического возобновления без подтверждения.  
- `user_text` — ввод пользователя, влияющий на решение о возобновлении (игнорируется при `auto_resume=True`, проверяется на пустоту).

Тестовый файл, проверяющий логику перепланирования оркестратора после выполнения каждого шага. Основная цель — убедиться, что при динамическом расширении плана (например, добавлении новых шагов) оркестратор корректно отслеживает выполненные шаги и не выполняет их повторно, несмотря на перепланирование.  

Используются фиктивные реализации `plan_steps` и `_execute_step` для моделирования поведения: план изначально содержит два шага, затем расширяется до трёх. Проверяется, что:
- Все шаги выполнены ровно один раз.
- Общее количество вызовов планирования — три (начальный план + после каждого из двух первых шагов).
- Результат выполнения включает ожидаемые выходные данные по каждому шагу.

Ключевые сущности: `OrchestratorRunner`, `PlanStep`, `ExecutorResponse`.  
Настройки конфигурации инициализируются с временными путями для изоляции теста. Используется `monkeypatch` для подмены асинхронных вызовов.

Тест проверяет, что состояние (state) корректно изолируется по идентификатору сессии. Используется временный файл `state.json`, в котором определены две сессии — `s1` и `s2` — с общими значениями `tool` и `workdir`, но разными `resume_token`, `summary`, `updated_at` и `name`. Функция `load_state` загружает данные и проверяет наличие обоих сеансов. Функция `get_state` извлекает состояние по пути, инструменту, рабочей директории и идентификатору сессии. При указании `session_id="s1"` возвращается соответствующее состояние с `resume_token == "r1"`. При отсутствии `session_id` и совпадении `tool` и `workdir` у нескольких сессий возвращается `None`, чтобы избежать неоднозначности. Тест подтверждает, что состояние изолировано и разрешается однозначно только при явном указании идентификатора сессии.

Тест проверяет корректность отправки вывода в Telegram с учётом параллельной обработки HTML и аннотаций. Настраивается тестовое окружение с временной директорией и моками для `_send_message`, `_send_document`, `summarize_text_with_reason`, `ansi_to_html`, `make_html_file` и `asyncio.to_thread`. Цель — убедиться, что при отправке большого объёма вывода (5000 символов) срабатывает логика параллельной генерации HTML-представления и краткого резюме. Проверяется порядок событий: сначала сообщение с заголовком, затем документ (HTML-файл), затем сообщение с резюме. Используются `asyncio.Event` для синхронизации между задачами и принудительного контроля очерёдности выполнения. Убеждается, что HTML-генерация не блокирует отправку резюме, и обе задачи выполняются конкурентно.

Тест-файл для проверки функции `_try_parse_review` класса `ManagerOrchestrator`. Проверяет корректность разбора текстового ответа, содержащего JSON с результатами ревью кода. Основные проверяемые сценарии: валидные JSON-ответы с флагами `approved: true/false`, извлечение данных из JSON, обёрнутого в Markdown-разметку (```` ```json ````), обработка текста с дополнительным содержимым вокруг JSON, а также случаи с отсутствующими обязательными полями (например, `approved`) или некорректным форматом. Обязательным полем для успешного разбора является `approved`, остальные поля (например, `summary`, `comments`, `files_reviewed`, `tests_passed`) могут отсутствовать или иметь значение `null`. В случае ошибки парсинга или отсутствия ключевых полей возвращается `None`.
