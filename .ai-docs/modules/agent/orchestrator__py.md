# agent/orchestrator

```markdown
Основной модуль оркестратора, управляющий планированием, выполнением шагов и взаимодействием с пользователем. Интегрирует планировщик, исполнитель и диспетчер для обработки пользовательского запроса в рамках сессии. Поддерживает повторное планирование на основе уточнений, управление контекстом и историей выполнения. Управляет порядком выполнения шагов с учётом зависимостей, параллелизма и статусов завершения. Обеспечивает интеграцию с исполнителем (executor) для запуска шагов, обработку блокировок и зависимостей, а также взаимодействие с пользователем. Поддерживает устойчивость к циклическим зависимостям и корректное завершение при ошибках. Также отвечает за управление памятью агента, включая принятие решений о сохранении информации, компрессию при превышении лимитов и обеспечение устойчивости к нехватке места. Основная логика сосредоточена на асинхронном анализе релевантности контента и его последующей оптимизации. Используются внешние функции для чтения, записи и сжатия памяти на основе конфигурации.

Ключевые структуры данных
PlanStep — описание шага плана с зависимостями, инструкцией и метаданными выполнения
ExecutorRequest — запрос на выполнение шага, передаваемый исполнителю
ExecutorResponse — ответ от исполнителя с результатом выполнения шага
Memory — структура, содержащая текстовое представление памяти агента с тегированной разметкой

class OrchestratorRunner
Основной класс управления выполнением задач: планирование, исполнение шагов, обработка уточнений. Интегрирует планировщик, исполнитель и диспетчер, управляет контекстом и историей сессии.
Поля
_config — Конфигурация приложения.
_executor — Экземпляр исполнителя инструментов.
_dispatcher — Экземпляр диспетчера для взаимодействия с пользователем.
_log — Логгер для записи событий выполнения.
Методы
__init__(config: AppConfig) — Инициализирует оркестратор с конфигурацией.
_load_session(cwd: str) -> Dict[str, Any] — Загружает данные сессии из файла с блокировкой.
_build_orchestrator_context(session_data: Dict[str, Any], task_key: str) -> str — Формирует контекст на основе истории оркестратора.
run(session: Any, user_text: str, bot: Any, context: Any, dest: Dict[str, Any]) -> str — Основной метод запуска оркестрации.
_order_steps_safely(steps: List[PlanStep]) -> List[PlanStep] — Упорядочивает шаги с учётом зависимостей.
_next_batch(steps: List[PlanStep], completed_ok: set[str], completed_fail: set[str], session_id: str) -> tuple[List[PlanStep], List[ExecutorResponse]] — Определяет следующую группу шагов для выполнения.
_execute_step(step: PlanStep, session: Any, bot: Any, context: Any, dest: Dict[str, Any], ctx_summary: str) -> ExecutorResponse — Выполняет один шаг плана.
_apply_step_result(step: PlanStep, resp: ExecutorResponse, completed_ok: set[str], completed_fail: set[str]) — Обновляет статусы выполнения на основе результата шага.

---
_order_steps_safely(steps: List[PlanStep]) -> List[PlanStep]
Упорядочивает шаги плана, очищая зависимости от некорректных ссылок.
Аргументы
steps — список шагов плана, которые необходимо проверить и нормализовать
Возвращает
Список шагов с корректными и безопасными зависимостями

---
_is_success_status(status: str) -> bool
Проверяет, является ли статус успешным («ok» или «partial»).
Аргументы
status — строка, представляющая статус выполнения шага
Возвращает
True, если статус считается успешным, иначе False

---
_apply_step_result(step: PlanStep, resp: ExecutorResponse, completed_ok: set[str], completed_fail: set[str]) -> None
Обновляет множества успешно и неуспешно завершённых шагов на основе результата выполнения.
Аргументы
step — шаг плана, для которого обновляется статус
resp — ответ от исполнителя с результатом выполнения
completed_ok — множество идентификаторов успешно завершённых шагов
completed_fail — множество идентификаторов шагов, завершённых с ошибкой

---
_next_batch(steps: List[PlanStep], completed_ok: set[str], completed_fail: set[str], session_id: str) -> tuple[List[PlanStep], List[ExecutorResponse]]
Определяет следующую группу шагов, готовых к выполнению, с учётом зависимостей и статусов.
Аргументы
steps — полный список шагов плана
completed_ok — множество идентификаторов успешно завершённых шагов
completed_fail — множество идентификаторов шагов, завершённых с ошибкой
session_id — идентификатор сессии, используется для формирования corr_id
Возвращает
Кортеж из списка готовых к выполнению шагов и списка ответов для пропущенных (заблокированных) шагов

---
_execute_step(step: PlanStep, session: Any, bot: Any, context: Any, dest: Dict[str, Any], orchestrator_context: str) -> ExecutorResponse
Асинхронно выполняет один шаг плана, отправляя запрос исполнителю и возвращая результат.
Аргументы
step — шаг плана для выполнения
session — объект сессии, передаваемый исполнителю
bot — объект бота, используемый для взаимодействия
context — контекст выполнения, передаваемый исполнителю
dest — словарь назначения для результатов
orchestrator_context — дополнительный контекст оркестратора, передаваемый агенту
Возвращает
Ответ исполнителя с результатом выполнения шага
Исключения
Может выбрасывать исключения, возникающие при взаимодействии с исполнителем

---
record_message(chat_id: int, message_id: int) -> None
Фиксирует отправленное сообщение в исполнителе для последующего отслеживания.
Аргументы
chat_id — идентификатор чата
message_id — идентификатор отправленного сообщения

---
resolve_question(question_id: str, answer: str) -> bool
Передаёт ответ пользователя на ожидающий вопрос в исполнитель.
Аргументы
question_id — идентификатор вопроса, на который поступил ответ
answer — текст ответа пользователя
Возвращает
True, если вопрос был найден и обработан, иначе False

---
clear_session_cache(session_id: str) -> None
Очищает кэш сессии в исполнителе.
Аргументы
session_id — идентификатор сессии, кэш которой следует очистить

---
get_plugin_commands(profile: Any) -> Dict[str, Any]
Возвращает команды плагинов, доступные для указанного профиля.
Аргументы
profile — объект профиля, для которого запрашиваются команды
Возвращает
Словарь команд плагинов, сгруппированных по категориям

---
get_plugin_ui(profile: Any) -> Dict[str, Any]
Возвращает UI-конфигурации плагинов для указанного профиля.
Аргументы
profile — объект профиля, для которого запрашивается UI
Возвращает
Словарь UI-описаний плагинов, используемых в интерфейсе

---
async def _maybe_update_memory(user_text: str, final_response: str, memory_text: str, cwd: str) -> None
Асинхронно решает, нужно ли обновить память, и при необходимости сохраняет и сжимает её
Аргументы
user_text — ввод пользователя, на основе которого принимается решение о сохранении
final_response — финальный ответ агента, анализируемый на релевантность
memory_text — текущее содержимое памяти для сравнения и компрессии
cwd — рабочая директория, где хранится файл памяти
Исключения
IOError — при ошибках чтения/записи файлов памяти
RuntimeError — если сжатие памяти завершилось неудачей при обязательной очистке

---
def append_memory_tagged(cwd: str, tag: str, content: str) -> None
Добавляет в память новый блок с указанным тегом и содержимым
Аргументы
cwd — путь к рабочей директории с файлом памяти
tag — тег, определяющий категорию сохраняемой информации
content — содержимое, которое будет добавлено в память

---
def read_memory(cwd: str) -> str
Считывает текущее содержимое памяти из файловой системы
Аргументы
cwd — путь к директории, где расположен файл памяти
Возвращает
Текстовое содержимое памяти, включая все тегированные блоки

---
def write_memory(cwd: str, content: str) -> None
Записывает обновлённое содержимое памяти в файл
Аргументы
cwd — путь к рабочей директории
content — новое содержимое памяти, которое будет сохранено

---
def memory_size_bytes(memory: str) -> int
Вычисляет размер памяти в байтах
Аргументы
memory — строка с содержимым памяти
Возвращает
Размер строки в байтах в кодировке UTF-8

---
async def compress_memory(config: Config, memory: str, target_chars: int) -> Optional[str]
Асинхронно сжимает память с использованием LLM до заданного объёма
Аргументы
config — конфигурация агента, включая параметры модели
memory — текущее содержимое памяти
target_chars — целевое количество символов после сжатия
Возвращает
Сжатое содержимое памяти или None, если сжатие не удалось

---
def compact_memory_by_priority(memory: str, max_bytes: int, priority_tags: List[str]) -> str
Жадно усекает память по приоритетам тегов, если LLM-сжатие недоступно
Аргументы
memory — исходное содержимое памяти
max_bytes — максимально допустимый размер в байтах
priority_tags — список тегов в порядке убывания приоритета сохранения
Возвращает
Сжатое содержимое памяти, укладывающееся в лимит байт
```
