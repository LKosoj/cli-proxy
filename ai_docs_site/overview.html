<!DOCTYPE html>

<html data-bs-theme="light" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="img/favicon.ico" rel="shortcut icon"/>
<title>Обзор проекта - cli-proxy</title>
<link href="css/bootstrap.min.css" rel="stylesheet"/>
<link href="css/fontawesome.min.css" rel="stylesheet"/>
<link href="css/brands.min.css" rel="stylesheet"/>
<link href="css/solid.min.css" rel="stylesheet"/>
<link href="css/v4-font-face.min.css" rel="stylesheet"/>
<link href="css/base.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" id="hljs-light" rel="stylesheet"/>
<link disabled="" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" id="hljs-dark" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body>
<div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
<div class="container">
<a class="navbar-brand" href="index.html">cli-proxy</a>
<!-- Expander button -->
<button aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-bs-target="#navbar-collapse" data-bs-toggle="collapse" type="button">
<span class="navbar-toggler-icon"></span>
</button>
<!-- Expanded navigation -->
<div class="navbar-collapse collapse" id="navbar-collapse">
<!-- Main navigation -->
<ul class="nav navbar-nav">
<li class="nav-item">
<a class="nav-link" href="index.html">Главная</a>
</li>
<li class="nav-item dropdown">
<a aria-current="page" aria-expanded="false" class="nav-link dropdown-toggle active" data-bs-toggle="dropdown" href="#" role="button">Обзор</a>
<ul class="dropdown-menu">
<li>
<a aria-current="page" class="dropdown-item active" href="overview.html">Обзор проекта</a>
</li>
</ul>
</li>
<li class="nav-item">
<a class="nav-link" href="architecture.html">Архитектура</a>
</li>
<li class="nav-item">
<a class="nav-link" href="runtime.html">Запуск</a>
</li>
<li class="nav-item">
<a class="nav-link" href="dependencies.html">Зависимости</a>
</li>
<li class="nav-item">
<a class="nav-link" href="testing.html">Тестирование</a>
</li>
<li class="nav-item">
<a class="nav-link" href="conventions.html">Соглашения</a>
</li>
<li class="nav-item">
<a class="nav-link" href="glossary.html">Глоссарий</a>
</li>
<li class="nav-item dropdown">
<a aria-expanded="false" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#" role="button">Конфигурация проекта</a>
<ul class="dropdown-menu">
<li>
<a class="dropdown-item" href="configs/index.html">Обзор</a>
</li>
<li class="dropdown-submenu">
<a class="dropdown-item" href="#">/agent</a>
<ul class="dropdown-menu">
<li class="dropdown-submenu">
<a class="dropdown-item" href="#">/approvals</a>
<ul class="dropdown-menu">
<li>
<a class="dropdown-item" href="configs/files/agent/approvals/blocked-patterns__json.html">blocked-patterns.json</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a class="dropdown-item" href="configs/files/config_example__yaml.html">config_example.yaml</a>
</li>
<li>
<a class="dropdown-item" href="configs/files/toolhelp__json.html">toolhelp.json</a>
</li>
</ul>
</li>
<li class="nav-item dropdown">
<a aria-expanded="false" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#" role="button">Модули</a>
<ul class="dropdown-menu">
<li>
<a class="dropdown-item" href="modules/index.html">Обзор</a>
</li>
<li class="dropdown-submenu">
<a class="dropdown-item" href="#">/agent</a>
<ul class="dropdown-menu">
<li class="dropdown-submenu">
<a class="dropdown-item" href="#">/mcp</a>
<ul class="dropdown-menu">
<li>
<a class="dropdown-item" href="modules/agent/mcp/__init____py.html">__init__.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/mcp/http_client__py.html">http_client.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/mcp/jsonrpc__py.html">jsonrpc.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/mcp/manager__py.html">manager.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/mcp/stdio_client__py.html">stdio_client.py</a>
</li>
</ul>
</li>
<li class="dropdown-submenu">
<a class="dropdown-item" href="#">/plugins</a>
<ul class="dropdown-menu">
<li>
<a class="dropdown-item" href="modules/agent/plugins/__init____py.html">__init__.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/ask_user__py.html">ask_user.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/auto_tts__py.html">auto_tts.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/base__py.html">base.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/chief__py.html">chief.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/codeinterpreter__py.html">codeinterpreter.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/ddg_image_search__py.html">ddg_image_search.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/delete_file__py.html">delete_file.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/edit_file__py.html">edit_file.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/fetch_page__py.html">fetch_page.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/github_analysis__py.html">github_analysis.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/gtts_text_to_speech__py.html">gtts_text_to_speech.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/haiper_image_to_video__py.html">haiper_image_to_video.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/list_directory__py.html">list_directory.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/manage_message__py.html">manage_message.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/manage_tasks__py.html">manage_tasks.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/memory__py.html">memory.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/movie_info__py.html">movie_info.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/prompt_perfect__py.html">prompt_perfect.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/read_file__py.html">read_file.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/reminders__py.html">reminders.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/run_command__py.html">run_command.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/schedule_task__py.html">schedule_task.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/search_files__py.html">search_files.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/search_text__py.html">search_text.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/search_web__py.html">search_web.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/send_file__py.html">send_file.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/show_me_diagrams__py.html">show_me_diagrams.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/stable_diffusion__py.html">stable_diffusion.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/task_management__py.html">task_management.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/text_document_qa__py.html">text_document_qa.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/use_cli__py.html">use_cli.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/web_research__py.html">web_research.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/website_content__py.html">website_content.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/wolfram_alpha__py.html">wolfram_alpha.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/write_file__py.html">write_file.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/plugins/youtube_transcript__py.html">youtube_transcript.py</a>
</li>
</ul>
</li>
<li class="dropdown-submenu">
<a class="dropdown-item" href="#">/tooling</a>
<ul class="dropdown-menu">
<li>
<a class="dropdown-item" href="modules/agent/tooling/__init____py.html">__init__.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/tooling/constants__py.html">constants.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/tooling/helpers__py.html">helpers.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/tooling/loader__py.html">loader.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/tooling/mcp_plugin__py.html">mcp_plugin.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/tooling/registry__py.html">registry.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/tooling/spec__py.html">spec.py</a>
</li>
</ul>
</li>
<li>
<a class="dropdown-item" href="modules/agent/__init____py.html">__init__.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/agent_core__py.html">agent_core.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/contracts__py.html">contracts.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/dispatcher__py.html">dispatcher.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/executor__py.html">executor.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/heuristics__py.html">heuristics.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/manager__py.html">manager.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/manager_prompts__py.html">manager_prompts.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/manager_store__py.html">manager_store.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/memory_policy__py.html">memory_policy.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/memory_store__py.html">memory_store.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/openai_client__py.html">openai_client.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/orchestrator__py.html">orchestrator.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/planner__py.html">planner.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/profiles__py.html">profiles.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/agent/session_store__py.html">session_store.py</a>
</li>
</ul>
</li>
<li>
<a class="dropdown-item" href="modules/bot__py.html">bot.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/bot_logging__py.html">bot_logging.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/command_registry__py.html">command_registry.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/config__py.html">config.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/dirs_ui__py.html">dirs_ui.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/dotenv_loader__py.html">dotenv_loader.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/git_ops__py.html">git_ops.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/mcp_bridge__py.html">mcp_bridge.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/metrics__py.html">metrics.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/session__py.html">session.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/session_ui__py.html">session_ui.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/state__py.html">state.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/summary__py.html">summary.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/telegram_io__py.html">telegram_io.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/tg_markdown__py.html">tg_markdown.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/toolhelp__py.html">toolhelp.py</a>
</li>
<li>
<a class="dropdown-item" href="modules/utils__py.html">utils.py</a>
</li>
</ul>
</li>
<li class="nav-item">
<a class="nav-link" href="changes.html">Изменения</a>
</li>
</ul>
<ul class="nav navbar-nav ms-md-auto">
<li class="nav-item">
<a class="nav-link" data-bs-target="#mkdocs_search_modal" data-bs-toggle="modal" href="#">
<i class="fa fa-search"></i> Search
                            </a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html" rel="prev">
<i class="fa fa-arrow-left"></i> Previous
                                </a>
</li>
<li class="nav-item">
<a class="nav-link" href="architecture.html" rel="next">
                                    Next <i class="fa fa-arrow-right"></i>
</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container">
<div class="row">
<div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
<div class="navbar-header">
<button class="navbar-toggler collapsed" data-bs-target="#toc-collapse" data-bs-toggle="collapse" title="Table of Contents" type="button">
<span class="fa fa-angle-down"></span>
</button>
</div>
<div class="navbar-collapse collapse card bg-body-tertiary" id="toc-collapse">
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_1">Обзор проекта</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#sessionui">Класс SessionUI</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_2">Основные компоненты</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_3">Поддерживаемые действия</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_4">Форматирование и вспомогательные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_5">Сохранение и хуки</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#cli-proxy-telegram-bridge">CLI Proxy Telegram Bridge — Краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_6">Основные возможности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_7">Режимы работы</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#configyaml">Конфигурация (config.yaml)</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_9">Обработка вложений</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_10">Команды</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_11">Восстановление состояния</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#yolo">Автоодобрение (YOLO)</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#git-telegram">Git-бот в Telegram: Краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_12">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_13">Особенности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_14">Ограничения</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_15">Рекомендации</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#manager">Режим Manager: Краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_16">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_17">Ключевые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_18">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_19">Персистентность и восстановление</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_20">Интеграция и управление</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#configyaml_1">Настройки (config.yaml)</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#v1">Ограничения (v1)</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#v2">Планы на v2</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_21">Обработка ошибок</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_22">Тестирование</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#yaml">Конфигурационный файл (YAML)</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_23">Основные секции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_24">Особенности</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#telegram-">Telegram-бот для управления агентом: Краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_25">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_26">Ключевые компоненты</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_27">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_28">Конфигурация и настройки</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_29">Обработка вывода и логирование</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_30">Особенности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_31">Команды</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_32">Запуск</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_33">Безопасность</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#openai">Асинхронный модуль генерации резюме и сообщений коммитов с OpenAI</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_34">Ключевые возможности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_35">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_36">Настройки</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_37">Обработка ошибок и отказоустойчивость</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_38">Требования</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#gitops-git-telegram-">Класс GitOps — Работа с Git в Telegram-боте</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_39">Основные возможности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_40">Ключевые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_41">Основные методы</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_42">Обработка событий</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_43">Безопасность и настройки</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_44">Зависимости</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#ansi-markdown-mermaid">Резюме: Утилиты обработки текста с ANSI, Markdown и Mermaid</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_45">Основные возможности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_46">Вспомогательные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_47">Зависимости и особенности</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_48">Управление сессиями выполнения инструментов</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_49">Основные сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_50">Ключевые параметры</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_51">Особенности реализации</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_52">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_53">Резюме: Политика безопасности и ограничений</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_54">Резюме документации</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_55">Основные компоненты</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_56">Ключевые настройки</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_57">Статус ревью</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#react">ReAct Агент — Краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_58">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_59">Ключевые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_60">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_61">Конфигурация и настройки</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_62">Особенности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_63">Назначение файлов</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_64">Оркестратор выполнения пользовательских задач — Краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_65">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_66">Ключевые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_67">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_68">Настройки и ограничения</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_69">Особенности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_70">Завершение работы</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#manager-orchestrator">Модуль управления проектом (Manager Orchestrator)</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_71">Ключевые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_72">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_73">Логика работы</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_74">Настройки</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_75">Вспомогательные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_76">Особенности</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_77">Конфигурация фильтрации команд — краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_78">Основные категории угроз</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_79">Ключевые параметры правил</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_80">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_81">Резюме: Назначение и функциональность файла</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_82">Ключевые функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_83">Настройки безопасности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_84">Интеграции и провайдеры</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_85">Формат вывода</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_86">Дополнительно</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_87">Краткое резюме</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#toolregistry">ToolRegistry — Реестр инструментов и менеджер плагинов</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_88">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_89">Состояние и сервисы</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_90">Важные компоненты</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_91">Настройки и поведение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_92">Утилиты</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_93">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#telegram-_1">Резюме: Система диалогов и инструментов для Telegram-бота</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_94">Основные компоненты</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_95">Диалоговые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_96">Обработка событий</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_97">Конфигурация и расширение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_98">Особенности</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#textdocumentqatool">TextDocumentQATool — Документация</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_99">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_100">Основные функции</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_101">Хранение данных</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_102">Диалоговый интерфейс</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#llm">Интеграция с LLM</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_103">Ответы</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_104">Интерфейс</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_105">Ограничения</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_106">Зависимости</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_107">Резюме: Плагинная система с поддержкой диалогов</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_108">Основные методы и контракт</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#dialogmixin">Диалоги и интерактивность (DialogMixin)</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#callback-">Callback-система</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_111">Меню и команды</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_112">Обработка ввода</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_113">Жизненный цикл и интеграция</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_114">Регистрация плагинов</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_115">Рекомендации</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_116">Пример функциональности</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#taskmanagementtool-telegram-">TaskManagementTool — Управление задачами в Telegram-боте</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_117">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_118">Ключевые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_119">Функциональность</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_notifypolicy">Настройки уведомлений (_NotifyPolicy)</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_120">Технические особенности</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#haiper-image-to-video-tool">Haiper Image-to-Video Tool — Краткое резюме</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#_121">Краткое резюме</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#reminderstool-telegram-">RemindersTool — Управление напоминаниями в Telegram-боте</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_122">Назначение</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_123">Основные возможности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_124">Ключевые сущности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#execute">Поддерживаемые действия (execute)</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_125">Ограничения</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_126">Технические особенности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_127">Интеграция</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#webresearchtool">WebResearchTool — Краткое резюме</a>
<ul class="nav flex-column">
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_128">Основные возможности</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_129">Ключевые методы</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_130">Настройки</a>
<ul class="nav flex-column">
</ul>
</li>
<li class="nav-item" data-bs-level="2"><a class="nav-link" href="#_131">Результат</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</li>
<li class="nav-item" data-bs-level="1"><a class="nav-link" href="#orchestratorrunner">Резюме документации: Тестирование модуля OrchestratorRunner</a>
<ul class="nav flex-column">
</ul>
</li>
</ul>
</div>
</div></div>
<div class="col-md-9" role="main">
<h1 id="_1">Обзор проекта</h1>
<h1 id="sessionui">Класс <code>SessionUI</code></h1>
<p>Класс <code>SessionUI</code> обеспечивает пользовательский интерфейс для управления сессиями через Telegram-бота. Предоставляет функциональность отображения списка сессий, навигации по меню и обработки команд, включая ввод данных от пользователя (например, переименование сессии, установка resume-токена). Взаимодействие осуществляется через callback-кнопки, поддерживается режим ожидания ввода с сохранением контекста.</p>
<h2 id="_2">Основные компоненты</h2>
<ul>
<li><strong><code>manager</code></strong> — менеджер сессий, отвечающий за доступ, активацию и управление сессиями.</li>
<li><strong><code>pending_session_rename</code></strong>, <strong><code>pending_session_resume</code></strong> — словари, отслеживающие пользователей, ожидающих ввода (имя сессии или resume-токен).</li>
<li><strong><code>build_sessions_menu()</code></strong> — формирует клавиатуру со списком сессий.</li>
<li><strong><code>handle_pending_message()</code></strong> — обрабатывает текстовые сообщения от пользователей в режиме ожидания.</li>
<li><strong><code>handle_callback()</code></strong> — обрабатывает действия в меню (выбор, активация, статус и др.).</li>
</ul>
<h2 id="_3">Поддерживаемые действия</h2>
<ul>
<li><code>sess_pick</code> — выбор сессии и отображение детального меню.</li>
<li><code>sess_use</code> — активация сессии.</li>
<li><code>sess_status</code> — показ состояния сессии (занятость, время работы, очередь и т.д.).</li>
<li><code>sess_rename</code> — переход в режим ввода нового имени.</li>
<li><code>sess_resume</code> — установка resume-токена (с ожиданием ввода).</li>
<li><code>sess_clearqueue</code> — очистка очереди сообщений.</li>
<li><code>sess_state</code> — просмотр текущего состояния сессии.</li>
<li><code>sess_close</code> — закрытие сессии.</li>
<li><code>sess_close_menu</code> — закрытие интерфейса меню.</li>
</ul>
<h2 id="_4">Форматирование и вспомогательные функции</h2>
<ul>
<li><code>send_message</code> — отправка сообщений через бота.</li>
<li><code>format_ts</code>, <code>short_label</code> — утилиты для форматирования временных меток и обрезки текста.</li>
<li>Информация о сессии выводится в структурированном виде: идентификатор, инструмент, рабочий каталог, токен, время обновления и др.</li>
</ul>
<h2 id="_5">Сохранение и хуки</h2>
<ul>
<li>Изменения сохраняются через <code>manager._persist_sessions()</code>.</li>
<li>Поддерживаются хуки: <code>on_before_close</code> (до закрытия) и <code>on_close</code> (после закрытия) — для интеграции внешней логики.</li>
</ul>
<p>Класс обеспечивает полный цикл управления сессиями с проверкой существования, обратной связью и безопасным взаимодействием через Telegram.</p>
<h1 id="cli-proxy-telegram-bridge">CLI Proxy Telegram Bridge — Краткое резюме</h1>
<p><strong>CLI Proxy Telegram Bridge</strong> — это Telegram-бот для управления CLI-агентами (Codex, Gemini, Qwen, Claude и др.) через удобный интерфейс. Превращает CLI-инструменты в масштабируемые, визуально контролируемые процессы с поддержкой многопользовательской работы, очередей команд и интеграции с Git и ИИ-агентами.</p>
<h2 id="_6">Основные возможности</h2>
<ul>
<li><strong>Многопользовательские сессии</strong>: изолированные контексты выполнения в разных каталогах, состояние сохраняется в <code>state.json</code>.</li>
<li><strong>Очередь команд</strong>: управление параллельными задачами, предотвращение конфликтов.</li>
<li><strong>HTML-вывод</strong>: отображение результатов с поддержкой Markdown, ANSI-цветов и mermaid-диаграмм (в SVG); ошибки — как код.</li>
<li><strong>Кэширование справки</strong>: <code>toolhelp.json</code> ускоряет доступ к help-информации инструментов.</li>
<li><strong>Git-интеграция</strong>: inline-меню с операциями (status, commit, push, merge, rebase, diff), обработка конфликтов.</li>
<li><strong>Файловый доступ</strong>: просмотр и отправка файлов через <code>/files</code>.</li>
<li><strong>Шаблоны задач</strong>: скрытая команда <code>/preset</code> для запуска типовых сценариев.</li>
</ul>
<h2 id="_7">Режимы работы</h2>
<ul>
<li><strong>Agent</strong>: ReAct-агент с доступом к инструментам.</li>
<li><strong>Manager</strong>: мультиагентная оркестрация с декомпозицией задач, автоматическим ревью и автокоммитом (<code>manager_auto_commit</code>).<blockquote>
<p>Режимы не могут быть активны одновременно.</p>
</blockquote>
</li>
</ul>
<h2 id="configyaml">Конфигурация (<code>config.yaml</code>)</h2>
<p>Основной файл настройки. Поддерживает <code>${VAR}</code>-подстановки и приоритет переменных окружения.</p>
<h3 id="_8">Ключевые параметры:</h3>
<ul>
<li><code>telegram.token</code>, <code>whitelist_chat_ids</code> — безопасность и доступ.</li>
<li><code>defaults.workdir</code>, <code>log_path</code>, <code>image_temp_dir</code> — пути и логирование (с ротацией).</li>
<li><code>tools.*</code> — настройка CLI-инструментов: команды, prompt, resume, help, <code>image_cmd</code>, переменные окружения (<code>env</code>).</li>
<li><code>openai_api_key</code>, <code>zai_api_key</code>, <code>tavily_api_key</code>, <code>jina_api_key</code>, <code>github_token</code> — ключи API.</li>
<li><code>presets</code> — шаблоны задач.</li>
<li><code>mcp.*</code> — TCP-мост для внешних клиентов.</li>
<li><code>manager_*</code> — лимиты, таймауты, debug-логи (<code>.manager/</code>), автовозобновление, автокоммит.</li>
</ul>
<h2 id="_9">Обработка вложений</h2>
<ul>
<li><strong>Текстовые файлы</strong> (до 500 КБ): объединяются с подписью и передаются в CLI.</li>
<li><strong>Изображения</strong>: обрабатываются при наличии <code>image_cmd</code>, текст берётся из подписи.</li>
</ul>
<h2 id="_10">Команды</h2>
<ul>
<li><strong>Видимые в меню</strong>: <code>/new</code>, <code>/sessions</code>, <code>/git</code>, <code>/files</code>, <code>/agent</code>, <code>/manager</code>, <code>/tools</code>, <code>/toolhelp</code>.</li>
<li><strong>Скрытые</strong>: <code>/dirs</code>, <code>/newpath</code>, <code>/use</code>, <code>/cwd</code>, <code>/setprompt</code>, <code>/send</code>, <code>/resume</code>, <code>/close</code>, <code>/status</code>, <code>/rename</code>, <code>/state</code>, <code>/clearqueue</code>, <code>/queue</code>, <code>/preset</code>, <code>/metrics</code>.</li>
<li><strong>Прямой ввод</strong>: через <code>/send</code> или с префиксом <code>&gt;</code>.</li>
</ul>
<h2 id="_11">Восстановление состояния</h2>
<p>После перезапуска бот восстанавливает:
- Активные сессии.
- Очередь задач.
- Состояние из <code>state.json</code> и <code>toolhelp.json</code>.</p>
<h2 id="yolo">Автоодобрение (YOLO)</h2>
<p>Активируется флагами:
- Gemini: <code>--approval-mode yolo</code>
- Qwen: <code>--yolo</code>
- Claude: <code>--dangerously-skip-permissions</code>
- Codex: <code>/approvals full</code> в чате.</p>
<hr/>
<p><strong>Цель</strong>: превратить CLI-инструменты в управляемые, визуализированные и автоматизированные процессы через Telegram.</p>
<p>Файл содержит справочную информацию о доступных slash-командах в различных CLI-инструментах, связанных с ИИ-ассистентами (Codex, Claude, Gemini, Qwen). Каждая запись включает название инструмента, тип (<code>tool</code>), текстовое описание с перечнем команд и временной меткой обновления. Основное назначение — быстрое ознакомление с функционалом командной строки каждого инструмента. Ключевые сущности: <code>codex</code>, <code>claude</code>, <code>gemini</code>, <code>qwen</code>. Важные команды: <code>/help</code>, <code>/status</code>, <code>/new</code>, <code>/exit</code>, <code>/quit</code>, <code>/clear</code>, <code>/settings</code>, <code>/auth</code>, <code>/chat</code>, <code>/model</code>, <code>/mcp</code>. Для получения справки в большинстве случаев используется <code>/help</code> или <code>/?</code>.</p>
<h1 id="git-telegram">Git-бот в Telegram: Краткое резюме</h1>
<p>Git-бот предоставляет упрощённый интерфейс для работы с Git через Telegram, позволяя выполнять основные операции без знания командной строки. Бот запускает стандартные git-команды и отображает их результат.</p>
<h2 id="_12">Основные функции</h2>
<ul>
<li><strong>Просмотр состояния</strong>: <code>Status</code>, <code>Log</code>, <code>Diff</code>, <code>Summary</code></li>
<li><strong>Синхронизация</strong>: <code>Fetch</code>, <code>Pull</code> (с <code>--ff-only</code> для безопасности)</li>
<li><strong>Коммиты и отправка</strong>: <code>Commit</code>, <code>Push</code></li>
<li><strong>Управление изменениями</strong>: <code>Stash</code></li>
<li><strong>Слияние веток</strong>: <code>Merge</code>, <code>Rebase</code></li>
<li><strong>Работа с конфликтами</strong>: отображение конфликтующих файлов, кнопки <code>Abort</code>, <code>Continue</code>, <code>Позвать агента</code></li>
</ul>
<h2 id="_13">Особенности</h2>
<ul>
<li>Автоматическое определение upstream-ветки</li>
<li>Поддержка приватных репозиториев через <strong>Personal Access Token</strong></li>
<li>Токен задаётся в <code>config.yaml</code> → <code>defaults.github_token</code></li>
<li>Операции выполняются в очереди при занятой сессии</li>
</ul>
<h2 id="_14">Ограничения</h2>
<ul>
<li>Нет автоматического разрешения конфликтов (требуется ручное редактирование меток <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>)</li>
<li>Зависимость от текущего состояния репозитория</li>
<li>Отсутствие "умного" автомержа</li>
</ul>
<h2 id="_15">Рекомендации</h2>
<ul>
<li>Начинайте с команды <code>Status</code></li>
<li>Избегайте слияний без проверки состояния</li>
<li>Используйте <code>Abort</code> при неуверенности в действиях</li>
<li>Убедитесь, что репозиторий находится в корректном состоянии перед операциями</li>
</ul>
<p>Настраивает централизованное логирование с разделением по уровням и источникам. Основное назначение — инициализация трёх файлов логов: основной (INFO и выше), ошибок (ERROR и выше) и отдельный для модулей с префиксом <code>agent.*</code>. Используются ротирующиеся обработчики (<code>TimedRotatingFileHandler</code>) с ротацией в полночь по UTC и временем суток 03:00. Каждый лог-файл сохраняет только один архивный файл (<code>backupCount=1</code>), при ротации старый удаляется, новый переименовывается с суффиксом <code>.1</code>.</p>
<p>Ключевые сущности:
- Основной лог: путь задаётся через параметр <code>log_path</code>.
- Файл ошибок: формируется как <code>&lt;base&gt;_error.log</code> в той же директории.
- Файл агентов: <code>&lt;base&gt;_agent.log</code>, логирует только сообщения от логгеров с именем <code>agent</code> и его подчинённых (через <code>logging.getLogger("agent")</code>).
- Формат сообщений: для основного и ошибок — <code>%(asctime)s %(levelname)s %(message)s</code>, для агентов — с указанием имени логгера <code>[%(name)s]</code>.</p>
<p>Особенности:
- Все предыдущие обработчики корневого логгера удаляются перед настройкой.
- Логгирование необработанных исключений в основном потоке и в потоках перехватывается через замену <code>sys.excepthook</code> и <code>threading.excepthook</code>.
- Кастомные функции <code>namer</code> и <code>rotator</code> обеспечивают простую схему ротации без временных меток в имени файла, сохраняя только последнюю резервную копию.</p>
<h1 id="manager">Режим Manager: Краткое резюме</h1>
<h2 id="_16">Назначение</h2>
<p>Режим <strong>Manager</strong> предназначен для автономной оркестрации мульти-агентной разработки: автоматической декомпозиции сложной задачи пользователя на подзадачи, их последовательного выполнения, ревью и финального отчёта. Режим активируется командой <code>/manager</code> и отключает стандартный Agent-режим.</p>
<h2 id="_17">Ключевые сущности</h2>
<ul>
<li><code>ManagerOrchestrator</code> — центральный класс, управляющий полным циклом: декомпозиция, выполнение, ревью, арбитраж, отчёт.</li>
<li><code>DevTask</code> — единица работы с описанием, критериями приёмки, статусом, зависимостями и попытками.</li>
<li><code>ProjectPlan</code> — структурированный план проекта, содержащий список задач.</li>
<li><code>ReviewResult</code> — результат проверки задачи агентом-ревьюером.</li>
<li>Профили: <code>developer_profile</code> (для разработки), <code>reviewer_profile</code> (только чтение).</li>
<li>Персистентность: состояние сохраняется в <code>MANAGER_PLAN.json</code>.</li>
</ul>
<h2 id="_18">Основные функции</h2>
<ol>
<li>
<p><strong>Декомпозиция задачи</strong>:
   - Двухфазный процесс: CLI-анализ проекта → нормализация вывода в JSON через LLM.
   - Использует промпты: <code>manager_decompose_prompt</code>, <code>manager_normalize_prompt</code>.
   - При сбое — fallback-план с одной задачей.
   - Таймаут: <code>manager_decompose_timeout_sec</code> (300 с).</p>
</li>
<li>
<p><strong>Выполнение и ревью</strong>:
   - <code>_delegate_develop()</code>: запуск разработки с таймаутом (<code>manager_dev_timeout_sec</code>, 600 с), обрезка отчёта (<code>manager_dev_report_max_chars</code>, 8000).
   - <code>_delegate_review()</code>: ревью с возвратом JSON; при ошибках — нормализация через <code>REVIEW_NORMALIZE_SYSTEM</code>.
   - <code>_make_decision()</code>: LLM-арбитраж по критериям приёма (<code>manager_arbitration_prompt</code>), независимо от ревью.</p>
</li>
<li>
<p><strong>Управление состоянием</strong>:
   - Поддержка зависимостей, попыток (<code>max_attempts</code>, по умолчанию 3), статусов: <code>pending</code>, <code>in_progress</code>, <code>in_review</code>, <code>rejected</code>, <code>failed</code>, <code>blocked</code>, <code>approved</code>.
   - Автоматическая блокировка при падении зависимостей.
   - Восстановление после сбоев: перезапуск с последней активной задачи.</p>
</li>
<li>
<p><strong>Финализация</strong>:
   - <code>_compose_final_report()</code>: генерация итогового Markdown-отчёта (<code>manager_final_report_prompt</code>).
   - Авто-коммит в Git при успехе (если <code>manager_auto_commit=true</code>).</p>
</li>
</ol>
<h2 id="_19">Персистентность и восстановление</h2>
<ul>
<li>План сохраняется в <code>MANAGER_PLAN.json</code> (блокировка при доступе).</li>
<li>Функции: <code>save_plan</code>, <code>load_plan</code>, <code>archive_plan</code> (в <code>.manager_archive</code>).</li>
<li>Поддержка возобновления сессии (<code>manager_auto_resume=true</code> по умолчанию).</li>
<li>Ручной сброс: <code>/manager reset</code>.</li>
</ul>
<h2 id="_20">Интеграция и управление</h2>
<ul>
<li>Активация: <code>/manager</code>, отключение при <code>/interrupt</code> или сбое.</li>
<li>Маршрутизация через <code>bot.py</code> → <code>manager_orchestrator.run()</code>.</li>
<li>Уведомления: прогресс-бары и статусы в Telegram (<code>_notify_progress()</code>).</li>
</ul>
<h2 id="configyaml_1">Настройки (config.yaml)</h2>
<div class="highlight"><pre><span></span><code><span class="nt">manager_max_tasks</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">10</span>
<span class="nt">manager_max_attempts</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">3</span>
<span class="nt">manager_decompose_timeout_sec</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">300</span>
<span class="nt">manager_dev_timeout_sec</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">600</span>
<span class="nt">manager_review_timeout_sec</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">300</span>
<span class="nt">manager_auto_resume</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="nt">manager_auto_commit</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="nt">manager_dev_report_max_chars</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8000</span>
</code></pre></div>
<h2 id="v1">Ограничения (v1)</h2>
<ul>
<li>Последовательное выполнение (без параллелизма).</li>
<li>Нет репланирования в процессе.</li>
<li>Ревью — через встроенный LLM (без отдельной CLI-сессии).</li>
<li>Работает только в текущей CLI-сессии.</li>
</ul>
<h2 id="v2">Планы на v2</h2>
<ul>
<li>Параллельное выполнение задач.</li>
<li>Репланирование после групп задач.</li>
<li>Выделенный ревью-агент (например, Claude).</li>
<li>Интерактивное редактирование плана.</li>
<li>Многомодельное голосование при ревью.</li>
</ul>
<h2 id="_21">Обработка ошибок</h2>
<ul>
<li>CLI недоступен → попытка перезапуска → <code>failed</code>.</li>
<li>Ошибки OpenAI → fallback-декомпозиция, ревью без LLM невозможно.</li>
<li>Пустой вывод CLI → ошибка попытки.</li>
<li>Каскадные падения → блокировка зависимых задач.</li>
<li>Ввод пользователя → обработка через очередь/прерывание.</li>
</ul>
<h2 id="_22">Тестирование</h2>
<p>Покрывает: декомпозицию, выбор задачи, парсинг ревью, хранение, полный цикл (с моками <code>session.run_prompt</code>, <code>chat_completion</code> и <code>Executor.run</code>).</p>
<h1 id="yaml">Конфигурационный файл (YAML)</h1>
<p>Конфигурационный файл в формате YAML для настройки Telegram-бота с поддержкой инструментов, внешних сервисов, MCP-серверов и мультиагентного взаимодействия. Загружается через <code>load_config</code>, который автоматически подтягивает переменные окружения из <code>.env</code>-файла в той же директории. Поддерживает backward compatibility (например, <code>big_model_to_use</code> → <code>openai_big_model</code>) и сохраняет путь к файлу в итоговой структуре <code>AppConfig</code>.</p>
<h2 id="_23">Основные секции</h2>
<ul>
<li>
<p><strong><code>telegram</code></strong> (<code>TelegramConfig</code>)<br/>
  Настройки Telegram-бота: <code>token</code>, список разрешённых <code>chat_id</code>.</p>
</li>
<li>
<p><strong><code>tools</code></strong> (<code>ToolConfig</code>)<br/>
  Описание внешних инструментов: команды, режимы выполнения, регулярные выражения для определения состояний, переменные окружения, автоматические команды.</p>
</li>
<li>
<p><strong><code>defaults</code></strong> (<code>DefaultsConfig</code>)<br/>
  Глобальные настройки:  </p>
</li>
<li>Рабочая директория, таймауты, лимиты памяти и вывода  </li>
<li>Параметры API: OpenAI, Zai, Tavily, Jina, GitHub  </li>
<li>Логирование, обработка изображений, уточняющие вопросы  </li>
<li>
<p>Поведение менеджера задач</p>
</li>
<li>
<p><strong><code>mcp</code></strong> (<code>MCPConfig</code>)<br/>
  Встроенный MCP-сервер: включение, <code>host</code>, <code>port</code>, <code>token</code>.</p>
</li>
<li>
<p><strong><code>mcp_clients</code></strong> (<code>MCPClientServerConfig</code>)<br/>
  Клиенты для подключения к внешним MCP-серверам: имя, команда запуска, транспорт (<code>stdio</code>/<code>http</code>), URL, окружение, заголовки, таймауты.</p>
</li>
<li>
<p><strong><code>mcp_servers</code></strong><br/>
  Альтернативный способ указания внешних MCP-серверов: имя, URL, транспорт (по умолчанию <code>http</code>).</p>
</li>
<li>
<p><strong><code>presets</code></strong> (<code>PresetConfig</code>)<br/>
  Пресеты сценариев: имя и шаблон промпта для быстрого запуска.</p>
</li>
</ul>
<h2 id="_24">Особенности</h2>
<ul>
<li>Сохранение порядка ключей при записи.</li>
<li>Поддержка кириллицы (с экранированием при <code>allow_unicode=False</code>).</li>
<li>Используется для инициализации объекта <code>AppConfig</code>.</li>
</ul>
<p>Файл предоставляет функциональность для управления состоянием сессий и активного состояния в виде JSON-файла. Основное назначение — хранение, загрузка и обновление данных о сессиях, включая идентификатор сессии, используемый инструмент, рабочую директорию, токен возобновления, краткое описание, имя и временные метки.</p>
<p>Ключевые сущности:
- <code>SessionState</code> — дата-класс, описывающий состояние сессии: <code>session_id</code>, <code>tool</code>, <code>workdir</code>, <code>resume_token</code>, <code>summary</code>, <code>updated_at</code>, <code>name</code>.
- <code>ActiveState</code> — дата-класс для хранения активной сессии: <code>tool</code>, <code>workdir</code>, <code>updated_at</code>, <code>session_id</code>.</p>
<p>Состояние хранится в JSON-файле с двумя основными секциями:
- <code>_sessions</code> — словарь сессий, где ключ — <code>session_id</code>, значение — данные сессии (предпочтительный формат).
- <code>_active</code> — информация об активной сессии.</p>
<p>Поддерживается миграция с устаревшего формата, где сессии хранились по ключу <code>{tool}::{workdir}</code> на верхнем уровне. Такие записи обрабатываются как fallback при отсутствии данных в <code>_sessions</code>.</p>
<p>Ключевые функции:
- <code>load_state</code> / <code>save_state</code> — загрузка и сохранение состояния сессий с поддержкой нового и старого форматов.
- <code>get_state</code> — получение состояния по <code>session_id</code> или по комбинации <code>tool</code> и <code>workdir</code> (если совпадение уникально).
- <code>load_active_state</code> / <code>set_active_state</code> / <code>clear_active_state</code> — управление активной сессией.
- <code>update_state</code> — обновление состояния (устаревшее, используется только при отсутствии <code>_sessions</code>).
- <code>delete_state</code> — удаление устаревшей записи по ключу <code>tool::workdir</code>.</p>
<p>Файл обеспечивает совместимость с предыдущими версиями, предотвращает конфликты при совпадающих <code>tool</code> и <code>workdir</code>, использует потокобезопасные операции чтения/записи и корректно обрабатывает ошибки ввода-вывода.</p>
<p>Файл определяет реестр команд для бота, возвращая список словарей с описанием каждой команды. Каждая команда содержит имя (<code>name</code>), описание (<code>desc</code>), ссылку на обработчик (<code>handler</code>) и флаг <code>menu</code>, указывающий, должна ли команда отображаться в основном меню. Реестр используется для регистрации доступных команд в интерфейсе бота, обеспечивая централизованное управление функционалом. Основные сущности — это команды для управления сессиями, файлами, Git, агентами, инструментами и метриками. Команды с <code>menu=True</code> доступны через меню, остальные предназначены для прямого вызова.</p>
<p>Класс <code>Metrics</code> предназначен для сбора и отслеживания метрик работы приложения в режиме реального времени. Основные сущности — счётчики событий и временные отметки. Поддерживает инкремент счётчиков по ключу, фиксацию вывода и формирование текстового снимка состояния. Ключевые счётчики: <code>messages</code>, <code>commands</code>, <code>outputs</code>, <code>errors</code>, <code>queued</code>. При каждом вызове <code>observe_output</code> обновляется количество символов последнего вывода и временная метка. Метод <code>snapshot</code> возвращает строку с общим временем работы, значениями счётчиков и информацией о последнем выводе (время, сколько прошло, размер в символах).</p>
<p>Класс <code>MCPBridge</code> реализует асинхронный TCP-сервер для взаимодействия с ботом через текстовые JSON-запросы. Сервер ожидает подключений, принимает входящие сообщения, проверяет токен авторизации, выполняет обработку текстового запроса через <code>bot_app.run_prompt_raw</code> и возвращает результат. Поддерживает построчную передачу данных, где каждое сообщение завершается символом новой строки.</p>
<p>Ключевые сущности:<br/>
- <code>config.mcp.enabled</code> — включение/отключение сервера.<br/>
- <code>config.mcp.host</code>, <code>config.mcp.port</code> — параметры привязки сервера.<br/>
- <code>config.mcp.token</code> — опциональный токен для аутентификации.  </p>
<p>Формат запроса:<br/>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="nt">"token"</span><span class="p">:</span><span class="w"> </span><span class="s2">"токен"</span><span class="p">,</span><span class="w"> </span><span class="nt">"prompt"</span><span class="p">:</span><span class="w"> </span><span class="s2">"текст запроса"</span><span class="p">,</span><span class="w"> </span><span class="nt">"session_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"идентификатор сессии"</span><span class="p">}</span>
</code></pre></div></p>
<p>Формат ответа:<br/>
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="nt">"ok"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="nt">"output"</span><span class="p">:</span><span class="w"> </span><span class="s2">"результат"</span><span class="p">}</span><span class="w">  </span>
<span class="p">{</span><span class="nt">"ok"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nt">"error"</span><span class="p">:</span><span class="w"> </span><span class="s2">"описание ошибки"</span><span class="p">}</span>
</code></pre></div></p>
<p>Сервер корректно завершает работу при вызове <code>stop()</code>, закрывая все соединения. Ошибки обработки логируются с помощью <code>logging.exception</code>.</p>
<h1 id="telegram-">Telegram-бот для управления агентом: Краткое резюме</h1>
<h2 id="_25">Назначение</h2>
<p>Конфигурируемое Telegram-приложение для управления агентом с поддержкой сессий, песочницы, Git-операций и плагинов. Основано на <code>python-telegram-bot</code>, обеспечивает асинхронную обработку команд, файлов, диалогов и интеграцию с MCP.</p>
<h2 id="_26">Ключевые компоненты</h2>
<ul>
<li><strong><code>SessionManager</code></strong> — управление жизненным циклом сессий.</li>
<li><strong><code>OrchestratorRunner</code> / <code>ManagerOrchestrator</code></strong> — выполнение и координация задач агента и менеджера.</li>
<li><strong><code>GitOps</code></strong> — выполнение Git-операций (клонирование, коммиты).</li>
<li><strong><code>MCPBridge</code></strong> — интеграция с внешней системой MCP.</li>
<li><strong><code>SessionUI</code></strong> — интерфейс для управления сессиями через inline-кнопки.</li>
<li><strong><code>Metrics</code></strong> — сбор и учёт метрик использования.</li>
</ul>
<h2 id="_27">Основные функции</h2>
<ul>
<li>Асинхронная обработка команд, сообщений, вложений и callback-запросов.</li>
<li>Поддержка сессий с очередями, блокировками (<code>run_lock</code>) и буферизацией ввода.</li>
<li>Управление агентом и менеджером: включение, остановка, прерывание, очереди задач.</li>
<li>Интерактивное меню: выбор сессий, плагинов, состояний, навигация по файловой системе.</li>
<li>Работа с файлами: отправка, загрузка, удаление, пагинация, ограничение по размеру.</li>
<li>Поддержка Git: клонирование репозиториев, ввод сообщений коммитов.</li>
<li>Интеграция с плагинами: приоритетная обработка, фильтрация по состоянию агента.</li>
</ul>
<h2 id="_28">Конфигурация и настройки</h2>
<ul>
<li><strong><code>CONFIG_PATH</code></strong> — путь к <code>config.yaml</code>.</li>
<li><strong><code>.env</code></strong> — загрузка переменных окружения.</li>
<li><strong><code>telegram.whitelist_chat_ids</code></strong> — ограничение доступа.</li>
<li><strong><code>sandbox_root</code> / <code>AGENT_SANDBOX_ROOT</code></strong> — корневая директория песочницы.</li>
<li><strong><code>dirs_root</code></strong> — корень для пользовательских директорий.</li>
<li><strong><code>workdir</code></strong> — рабочая директория по умолчанию.</li>
<li><strong><code>image_max_mb</code>, <code>image_temp_dir</code></strong> — ограничения и хранение изображений.</li>
</ul>
<h2 id="_29">Обработка вывода и логирование</h2>
<ul>
<li><strong>ANSI → HTML</strong> — рендеринг с порогом <code>_HTML_PROCESS_THRESHOLD_CHARS</code> (100K).</li>
<li><strong>Суммаризация</strong> — при превышении <code>_SUMMARY_PREPARE_THRESHOLD_CHARS</code> (20K).</li>
<li><strong>Логи</strong>: <code>bot.log</code>, <code>bot_error.log</code>, <code>agent.log</code> с ротацией (ежедневно, 3 файла).</li>
<li><strong><code>agent_logger</code></strong> — отдельный логгер для компонентов агента.</li>
<li>Перехват исключений через <code>sys.excepthook</code> и <code>threading.excepthook</code>.</li>
</ul>
<h2 id="_30">Особенности</h2>
<ul>
<li>Поддержка MarkdownV2 с экранированием.</li>
<li>Отправка сообщений с повторами при сетевых ошибках (до 5 попыток).</li>
<li>Потокобезопасная обработка HTML и суммаризации через <code>ProcessPoolExecutor</code>.</li>
<li>Автоматическая очистка временных файлов и песочницы.</li>
<li>Интеграция с <code>config.yaml</code> и <code>.env</code>.</li>
<li>Динамическое управление inline-кнопками и пагинацией.</li>
<li>Сохранение состояния сессий через <code>manager._persist_sessions()</code>.</li>
</ul>
<h2 id="_31">Команды</h2>
<ul>
<li><code>/new</code>, <code>/use</code>, <code>/close</code>, <code>/sessions</code> — управление сессиями.</li>
<li><code>/agent</code>, <code>/manager</code> — включение/выключение компонентов.</li>
<li><code>/status</code>, <code>/state</code> — просмотр состояния.</li>
<li><code>/send</code>, <code>/cwd</code>, <code>/git</code>, <code>/files</code>, <code>/toolhelp</code> — работа с инструментами и файлами.</li>
<li><code>/queue</code>, <code>/clearqueue</code>, <code>/interrupt</code> — управление очередями и задачами.</li>
</ul>
<h2 id="_32">Запуск</h2>
<ul>
<li>Точка входа: <code>__main__</code>.</li>
<li>Инициализация: загрузка <code>.env</code>, <code>config.yaml</code>, построение приложения через <code>build_app</code>.</li>
<li>Режим: polling.</li>
<li>Обработка ошибок и пост-инициализация встроены в <code>Application</code>.</li>
</ul>
<h2 id="_33">Безопасность</h2>
<ul>
<li>Проверка путей через <code>is_within_root</code>.</li>
<li>Аутентификация по <code>whitelist_chat_ids</code>.</li>
<li>Очистка активных диалогов при смене сессии.</li>
<li>Проверка доступности инструментов через <code>shutil.which</code>.</li>
</ul>
<h1 id="openai">Асинхронный модуль генерации резюме и сообщений коммитов с OpenAI</h1>
<p>Модуль предоставляет асинхронные функции для краткого резюмирования текстов (например, логов, диалогов) и генерации сообщений коммитов с использованием OpenAI API. Основной акцент — на сохранении ключевой информации из конца текста и предсказуемом выводе.</p>
<h2 id="_34">Ключевые возможности</h2>
<ul>
<li><strong>Асинхронная обработка</strong> с использованием <code>AsyncOpenAI</code>.</li>
<li><strong>Кэширование клиентов</strong> по парам <code>(api_key, base_url)</code> для повышения производительности и избежания утечек соединений.</li>
<li><strong>Адаптивные настройки</strong> длины вывода и контекста в зависимости от объёма и языка входного текста.</li>
<li><strong>Нормализация текста</strong> в отдельном потоке (<code>asyncio.to_thread</code>) для неблокирующей работы.</li>
</ul>
<h2 id="_35">Основные функции</h2>
<ul>
<li><code>summarize_text()</code> — возвращает краткое резюме или <code>None</code>, если конфигурация недоступна.</li>
<li><code>summarize_text_with_reason()</code> — то же, с возвратом причины при ошибке.</li>
<li><code>suggest_commit_message_async()</code> — генерирует однострочное сообщение коммита (~80 символов).</li>
<li><code>suggest_commit_message_detailed_async()</code> — возвращает заголовок и тело с до 4 пунктов.</li>
<li><code>_summarize_with_cfg()</code> — внутренняя логика резюмирования с динамическими параметрами.</li>
<li><code>_tail_digest()</code> — извлекает значимые строки из конца текста (например, по маркерам: "добавил", "исправил").</li>
</ul>
<h2 id="_36">Настройки</h2>
<ul>
<li><strong>Модель</strong>: выбирается из <code>OPENAI_BIG_MODEL</code> или <code>OPENAI_MODEL</code> (через env).</li>
<li><strong>API ключ и URL</strong>: <code>OPENAI_API_KEY</code>, <code>OPENAI_BASE_URL</code> (по умолчанию <code>https://api.openai.com</code>).</li>
<li><strong>Токены</strong>: <code>max_tokens</code> рассчитывается динамически (~4 символа на токен для русского).</li>
<li><strong>Длина вывода</strong>: <code>max_chars</code> — ограничение с обрезкой и суффиксом <code>...(обрезано)...</code>.</li>
<li><strong>Температура</strong>: <code>0.2</code> — низкая случайность для сжатого и предсказуемого вывода.</li>
<li><strong>Обрезка входа</strong>: до 12000 символов.</li>
<li><strong>Форматирование</strong>: <code>_strip_cli_preamble</code> удаляет префиксы вроде "User:".</li>
</ul>
<h2 id="_37">Обработка ошибок и отказоустойчивость</h2>
<ul>
<li>Таймауты: <code>httpx.Timeout</code> (подключение, чтение, запись).</li>
<li>Обработка HTTP-статусов, сетевых ошибок и исключений.</li>
<li>Поддержка синхронных вызовов через <code>asyncio.run</code> при отсутствии event loop.</li>
</ul>
<h2 id="_38">Требования</h2>
<ul>
<li><code>OPENAI_API_KEY</code> и указанная модель.</li>
<li>Библиотеки: <code>openai</code>, <code>httpx</code>, <code>asyncio</code>.</li>
</ul>
<h1 id="gitops-git-telegram-">Класс <code>GitOps</code> — Работа с Git в Telegram-боте</h1>
<p>Класс <code>GitOps</code> предоставляет асинхронный интерфейс для выполнения Git-операций через Telegram-бота, интегрированный с системой сессий (<code>SessionManager</code>) и поддерживающий интерактивное взаимодействие через inline-кнопки и callback-запросы.</p>
<h2 id="_39">Основные возможности</h2>
<ul>
<li>Выполнение Git-команд: <code>commit</code>, <code>fetch</code>, <code>pull</code>, <code>merge</code>, <code>rebase</code>, <code>diff</code>, <code>log</code>, <code>stash</code>, <code>push</code>.</li>
<li>Интерактивное управление операциями: выбор веток, подтверждение действий, разрешение конфликтов.</li>
<li>Автоматическое формирование сообщений коммита (с поддержкой OpenAI при наличии API-ключа).</li>
<li>Отображение статуса репозитория, истории, отставания/опережения относительно upstream.</li>
<li>Генерация HTML-отчётов и отправка справки из <code>git.md</code>.</li>
</ul>
<h2 id="_40">Ключевые сущности</h2>
<ul>
<li><code>Session</code> — активная сессия пользователя.</li>
<li><code>SessionManager</code> — управление сессиями.</li>
<li><code>config.github_token</code> — токен для аутентификации в Git (через <code>GIT_ASKPASS</code>).</li>
<li>Внутренние состояния по <code>chat_id</code>:  </li>
<li><code>git_branch_menu</code>, <code>git_pending_ref</code>, <code>git_pull_target</code>, <code>pending_git_commit</code> — хранение промежуточных данных операций.</li>
</ul>
<h2 id="_41">Основные методы</h2>
<ul>
<li><strong><code>_run_git()</code></strong> — асинхронное выполнение Git-команд с перехватом вывода.</li>
<li><strong><code>git_env()</code></strong>, <code>_ensure_git_askpass()</code> — безопасная передача токена аутентификации.</li>
<li><strong><code>build_git_keyboard()</code></strong> — построение основного меню и вспомогательных клавиатур (выбор ветки, подтверждение, конфликты).</li>
<li><strong>Проверки состояния</strong>:  </li>
<li><code>ensure_git_session()</code>, <code>ensure_git_repo()</code>, <code>ensure_git_not_busy()</code> — валидация окружения и блокировка параллельных операций.</li>
<li><strong>Анализ репозитория</strong>:  </li>
<li><code>_git_current_branch</code>, <code>_git_upstream</code>, <code>_git_ahead_behind</code>, <code>_git_in_progress</code>, <code>_git_conflict_files</code>.</li>
<li><strong>Формирование отчётов</strong>:  </li>
<li><code>_git_status_text</code>, <code>_git_commit_context</code>, <code>_build_commit_body</code>, <code>_sanitize_commit_message</code>.</li>
</ul>
<h2 id="_42">Обработка событий</h2>
<ul>
<li><code>handle_callback()</code> — обработка inline-действий: <code>git_status</code>, <code>git_fetch</code>, <code>git_pull</code>, <code>git_help</code>, <code>git_confirm_merge</code> и др.</li>
<li><code>handle_pending_commit_message()</code> — обработка ввода сообщения коммита, включая отмену и валидацию.</li>
<li>Поддержка разрешения конфликтов: показ <code>diff</code>, вызов агента, продолжение/отмена операции.</li>
</ul>
<h2 id="_43">Безопасность и настройки</h2>
<ul>
<li>Токен GitHub передаётся через временный <code>GIT_ASKPASS</code>-скрипт.</li>
<li>Все операции асинхронны, не блокируют бота.</li>
<li>Вывод команд обрезается до 4000 символов.</li>
<li>Временные HTML-файлы удаляются после отправки.</li>
<li>Кодировка: UTF-8 с игнорированием ошибок декодирования.</li>
</ul>
<h2 id="_44">Зависимости</h2>
<ul>
<li>Git должен быть доступен в <code>PATH</code>.</li>
<li>Требуется <code>github_token</code> в конфиге для приватных репозиториев.</li>
<li>Наличие файлов: <code>git.md</code> (справка), права на чтение/запись в рабочей директории.</li>
</ul>
<p>Файл содержит функции для работы с файловой системой в контексте Telegram-бота, позволяя пользователю навигацию по каталогам через интерфейс с кнопками. Основное назначение — безопасное отображение и выбор директорий с поддержкой пагинации и ограничением доступа к корневому каталогу.</p>
<p>Ключевые сущности: словари <code>dirs_menu</code>, <code>dirs_base</code>, <code>dirs_page</code>, <code>dirs_root</code>, хранящие состояние каталогов для каждого <code>chat_id</code>; функции <code>prepare_dirs</code> и <code>build_dirs_keyboard</code> для подготовки списка директорий и построения интерактивной клавиатуры.</p>
<p>Функция <code>prepare_dirs</code> проверяет доступ к каталогу, читает поддиректории, сохраняет состояние и возвращает сообщение об ошибке или <code>None</code> при успехе. Параметр <code>allow_empty</code> позволяет обрабатывать отсутствие подкаталогов без ошибки.</p>
<p>Функция <code>build_dirs_keyboard</code> формирует <code>InlineKeyboardMarkup</code> с кнопками для выбора каталога, навигации (вверх, назад, далее), а также действиями: использовать текущий каталог, создать каталог, выполнить git clone или ввести путь вручную. Используется пагинация по 10 элементов на страницу. Каждая кнопка генерирует callback-данные для обработки в боте.</p>
<p>Модуль для управления справочной информацией по инструментам (tool help) в формате JSON-файла. Основное назначение — хранение, обновление и чтение описаний инструментов с меткой времени последнего изменения.</p>
<p>Ключевая сущность — <code>ToolHelpEntry</code>, dataclass, содержащий поля: <code>tool</code> (название инструмента), <code>content</code> (текст справки), <code>updated_at</code> (временная метка обновления в формате Unix time).</p>
<p>Основные функции:
- <code>load_toolhelp(path)</code> — загружает данные из JSON-файла по указанному пути, возвращает словарь <code>tool_name → ToolHelpEntry</code>.
- <code>save_toolhelp(path, data)</code> — сохраняет словарь с записями в JSON-файл с отступами и поддержкой Unicode.
- <code>update_toolhelp(path, tool, content)</code> — добавляет или обновляет запись для инструмента, автоматически устанавливая текущее время как <code>updated_at</code>.
- <code>get_toolhelp(path, tool)</code> — возвращает объект <code>ToolHelpEntry</code> для указанного инструмента или <code>None</code>, если не найден.</p>
<p>Файл хранится в формате JSON с ключами: <code>tool</code>, <code>content</code>, <code>updated_at</code>. При отсутствии файла или пустом содержимом возвращается пустой словарь.</p>
<p>Файл предоставляет утилиты для чтения и загрузки переменных окружения из <code>.env</code>-файлов. Основные функции:</p>
<ul>
<li><code>parse_dotenv(text: str) -&gt; Dict[str, str]</code> — разбирает строку с содержимым <code>.env</code>-файла, возвращает словарь пар ключ-значение. Поддерживает:</li>
<li>игнорирование пустых строк и комментариев (начинающихся с <code>#</code>);</li>
<li>ключи и значения в формате <code>KEY=value</code>;</li>
<li>опциональный префикс <code>export</code>;</li>
<li>значения в одинарных или двойных кавычках (кавычки удаляются);</li>
<li>
<p>inline-комментарии только при наличии пробела перед <code>#</code> (например, <code>KEY=value # comment</code>), не затрагивает <code>#</code> внутри значений или кавычек.</p>
</li>
<li>
<p><code>load_dotenv(path: str, override: bool = False) -&gt; Dict[str, str]</code> — загружает переменные из файла по указанному пути в <code>os.environ</code>. Если <code>override=False</code>, существующие переменные окружения не перезаписываются. Возвращает словарь загруженных переменных.</p>
</li>
<li>
<p><code>load_dotenv_near(path: str, filename: str = ".env", override: bool = False)</code> — удобная функция для загрузки <code>.env</code>-файла из директории, указанной в <code>path</code>.</p>
</li>
</ul>
<p>Поддерживает стандартные сценарии использования: чтение защищённых переменных, обработку кавычек, избежание перезаписи существующих значений. Используется, например, для конфигурации приложений на основе локальных файлов окружения.</p>
<p>Список зависимостей Python-пакетов для реализации Telegram-бота с расширенными функциями обработки текста, медиа и веб-контента. Основное назначение — поддержка бота, взаимодействующего с OpenAI API, выполняющего поиск в интернете, конвертацию текста в речь, извлечение текста из PDF, YouTube-транскрипций, веб-страниц и форматирование Markdown для Telegram.</p>
<p>Ключевые сущности:
- <code>python-telegram-bot</code> — основа для построения Telegram-бота.
- <code>openai</code> — интеграция с моделями OpenAI (например, GPT).
- <code>duckduckgo-search</code> — выполнение веб-поиска.
- <code>gTTS</code> — преобразование текста в речь.
- <code>youtube-transcript-api</code> — извлечение субтитров с YouTube.
- <code>pdfminer.six</code>, <code>beautifulsoup4</code>, <code>trafilatura</code> — парсинг PDF и веб-страниц.
- <code>md2tgmd</code> — конвертация Markdown-подобного текста в формат, совместимый с Telegram (HTML-разметка).
- <code>PyYAML</code> — работа с YAML-конфигурациями.
- <code>httpx</code>, <code>requests</code> — HTTP-запросы (асинхронные и синхронные).
- <code>markdown-it-py</code> с плагинами — парсинг и обработка Markdown.
- <code>pexpect</code>, <code>ansi2html</code> — обработка командной строки и преобразование ANSI-цветов в HTML.</p>
<p>Важные настройки и особенности:
- Версии пакетов зафиксированы, кроме <code>openai</code>, <code>httpx</code>, <code>beautifulsoup4</code>, <code>trafilatura</code>, <code>pdfminer.six</code>, где допускается обновление (указаны минимальные версии).
- Поддержка асинхронных операций через <code>httpx</code> и <code>python-telegram-bot==20.7</code>.
- Подготовка к генерации ответов с внешними данными: поиск, цитирование, озвучка, форматирование.</p>
<p>Модуль предоставляет тонкую обёртку для работы с вводом-выводом через Telegram с поддержкой повторных попыток при сетевых ошибках. Основное назначение — надёжная отправка и редактирование сообщений, а также отправка документов и удаление сообщений с обработкой временных сбоев сети.</p>
<p>Ключевая сущность — класс <code>TelegramIO</code>, инкапсулирующий логику повторных попыток при взаимодействии с API Telegram. Поддерживает до 5 попыток отправки с экспоненциальной задержкой (начиная с 2 секунд). Обрабатываются исключения <code>NetworkError</code> и <code>TimedOut</code>, остальные ошибки логируются и приводят к отказу.</p>
<p>Поддерживаемые операции:
- <code>send_message</code> — отправка текстового сообщения с опциональным сохранением идентификатора через переданную функцию <code>record_message</code>.
- <code>send_document</code> — отправка файла с подтверждением успеха.
- <code>delete_message</code> — удаление сообщения по ID.
- <code>edit_message</code> — редактирование текста существующего сообщения.</p>
<p>Параметр <code>record_message</code> (опциональный) — функция, вызываемая при успешной отправке сообщения для сохранения соответствия <code>chat_id</code> и <code>message_id</code>.</p>
<h1 id="ansi-markdown-mermaid">Резюме: Утилиты обработки текста с ANSI, Markdown и Mermaid</h1>
<p>Модуль предоставляет набор вспомогательных функций для преобразования терминального вывода (с ANSI-кодами, Mermaid-диаграммами и служебными метками) в чистый, валидный HTML, готовый к отображению в браузере.</p>
<h2 id="_45">Основные возможности</h2>
<ul>
<li><strong>Обработка ANSI-кодов</strong>:  </li>
<li><code>strip_ansi()</code> — удаление ANSI-последовательностей.  </li>
<li><code>ansi_to_html()</code> — преобразование ANSI-размеченного текста в HTML с цветами, жирным шрифтом, списками и таблицами.  </li>
<li>Цвета (30–37, 90–97) сопоставляются с HTML-цветами через <code>_ANSI_FG_COLORS</code>.  </li>
<li>
<p>Используются регулярные выражения <code>_ANSI_RE</code> и <code>_LOOSE_ANSI_RE</code>.</p>
</li>
<li>
<p><strong>Поддержка Mermaid</strong>:  </p>
</li>
<li><code>_MERMAID_BLOCK_RE</code> выделяет блоки Mermaid.  </li>
<li>
<p><code>_render_mermaid_svg()</code> рендерит диаграммы через внешний сервис <a href="https://mermaid.ink">mermaid.ink</a>.</p>
</li>
<li>
<p><strong>Нормализация текста</strong>:  </p>
</li>
<li><code>normalize_text()</code> удаляет строки с префиксом <code>mcp:</code> (через <code>_MCP_LINE_RE</code>) и устраняет дублирование блоков.  </li>
<li>
<p><code>build_preview()</code> — обрезка текста с пометкой усечения.</p>
</li>
<li>
<p><strong>Работа с HTML и файлами</strong>:  </p>
</li>
<li><code>escape_html_text()</code> — экранирование HTML-символов.  </li>
<li><code>make_html_file()</code> — создание временного HTML-файла.  </li>
<li>
<p><code>is_within_root()</code> — проверка безопасного пути в файловой системе.</p>
</li>
<li>
<p><strong>Сборка и обработка команд</strong>:  </p>
</li>
<li><code>build_command()</code> — подстановка значений (<code>{prompt}</code>, <code>{resume}</code>, <code>{image}</code>) в шаблон с фильтрацией неактуальных флагов.  </li>
<li>
<p><code>resolve_env_value()</code> — раскрытие переменных окружения.</p>
</li>
<li>
<p><strong>Детекция сессий и приглашений</strong>:  </p>
</li>
<li><code>detect_prompt_regex()</code> — определение приглашения ввода по последним строкам.  </li>
<li><code>detect_resume_regex()</code> — поиск идентификаторов сессии (thread_id, conversation_id и др.) по жёстко заданным шаблонам.</li>
</ul>
<h2 id="_46">Вспомогательные функции</h2>
<ul>
<li><code>sandbox_*</code> — работа с путями в песочнице.  </li>
<li><code>_TICK_OR_TIME_RE</code> — извлечение временных меток.</li>
</ul>
<h2 id="_47">Зависимости и особенности</h2>
<ul>
<li>Модули: <code>os</code>, <code>re</code>, <code>html</code>, <code>tempfile</code>.  </li>
<li>Глобальное состояние (<code>out</code>, <code>fg_color</code>, <code>bold</code>, <code>open_span</code>) — требует осторожности при использовании в многопоточной среде.  </li>
<li>Регулярные выражения и шаблоны частично зашиты в код.</li>
</ul>
<p>Результат — структурированный HTML с инлайн-стилями, поддержкой цветов, диаграмм и безопасной подстановкой данных.</p>
<h1 id="_48">Управление сессиями выполнения инструментов</h1>
<p>Файл реализует асинхронное управление сессиями выполнения внешних инструментов (tools) с поддержкой headless и интерактивных режимов. Основные компоненты — классы <code>Session</code> и <code>SessionManager</code>.</p>
<h2 id="_49">Основные сущности</h2>
<h3 id="session"><code>Session</code></h3>
<p>Отвечает за жизненный цикл сессии:
- Хранит состояние: ID, <code>ToolConfig</code>, рабочую директорию, флаги активности, очередь команд, процессы и метаданные (git-состояние, временные метки, данные агента).
- Поддерживает два режима выполнения:
  - <strong>Headless</strong>: через <code>asyncio.subprocess</code>, с безопасным чтением вывода и обработкой таймаутов.
  - <strong>Интерактивный</strong>: через <code>pexpect</code>, с ожиданием приглашений (<code>prompt_regex</code>) и возобновлением по токену (<code>resume_token</code>).
- Обеспечивает:
  - Асинхронное выполнение с защитой от зависаний (проверка PID, принудительное завершение).
  - Обработку сигналов (<code>SIGINT</code>, <code>SIGTERM</code>, <code>SIGKILL</code>) и graceful shutdown (<code>grace_sec</code>).
  - Отслеживание активности по выводу и тикетам (<code>extract_tick_tokens</code>).
  - Автоматическое выполнение команд (<code>auto_commands</code>) при инициализации.
  - Поддержку изображений через <code>image_cmd</code> (если доступно).
- Логирует выполнение, ошибки и диагностику состояния процесса.</p>
<h3 id="sessionmanager"><code>SessionManager</code></h3>
<p>Централизованное управление сессиями:
- Создание, активация, переключение, восстановление и закрытие сессий.
- Хранение сессий по уникальному ID (предотвращение конфликтов при совпадении tool + workdir).
- Автоматическая генерация ID и поддержка счётчика.
- Сохранение и восстановление состояния:
  - Сериализация в файл по пути <code>config.defaults.state_path</code>.
  - Валидация при восстановлении (наличие инструмента и директории).
  - Отдельное хранение активной сессии (<code>active_session_id</code>).
- Уведомления об изменениях через <code>_fire_session_change()</code>.</p>
<h2 id="_50">Ключевые параметры</h2>
<table>
<thead>
<tr>
<th>Параметр</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tool.mode</code></td>
<td>Режим выполнения: <code>headless</code> или <code>interactive</code></td>
</tr>
<tr>
<td><code>tool.cmd</code>, <code>tool.headless_cmd</code>, <code>tool.interactive_cmd</code></td>
<td>Шаблоны команд запуска</td>
</tr>
<tr>
<td><code>tool.env</code></td>
<td>Переменные окружения (с разрешением через <code>resolve_env_value</code>)</td>
</tr>
<tr>
<td><code>tool.prompt_regex</code>, <code>tool.resume_regex</code></td>
<td>Регулярные выражения для приглашения и токена возобновления</td>
</tr>
<tr>
<td><code>tool.auto_commands</code></td>
<td>Команды, выполняемые при старте сессии</td>
</tr>
<tr>
<td><code>idle_timeout_sec</code></td>
<td>Таймаут бездействия перед завершением сессии</td>
</tr>
<tr>
<td><code>resume_token</code></td>
<td>Токен для возобновления сессии</td>
</tr>
<tr>
<td><code>state_path</code></td>
<td>Путь к файлу сохранения состояния сессий</td>
</tr>
</tbody>
</table>
<h2 id="_51">Особенности реализации</h2>
<ul>
<li><strong>Асинхронность и отказоустойчивость</strong>: Использование <code>asyncio</code> и <code>pexpect</code>, обработка ошибок через <code>try/except</code>.</li>
<li><strong>Сериализация</strong>: Очередь сообщений нормализуется (строки → <code>{text, dest}</code>), состояние сохраняется целиком.</li>
<li><strong>Автоконфигурация</strong>: Функции <code>detect_prompt_regex</code>, <code>detect_resume_regex</code>, <code>save_config</code> обновляют настройки динамически.</li>
<li><strong>Интеграции</strong>: Поддержка <code>config</code>, <code>pexpect</code>, обработка окружения и help-команд (<code>run_tool_help</code>).</li>
</ul>
<h2 id="_52">Назначение</h2>
<p>Обеспечивает устойчивое, многорежимное выполнение инструментов с сохранением состояния между перезапусками, корректным управлением активной сессией и гибкой конфигурацией.</p>
<p>Конфигурационный файл для Telegram-бота, управляющего CLI-агентами (Codex, Claude, Gemini, Qwen) в headless-режиме. Определяет параметры подключения к Telegram, настройки инструментов, режимы работы, переменные окружения, пути и таймауты. Поддерживает мультиагентную оркестровку (режим manager), включая автоматическое выполнение, резюмирование и коммиты в Git. Включает фильтрацию чатов через <code>whitelist_chat_ids</code>, настройки обработки изображений, логирования, временных файлов и памяти. Доступ к MCP-серверам (внешние инструменты) настраивается через <code>mcp_servers</code> с указанием URL. Пресеты позволяют быстро запускать типовые команды (тесты, линтер). Ключевые параметры: <code>token</code>, <code>workdir</code>, <code>idle_timeout_sec</code>, <code>manager_auto_commit</code>, <code>image_max_mb</code>, <code>clarification_keywords</code>, <code>env</code> для API-ключей, <code>cmd</code> и <code>resume_cmd</code> для кастомизации вызовов агентов.</p>
<p>Преобразует текст для корректного отображения в Telegram с использованием MarkdownV2. Основная логика — попытка использовать библиотеку <code>md2tgmd</code> для точного экранирования специальных символов и нормализации Markdown-разметки. При отсутствии или ошибке <code>md2tgmd</code> применяется резервный метод, экранирующий все специальные символы MarkdownV2: <code>_ * [ ] ( ) ~</code> &gt; # + - = | { } . ! `. Символы экранируются двойным обратным слэшем. Функция безопасно обрабатывает <code>None</code>, возвращая пустую строку. Основная сущность — регулярное выражение <code>_MDV2_RE</code>, определяющее подлежащие экранированию символы.</p>
<p>Класс <code>Dispatcher</code> отвечает за выбор профиля исполнителя (<code>ExecutorProfile</code>) для каждого шага плана (<code>PlanStep</code>). На текущий момент поддерживается только один профиль по умолчанию, инициализируемый на основе конфигурации приложения (<code>AppConfig</code>) и реестра инструментов (<code>ToolRegistry</code>). </p>
<p>Ключевые сущности:
- <code>AppConfig</code> — конфигурация приложения.
- <code>ToolRegistry</code> — реестр доступных инструментов.
- <code>ExecutorProfile</code> — профиль исполнителя, определяющий поведение при выполнении шага.
- <code>PlanStep</code> — шаг плана, для которого выбирается профиль.</p>
<p>Важные настройки:
- Инициализация профиля по умолчанию через <code>build_default_profile</code>.
- Логирование инициализации и выбора профиля на уровне <code>INFO</code>.</p>
<p>В будущем логику выбора профиля можно расширить в зависимости от типа шага, его параметров или других условий.</p>
<p>Модуль отвечает за управление долговременной памятью проекта: определяет, какие сведения стоит сохранить, и сжимает память при превышении лимита. Основные функции — <code>decide_memory_save</code> и <code>compress_memory</code>. Первая анализирует диалог и решает, нужно ли сохранить информацию в одной из категорий: preference, decision, config, agreement (по убыванию приоритета), возвращая тег и содержание записи. Вторая сжимает существующую память до заданного количества символов, сохраняя формат записей и приоритет по категориям. Использует LLM через <code>chat_completion</code> с жёстко заданными системными промптами. Формат сохраняемых записей: <code>- YYYY-MM-DD HH:MM: [TAG] текст</code>. Чувствительные и временные данные не сохраняются.</p>
<p>Модуль предоставляет асинхронные функции для взаимодействия с OpenAI API через <code>AsyncOpenAI</code>. Основное назначение — выполнение запросов к модели с использованием настроек из <code>AppConfig</code>.</p>
<p>Ключевые сущности:
- <code>get_openai_config</code> — извлекает из конфигурации API-ключ, модель и базовый URL; возвращает <code>None</code>, если обязательные параметры отсутствуют.
- <code>build_client</code> — создаёт экземпляр <code>AsyncOpenAI</code> на основе конфигурации; возвращает клиент и имя модели или <code>None</code>.
- <code>chat_completion</code> — выполняет асинхронный запрос к чат-модели с системным и пользовательским сообщением; поддерживает опциональный <code>response_format</code>.</p>
<p>Важные настройки:
- <code>openai_api_key</code>, <code>openai_model</code>, <code>openai_base_url</code> — задаются в <code>config.defaults</code>; последний по умолчанию равен <code>https://api.openai.com</code>.
- Температура фиксирована на уровне <code>0.2</code>.
- Используется <code>chat.completions.create</code> с двумя сообщениями: <code>system</code> и <code>user</code>.
- При отсутствии ответа или ошибке возвращается пустая строка.</p>
<h1 id="_53">Резюме: Политика безопасности и ограничений</h1>
<p>Документ описывает правила безопасного использования вычислительной среды, направленные на предотвращение выполнения ресурсоёмких, опасных или бесполезных операций. Запрещены:</p>
<ul>
<li>Бесконечные циклы и тяжёлые вычисления  </li>
<li>Сетевое сканирование и атаки на сервисы  </li>
<li>Доступ к чужим данным и системным ресурсам  </li>
</ul>
<p>Разрешены легальные действия: установка пакетов, запуск скриптов, управление файлами, планирование задач и корректная работа с сетью. Приведены рекомендации по запуску сервисов, использованию инструментов и эффективному расходованию памяти.</p>
<p>Модуль отвечает за построение плана выполнения задачи пользователя в виде последовательности шагов. Использует LLM для генерации структурированного плана в формате JSON, который затем парсится и валидируется. Основная функция — <code>plan_steps</code>, возвращающая список объектов <code>PlanStep</code>, описывающих действия, уточнения или параллельные задачи.</p>
<p>Ключевые сущности:<br/>
- <code>PlanStep</code> — модель шага с полями: <code>id</code>, <code>title</code>, <code>instruction</code>, <code>step_type</code>, <code>depends_on</code>, <code>parallelizable</code>, <code>parallel_group</code>, <code>ask_question</code>, <code>ask_options</code>.<br/>
- <code>step_type</code> может быть <code>task</code> (обычный шаг) или <code>ask_user</code> (требует уточнения у пользователя).<br/>
- При необходимости уточнения автоматически добавляется шаг с <code>ask_user</code>, если это не предусмотрено LLM.<br/>
- Поддержка параллельного выполнения через флаги <code>parallelizable</code> и <code>parallel_group</code>, с обязательным обоснованием в <code>parallelizable_reason</code>.  </p>
<p>Важные настройки и поведение:<br/>
- Запрос к LLM отправляется с системным промптом <code>_PLANNER_SYSTEM</code>, требующим строгий JSON-формат ответа.<br/>
- Нестабильный вывод LLM обрабатывается через <code>_extract_json_object</code>, извлекающий JSON из текста или код-фен.<br/>
- Гарантируется уникальность <code>id</code> шагов через <code>_ensure_unique_step_ids</code> с использованием временных меток и UUID.<br/>
- Если LLM возвращает пустой или невалидный JSON, используется fallback-план с одним шагом.<br/>
- Дополнительная проверка на необходимость уточнения через <code>needs_clarification</code> из модуля эвристик.</p>
<h1 id="_54">Резюме документации</h1>
<p>Файл содержит системные промпты и шаблоны для автоматизации управления разработкой ПО с использованием ИИ-ассистентов. Обеспечивает автономный цикл: анализ проекта, декомпозиция задач, реализация и ревью.</p>
<h2 id="_55">Основные компоненты</h2>
<ul>
<li><strong><code>DECOMPOSE_INSTRUCTION</code></strong> — промпт для анализа проекта и генерации плана задач. Выход: строгий JSON с <code>project_analysis</code> и списком атомарных задач (описание, критерии приёмки, зависимости).</li>
<li><strong><code>DECOMPOSE_NORMALIZE_SYSTEM</code></strong> — нормализует неструктурированный ответ в валидный JSON, восстанавливает пропущенные ID и критерии.</li>
<li><strong><code>DEV_INSTRUCTION_TEMPLATE</code></strong> — задание для ИИ-разработчика: описание задачи, контекст, критерии приёмки, указание на автономное выполнение с отчётом.</li>
<li><strong><code>REVIEW_INSTRUCTION_TEMPLATE</code></strong> — шаблон проверки реализации: анализ отчёта, соответствие ТЗ и критериям приёмки.</li>
</ul>
<h2 id="_56">Ключевые настройки</h2>
<ul>
<li>Максимум 10 задач в декомпозиции (<code>{max_tasks}</code>).</li>
<li>Обязательный строгий JSON-формат ответов без дополнительного текста.</li>
<li>Полная автономность: запрет на уточнения у пользователя.</li>
<li>Все вызовы LLM используют модель из <code>defaults.openai_model</code>.</li>
</ul>
<h2 id="_57">Статус ревью</h2>
<div class="highlight"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">"approved"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">  </span><span class="nt">"summary"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Не удалось проверить выполнение критериев из-за отсутствия данных."</span><span class="p">,</span>
<span class="w">  </span><span class="nt">"comments"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Не предоставлены описание задачи, отчёт разработчика, файлы или тесты для анализа. Требуется дополнительная информация для проведения ревью."</span><span class="p">,</span>
<span class="w">  </span><span class="nt">"files_reviewed"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">  </span><span class="nt">"tests_passed"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span>
<span class="p">}</span>
</code></pre></div>
<p>Файл предоставляет функции для работы с локальным файлом памяти <code>MEMORY.md</code>, используемым для хранения временных записей в формате Markdown. Основное назначение — ведение журнала событий с поддержкой тегов, дедупликацией, компрессией по приоритету и ограничением по размеру.  </p>
<p>Ключевые сущности:<br/>
- <code>MEMORY.md</code> — файл, хранящий записи в формате <code>- ГГГГ-ММ-ДД ЧЧ:ММ: [ТЕГ] Текст</code>.<br/>
- Регулярное выражение <code>_ENTRY_RE</code> — парсит записи, извлекая метку времени, тег и текст.<br/>
- Функции <code>read_memory</code>, <code>write_memory</code>, <code>append_memory</code> — чтение, запись и добавление содержимого.<br/>
- <code>append_memory_tagged</code> — добавляет запись с тегом, избегая дубликатов (сравнение по нормализованному тексту и тегу).<br/>
- <code>parse_entries</code> — разбирает содержимое на структурированные записи.<br/>
- <code>compact_memory_by_priority</code> — сжимает память по заданному лимиту в байтах, сохраняя записи в порядке приоритета тегов.<br/>
- <code>trim_for_context</code> — обрезает текст по количеству символов с пометкой о тримировании.<br/>
- <code>memory_size_bytes</code> — возвращает размер содержимого в байтах.  </p>
<p>Важные настройки:<br/>
- <code>max_chars=2000</code> в <code>trim_for_context</code> — ограничение на длину контекста.<br/>
- <code>max_bytes</code> в <code>compact_memory_by_priority</code> — лимит размера памяти при компрессии.<br/>
- <code>priority</code> — список тегов, определяющий порядок сохранения записей при сжатии.  </p>
<p>Функции работают с указанием рабочей директории (<code>cwd</code>), что позволяет использовать изолированные файлы памяти.</p>
<p>Файл предоставляет функции для управления жизненным циклом проектного плана в виде JSON-файла. Основное назначение — загрузка, сохранение, архивирование и удаление плана разработки, представленного структурой <code>ProjectPlan</code>, включая вложенные сущности <code>DevTask</code> и <code>ProjectAnalysis</code>.</p>
<p>Ключевые сущности:<br/>
- <code>ProjectPlan</code> — основной объект плана проекта с целями, задачами, анализом и статусом.<br/>
- <code>DevTask</code> — отдельная задача разработки с критериями приёмки, зависимостями и историей выполнения.<br/>
- <code>ProjectAnalysis</code> — анализ состояния проекта, включающий выполненные и оставшиеся задачи.</p>
<p>Основные функции:<br/>
- <code>load_plan</code> — загружает план из <code>MANAGER_PLAN.json</code>, возвращает <code>None</code>, если файл отсутствует.<br/>
- <code>save_plan</code> — атомарно сохраняет план в файл с обновлением временных меток <code>created_at</code> и <code>updated_at</code>.<br/>
- <code>delete_plan</code> — удаляет текущий файл плана (используется при сбросе).<br/>
- <code>archive_plan</code> — перемещает текущий план в архив с временной меткой и статусом, возвращает путь к архивному файлу или <code>None</code> при ошибке.</p>
<p>Файл плана хранится в корне рабочей директории, архивные копии — в поддиректории <code>.manager_archive</code>. Все операции сопровождаются обработкой исключений и логированием ошибок.</p>
<p>Модуль предоставляет потокобезопасные операции чтения и записи JSON-файлов с использованием системных блокировок. Основное назначение — обеспечение целостности данных при одновременном доступе к файлу из нескольких процессов.</p>
<p>Ключевые функции:
- <code>read_json_locked</code> — читает JSON-файл под общей (shared) блокировкой, возвращает содержимое как словарь. При отсутствии файла, ошибке парсинга или пустом содержимом возвращает значение по умолчанию.
- <code>write_json_locked</code> — записывает словарь в JSON-файл под эксклюзивной (exclusive) блокировкой с полной перезаписью содержимого.
- <code>update_json_locked</code> — выполняет атомарное чтение, модификацию и запись JSON-файла под эксклюзивной блокировкой. Принимает функцию <code>updater</code>, которая преобразует текущие данные и возвращает новые.</p>
<p>Все функции автоматически создают родительские директории пути при необходимости. Используется буферизация и синхронизация (<code>os.fsync</code>) для надежности записи на диск. Файлы открываются в режиме <code>a+</code>, что гарантирует создание файла, если он отсутствует.</p>
<p>Файл определяет основные сущности и контракты для системы планирования и исполнения задач, ориентированной на управление разработкой и выполнение агентных операций. Включает модели данных для шагов плана, запросов и ответов исполнителя, а также структуры для режима управления проектами (Manager mode).</p>
<p>Ключевые сущности:
- <code>PlanStep</code> — описание шага в плане, включая зависимости, тип, возможность параллельного выполнения и разрешённые инструменты.
- <code>ExecutorRequest</code> — входные данные для исполнителя: цель, контекст, ограничения, ожидаемые выходы и профиль исполнения.
- <code>ExecutorResponse</code> — ответ от исполнителя с результатами, вызовами инструментов и следующими вопросами.
- <code>DevTask</code> — задача разработки с критериями приёма, статусом, зависимостями и историей проверок.
- <code>ProjectPlan</code> — план проекта, содержащий список задач, анализ состояния и общий статус.
- <code>ProjectAnalysis</code> — анализ текущего состояния проекта: выполненные и оставшиеся задачи.
- <code>ReviewResult</code> — результат ревью задачи: одобрение, комментарии, результаты тестов.</p>
<p>Важные настройки и правила:
- Параллельное выполнение шагов (<code>parallelizable</code>) требует явного указания и обоснования.
- Зависимости между шагами задаются через <code>depends_on</code> для безопасного исполнения.
- Валидация запросов и ответов осуществляется через <code>validate_request</code> и <code>validate_response</code>.
- Поддержка режима диалога с пользователем через <code>ask_question</code> и <code>ask_options</code> в <code>PlanStep</code>.
- Ограничение числа попыток выполнения задачи через <code>max_attempts</code> в <code>DevTask</code>.</p>
<p>Модуль предоставляет основные компоненты для работы агента: ядро исполнения, реестр инструментов и вспомогательные функции для выполнения команд. Включает класс <code>AgentRunner</code> для управления жизненным циклом агента, <code>ToolRegistry</code> для регистрации и управления инструментами, а также функции <code>execute_shell_command</code>, <code>pop_pending_command</code> и <code>set_approval_callback</code> для взаимодействия с командами оболочки и обработки подтверждений. Основное назначение — объединение логики исполнения и инструментария в единую точку доступа.</p>
<h1 id="react">ReAct Агент — Краткое резюме</h1>
<h2 id="_58">Назначение</h2>
<p>Файл реализует агентскую систему на основе архитектуры <strong>ReAct (Reasoning + Acting)</strong>, предназначенную для выполнения пользовательских задач с использованием LLM (через OpenAI API) и набора инструментов (tools). Агент поддерживает диалог, управление памятью, историей чата, работу в песочнице и циклическое выполнение действий с логированием.</p>
<h2 id="_59">Ключевые сущности</h2>
<ul>
<li><strong><code>ReActAgent</code></strong> — основной класс, управляющий циклом рассуждений и действий: анализирует ответы модели, вызывает инструменты, обрабатывает результаты.</li>
<li><strong><code>AgentRunner</code></strong> — фасад для запуска агента, управляет сессиями и проверкой конфигурации.</li>
<li><strong><code>AgentRunResult</code></strong> — результат выполнения: ответ, статус, список вызванных инструментов.</li>
<li><strong><code>PluginToolRegistry</code></strong> — реестр доступных инструментов, фильтруемых по <code>allowed_tools</code>.</li>
<li><strong>Сессия (<code>session</code>)</strong> — состояние агента, хранится в <code>SESSION.json</code> в изолированной директории.</li>
<li><strong><code>working</code></strong> — временный буфер текущей итерации (вызовы/результаты инструментов).</li>
</ul>
<h2 id="_60">Основные функции</h2>
<ul>
<li><code>_load_session</code> / <code>_save_session</code> — потокобезопасное чтение/запись сессии.</li>
<li><code>_build_messages</code> — формирование цепочки сообщений с системным промптом, памятью, историей и текущим контекстом.</li>
<li><code>_call_openai</code> — вызов модели с ограничением инструментов.</li>
<li><code>run</code> — основной цикл агента: итеративная обработка до ответа или лимита.</li>
</ul>
<h2 id="_61">Конфигурация и настройки</h2>
<ul>
<li><strong>Максимумы:</strong></li>
<li><code>AGENT_MAX_ITERATIONS</code> — лимит итераций ReAct.</li>
<li><code>AGENT_MAX_BLOCKED</code> — лимит блокировок команд.</li>
<li><code>AGENT_MAX_HISTORY</code> — лимит записей в истории.</li>
<li><code>MAX_CHAT_MESSAGES</code>, <code>MAX_MEMORY_CHARS</code> — ограничения на чат и память.</li>
<li><strong>Пути и окружение:</strong></li>
<li><code>AGENT_SANDBOX_ROOT</code> — корень песочницы.</li>
<li><code>_shared_dir</code>, <code>_chats_dir</code> — директории данных.</li>
<li><code>MEMORY_FILE</code> — файл памяти (<code>MEMORY.md</code>).</li>
<li><strong>OpenAI:</strong></li>
<li><code>OPENAI_API_KEY</code>, <code>OPENAI_MODEL</code>, <code>OPENAI_BASE_URL</code> — настраиваются через <code>AppConfig</code> или переменные окружения.</li>
<li><strong>Системный промпт:</strong></li>
<li>Загружается из <code>system.txt</code>, подставляются <code>{{cwd}}</code>, <code>{{date}}</code>, <code>{{tools}}</code>, <code>{{userPorts}}</code>, память и история.</li>
</ul>
<h2 id="_62">Особенности</h2>
<ul>
<li><strong>Логирование:</strong> глобальное через <code>log_global</code>, детальное через <code>_log</code>.</li>
<li><strong>Блокировка команд:</strong> команды с <code>BLOCKED:</code> игнорируются, превышение <code>AGENT_MAX_BLOCKED</code> останавливает выполнение.</li>
<li><strong>Обработка ошибок:</strong> прерывание при трёх неудачных попытках подряд.</li>
<li><strong>Поддержка контекста:</strong> в промпт добавляются <code>request_context</code>, <code>constraints</code>, <code>corr_id</code> для трассировки.</li>
<li><strong>Интеграция:</strong> требует валидного <code>OPENAI_API_KEY</code> и <code>OPENAI_MODEL</code>.</li>
</ul>
<h2 id="_63">Назначение файлов</h2>
<ul>
<li><code>system.txt</code> — шаблон системного промпта.</li>
<li><code>SESSION.json</code> — состояние сессии.</li>
<li><code>MEMORY.md</code> — контекстная память агента.</li>
</ul>
<p>Файл содержит вспомогательные функции для обработки шагов планирования и определения необходимости уточнения входного запроса. Основная логика построена на анализе текста и конфигурации приложения.</p>
<p>Функция <code>needs_clarification</code> проверяет, требует ли текст уточнения, на основе наличия вопросительного знака или ключевых слов из конфигурации (<code>clarification_keywords</code>). Проверка активируется только при включённой опции <code>clarification_enabled</code> в <code>AppConfig</code>.</p>
<p>Функция <code>normalize_ask_step</code> нормализует объект <code>PlanStep</code>, устанавливая значения по умолчанию для полей <code>ask_question</code> и <code>ask_options</code>, если они не заданы или содержат недостаточно вариантов ответа.</p>
<p>Ключевые сущности: <code>AppConfig</code>, <code>PlanStep</code>.<br/>
Важные настройки: <code>clarification_enabled</code>, <code>clarification_keywords</code> — определяют поведение механизма уточнения.</p>
<h1 id="_64">Оркестратор выполнения пользовательских задач — Краткое резюме</h1>
<h2 id="_65">Назначение</h2>
<p>Файл реализует <strong>оркестратор выполнения многошаговых пользовательских задач</strong>, координирующий планирование, выполнение шагов, взаимодействие с пользователем и генерацию итогового ответа. Основной класс — <code>OrchestratorRunner</code>, управляющий циклом обработки в асинхронной среде.</p>
<h2 id="_66">Ключевые сущности</h2>
<ul>
<li><code>PlanStep</code> — структура шага плана с зависимостями, типом и ID.</li>
<li><code>Executor</code> — выполнение шагов через инструменты.</li>
<li><code>Dispatcher</code> — маршрутизация и управление выполнением.</li>
<li><code>ExecutorRequest</code> / <code>ExecutorResponse</code> — ввод/вывод исполнителя (статус, результат, ошибки).</li>
<li><code>session_store</code>, <code>memory_store</code> — хранение сессий (с блокировками) и контекстной памяти.</li>
<li><code>tool_registry</code> — реестр доступных инструментов.</li>
<li><code>bot</code> — отправка сообщений и вложений.</li>
<li><code>session</code>, <code>context</code>, <code>dest</code> — данные сессии и назначения.</li>
</ul>
<h2 id="_67">Основные функции</h2>
<ul>
<li>Асинхронное выполнение шагов с поддержкой <strong>параллелизма</strong> (при явном указании).</li>
<li>Управление <strong>зависимостями</strong> между шагами (выполнение только после успешного завершения предшественников).</li>
<li><strong>Динамическое перепланирование</strong> после каждого шага (до 25 итераций).</li>
<li>Обработка <code>ask_user</code> — запрос уточнений от пользователя (до 2 раз).</li>
<li>Сбор <strong>артефактов</strong> (файлов) и их отправка отдельными сообщениями.</li>
<li>Финальный ответ генерируется через LLM с использованием Markdown и кратких итогов.</li>
</ul>
<h2 id="_68">Настройки и ограничения</h2>
<ul>
<li>Рабочая директория: изолированная (<code>workdir</code> из <code>AppConfig</code>).</li>
<li>Память: до 2000 символов, компрессия при превышении (<code>memory_max_kb</code>, <code>memory_compact_target_kb</code>).</li>
<li>История оркестратора: последние 25 записей.</li>
<li>JSON-контекст финального ответа: до 40 000 символов.</li>
<li><code>SESSION.json</code>: до 50 записей, с блокировкой при доступе.</li>
<li>Ограничение на перепланирования: 25, на уточнения: 2.</li>
<li>Блокировка параллельного выполнения для файловых операций без явного разрешения.</li>
</ul>
<h2 id="_69">Особенности</h2>
<ul>
<li>Восстановление состояния сессии из <code>SESSION.json</code>.</li>
<li>Адаптивное обновление памяти: <code>_maybe_update_memory</code> с приоритезацией по тегам или LLM-сжатием.</li>
<li>Компактное представление выходных данных (обрезка &gt;5000 символов).</li>
<li>Финальный ответ отправляется асинхронно, не блокируя цикл.</li>
<li>Поддержка профилей: ограничения по инструментам, настройки UI и плагинов.</li>
<li>Логирование: статусы, метрики, длина ответов, обновления сессии.</li>
</ul>
<h2 id="_70">Завершение работы</h2>
<p>Оркестратор останавливается при:
- Отсутствии шагов для выполнения.
- Превышении лимита перепланирований.
- Критических ошибках или явном завершении задачи.</p>
<p>Модуль определяет профили исполнителей (<code>ExecutorProfile</code>) — конфигурации с набором разрешённых инструментов, таймаутами и количеством попыток. Используется для управления доступом и ограничениями при выполнении задач в зависимости от роли (например, default, reviewer, developer).</p>
<p>Ключевая сущность — <code>ExecutorProfile</code>, датакласс с полями:<br/>
- <code>name</code> — имя профиля<br/>
- <code>allowed_tools</code> — список имён разрешённых инструментов<br/>
- <code>timeout_ms</code> — максимальное время выполнения в миллисекундах<br/>
- <code>max_retries</code> — количество попыток повтора при ошибках  </p>
<p>Функции формирования профилей:<br/>
- <code>build_default_profile</code> — профиль по умолчанию с доступом ко всем инструментам и увеличенным таймаутом (600 сек), подходит для сложных задач.<br/>
- <code>build_reviewer_profile</code> — профиль для ревьюера: только безопасные, идемпотентные инструменты (чтение файлов, поиск, запуск команд), таймаут задаётся через конфиг (<code>manager_review_timeout_sec</code>), одна попытка.<br/>
- <code>build_developer_profile</code> — заготовка для разработчика, не предоставляет инструментов (выполнение через CLI), используется для симметрии интерфейсов, таймаут настраивается через <code>manager_dev_timeout_sec</code>.  </p>
<p>Зависит от <code>AppConfig</code> (настройки приложения) и <code>ToolRegistry</code> (реестр доступных инструментов). Фильтрация инструментов по наличию выполняется через вспомогательную функцию <code>_available</code>.</p>
<p>Класс <code>Executor</code> отвечает за выполнение задач агента в изолированной среде с поддержкой инструментов, обработкой ошибок и повторными попытками. Основан на <code>AgentRunner</code> и использует <code>ToolRegistry</code> для управления доступными инструментами. Поддерживает диалог с пользователем через <code>ask_user</code>, обработку таймаутов и временных сбоев с экспоненциальным отступом.</p>
<p>Ключевые сущности:
- <code>ExecutorRequest</code> / <code>ExecutorResponse</code> — валидируемые входные и выходные данные.
- <code>ExecutorProfile</code> — определяет политики выполнения: <code>allowed_tools</code>, <code>max_retries</code>, <code>timeout_ms</code>.
- <code>ToolRegistry</code> — предоставляет и выполняет инструменты, включая <code>ask_user</code>.
- <code>AgentRunner</code> — непосредственно запускает логику агента (ReAct).</p>
<p>Важные настройки:
- <code>workdir</code> в конфиге — корневая директория для песочниц.
- <code>session_workspace</code> — изолированная директория на сессию.
- <code>max_retries</code> и <code>timeout_ms</code> из профиля — контроль устойчивости и времени выполнения.
- Обработка <code>asyncio.TimeoutError</code>, <code>ConnectionError</code> и подобных как временных ошибок.
- Логирование с привязкой к <code>corr_id</code> и замером времени выполнения.</p>
<p>Методы управления:
- <code>record_message</code>, <code>resolve_question</code>, <code>clear_session_cache</code> — работа с состоянием сессии.
- <code>get_plugin_commands</code>, <code>get_plugin_ui</code> — интеграция с интерфейсом бота через разрешённые инструменты.</p>
<h1 id="manager-orchestrator">Модуль управления проектом (Manager Orchestrator)</h1>
<p>Модуль реализует оркестратор управления проектом в режиме менеджера, координирующего выполнение задач через взаимодействие с исполнителем (агентом). Центральный класс — <code>ManagerOrchestrator</code>, управляющий жизненным циклом проектного плана на основе целей пользователя.</p>
<h2 id="_71">Ключевые сущности</h2>
<ul>
<li><code>ProjectPlan</code> — структурированный план проекта с задачами, статусами и зависимостями.</li>
<li><code>DevTask</code> — отдельная задача разработки с попытками, зависимостями и статусом.</li>
<li><code>Executor</code> — компонент выполнения и ревью задач.</li>
<li><code>Session</code> — контекст сессии с рабочей директорией и состоянием.</li>
<li><code>bot</code> — отправка уведомлений пользователю (при наличии <code>chat_id</code>).</li>
</ul>
<h2 id="_72">Основные функции</h2>
<ul>
<li><code>run</code> — основная точка входа: загружает или создаёт план и запускает цикл обработки.</li>
<li><code>_start_new_plan</code> — инициализация плана по пользовательскому запросу с fallback-механизмами при ошибках парсинга.</li>
<li><code>_run_loop</code> — асинхронный цикл выполнения: выбор задачи, разработка, ревью, решение, повтор или завершение.</li>
<li><code>_next_ready_task</code> — определяет следующую готовую задачу с учётом зависимостей и статусов.</li>
<li><code>_is_plan_blocked</code> — проверка блокировки плана (все невыполненные задачи — <code>blocked</code>/<code>failed</code>).</li>
<li><code>format_manager_status</code> — формирует читаемый отчёт о состоянии плана.</li>
<li><code>_notify_plan</code> — отправка сводки по плану в чат.</li>
<li><code>_compose_final_report</code> — генерация итогового отчёта через LLM.</li>
<li><code>_auto_commit</code> — автоматический git-коммит после успешного выполнения задачи с генерацией сообщения через LLM.</li>
<li><code>pause</code>, <code>reset</code> — приостановка и сброс сессии с архивацией плана.</li>
</ul>
<h2 id="_73">Логика работы</h2>
<ol>
<li>
<p><strong>Инициализация плана</strong>:<br/>
   - Декомпозиция запроса через CLI с таймаутом (<code>manager_decompose_timeout_sec</code>).<br/>
   - При неудаче — нормализация через агента (с постепенным ужесточением).<br/>
   - Результат валидируется и приводится к единой структуре (<code>_payload_to_plan</code>).</p>
</li>
<li>
<p><strong>Выполнение плана</strong>:<br/>
   - Цикл <code>_run_loop</code> обрабатывает задачи до завершения или ошибки.<br/>
   - Учитываются зависимости: провал зависимой задачи → статус <code>blocked</code>.<br/>
   - Поддержка повторных попыток для статусов из <code>RETRIABLE_STATUSES</code>.<br/>
   - Ограничения: <code>manager_max_tasks</code>, <code>manager_max_attempts</code> — защита от бесконечных циклов.</p>
</li>
<li>
<p><strong>Состояния и восстановление</strong>:<br/>
   - План сохраняется после каждого шага (<code>save_plan</code>).<br/>
   - При перезапуске: <code>in_progress</code>, <code>in_review</code> → <code>pending</code>; <code>rejected</code> → <code>pending</code> или <code>failed</code>.<br/>
   - <code>needs_resume_choice</code> — определяет необходимость подтверждения возобновления.</p>
</li>
<li>
<p><strong>Интеграции и уведомления</strong>:<br/>
   - Использует <code>openai_client</code>, <code>manager_store</code>, <code>manager_prompts</code>, <code>tooling.registry</code>.<br/>
   - Отправка статусов и отчётов через <code>bot</code>.<br/>
   - Автокоммит в git: анализ изменений, генерация сообщения (<code>COMMIT_MESSAGE_SYSTEM</code>), фиксация.</p>
</li>
</ol>
<h2 id="_74">Настройки</h2>
<ul>
<li><code>manager_auto_resume</code> — автоматическое возобновление плана.</li>
<li><code>manager_auto_commit</code> — включение автоматического коммита.</li>
<li><code>manager_debug_log</code> — сохранение отладочных данных в <code>.manager/</code>.</li>
<li><code>defaults.openai_model</code> — модель LLM для всех вызовов.</li>
<li><code>manager_dev_timeout_sec</code>, <code>manager_dev_report_max_chars</code> — таймауты и лимиты.</li>
</ul>
<h2 id="_75">Вспомогательные функции</h2>
<ul>
<li><code>_extract_json_object</code> — извлечение JSON из текста/Markdown.</li>
<li><code>_debug_write</code> — запись отладочных промптов и ответов.</li>
<li><code>_truncate_report</code> — обрезка длинных текстов с сохранением контекста.</li>
<li><code>_run_git</code> — выполнение git-команд.</li>
</ul>
<h2 id="_76">Особенности</h2>
<ul>
<li>Обнаружение дедлоков и каскадных блокировок.</li>
<li>Архивация завершённого плана и отправка итогового отчёта.</li>
<li>Поддержка отладочного режима с детальным логированием.</li>
</ul>
<h1 id="_77">Конфигурация фильтрации команд — краткое резюме</h1>
<p>Конфигурационный файл предназначен для <strong>детектирования и блокировки потенциально опасных команд</strong> в shell-окружениях, CI/CD-пайплайнах и изолированных средах выполнения. Основная цель — <strong>предотвращение утечек секретов, экзфильтрации данных, повышения привилегий, обхода изоляции и выполнения вредоносных операций</strong>.</p>
<h2 id="_78">Основные категории угроз</h2>
<ul>
<li><code>env_leak</code> — утечка переменных окружения (<code>env</code>, <code>printenv</code>, <code>$SECRET</code>).</li>
<li><code>sensitive_files</code> — чтение конфиденциальных файлов (<code>.env</code>, <code>id_rsa</code>, <code>.pem</code>, <code>credentials</code>).</li>
<li><code>docker_secrets</code> — доступ к <code>/run/secrets</code>, <code>/var/run/secrets</code>.</li>
<li><code>exfiltration</code> — кодирование и передача данных (<code>base64</code>, <code>openssl</code>, <code>curl</code>, <code>nc</code>, DNS-экстракция).</li>
<li><code>code_env_access</code> — доступ к секретам через код (Python: <code>os.environ</code>, <code>dotenv</code>, <code>open</code>).</li>
<li><code>network_scan</code> — сканирование сети (<code>nmap</code>, <code>masscan</code>, <code>zmap</code>).</li>
<li><code>dos</code> — ресурсоёмкие команды (<code>dd</code>, <code>yes</code>, <code>fallocate</code>, бесконечные циклы, Python-вычисления).</li>
<li><code>crypto_mining</code> — запуск майнеров (<code>xmrig</code>, <code>minerd</code>).</li>
<li><code>process_kill</code> — принудительное завершение процессов (<code>kill -9</code>, <code>xkill</code>).</li>
<li><code>privilege</code> — попытки повышения привилегий (<code>sudo</code>, <code>apt</code>, <code>chroot</code>).</li>
<li><code>escape</code> — побег из контейнера (<code>docker</code>, <code>nsenter</code>, <code>unshare</code>, <code>/proc</code>).</li>
<li><code>cloud</code> — доступ к метаданным облака (169.254.169.254, <code>curl</code> к внутренним сервисам).</li>
<li><code>obfuscation</code> — обфускация команд (<code>chr()</code>, <code>reversed</code>, <code>IFS</code>, hex-кодирование).</li>
<li><code>filter_bypass</code> — обход фильтров (<code>/dev/tcp</code>, ANSI-C quoting, brace expansion).</li>
<li><code>code_execution</code> — выполнение кода (<code>exec</code>, <code>eval</code>, <code>importlib</code>, <code>LD_PRELOAD</code>).</li>
<li><code>recon</code> — разведка (<code>dig</code>, <code>nslookup</code>, <code>host</code>).</li>
<li><code>attack_tool</code> — использование инструментов атак (SQLmap, Metasploit, Cobalt Strike).</li>
<li><code>persistent</code> — создание персистентности (<code>crontab</code>, <code>systemctl</code>).</li>
<li><code>large_install</code> — установка тяжёлых пакетов (TensorFlow, PyTorch, Go, Rust).</li>
<li><code>dangerous_download</code> — загрузка и выполнение скриптов (<code>curl | bash</code>).</li>
<li><code>cross-user</code> — доступ к чужим рабочим областям (<code>../</code>, <code>/workspace</code>, <code>_shared/</code>).</li>
</ul>
<h2 id="_79">Ключевые параметры правил</h2>
<ul>
<li><code>id</code> — уникальный идентификатор правила.</li>
<li><code>category</code> — тип угрозы.</li>
<li><code>pattern</code> — регулярное выражение для сопоставления.</li>
<li><code>flags</code> — флаги (например, <code>i</code> — регистронезависимость).</li>
<li><code>reason</code> — пояснение блокировки.</li>
</ul>
<h2 id="_80">Назначение</h2>
<p>Обеспечение безопасности, стабильности и контролируемости среды выполнения за счёт централизованного управления запрещёнными паттернами. Используется в secure shell, песочницах, CI/CD и облачных платформах.</p>
<p>Модуль реализует загрузчик плагинов <code>PluginLoader</code> для динамической подгрузки классов, наследующих <code>ToolPlugin</code>, из Python-файлов в указанной директории. Основная цель — обнаружение и инициализация плагинов, исключая системные и базовые файлы (<code>__init__.py</code>, <code>base.py</code>). Поддерживаются только <code>.py</code> файлы, из которых загружаются модули через <code>importlib.util</code>. Классы плагинов должны быть унаследованы от <code>ToolPlugin</code> и не совпадать с ним напрямую. Экземпляры успешно загруженных классов добавляются в результирующий список. Ошибки при загрузке модулей или инициализации плагинов логируются с помощью <code>logging.exception</code>. Важные настройки: путь к директории с плагинами, исключённые файлы, безопасная загрузка модулей с регистрацией в <code>sys.modules</code>.</p>
<h1 id="_81">Резюме: Назначение и функциональность файла</h1>
<p>Файл реализует безопасное выполнение команд и работу с внешними данными в изолированной среде с контролем доступа. Основные задачи — проверка команд на соответствие политикам безопасности, санитизация вывода, ограничение объёма данных и поддержка безопасного доступа к веб-ресурсам.</p>
<h2 id="_82">Ключевые функции</h2>
<ul>
<li><strong>Проверка команд</strong>: <code>check_command</code> анализирует команды на соответствие блокирующим шаблонам из <code>BLOCKED_PATTERNS_PATH</code>, с учётом типа чата.</li>
<li><strong>Изоляция рабочей области</strong>: <code>_check_workspace_isolation</code>, <code>_check_command_path_escape</code> предотвращают выход за пределы выделённой директории.</li>
<li><strong>Санитизация вывода</strong>: <code>sanitize_output</code>, <code>_trim_output</code>, <code>_trim_fetch_output</code> ограничивают и очищают вывод команд и веб-запросов.</li>
<li><strong>Выполнение команд</strong>: <code>execute_shell_command</code> — асинхронное выполнение shell-команд с таймаутами, фоновым режимом и логированием.</li>
<li><strong>Подтверждение команд</strong>: <code>PendingCommand</code>, <code>_PENDING_COMMANDS</code>, <code>set_approval_callback</code>, <code>pop_pending_command</code> управляют командами, требующими подтверждения.</li>
<li><strong>Загрузка веб-контента</strong>: Поддержка нескольких провайдеров (<code>proxy</code>, <code>tavily</code>, <code>jina</code>, <code>zai</code>) и резервный метод через <code>trafilatura</code>. Обеспечивает извлечение и структурирование текста с веб-страниц.</li>
</ul>
<h2 id="_83">Настройки безопасности</h2>
<ul>
<li><strong>Чувствительные файлы</strong>: <code>SENSITIVE_FILES</code> включает <code>.env*</code>, <code>id_rsa</code>, <code>secrets.yaml</code>, <code>*.pem</code>, <code>credentials.*</code> и др. Проверяется содержимое и пути на наличие секретов.</li>
<li><strong>Блокировка URL</strong>: Список <code>blocked</code> предотвращает доступ к опасным ресурсам (например, метаданным облака).</li>
<li><strong>Таймауты</strong>: <code>TOOL_TIMEOUT_MS</code>, <code>WEB_FETCH_TIMEOUT_MS</code>, <code>GREP_TIMEOUT_MS</code>.</li>
<li><strong>Ограничения вывода</strong>: <code>OUTPUT_TRIM_LEN</code>, <code>OUTPUT_HEAD_LEN</code>, <code>OUTPUT_TAIL_LEN</code>, <code>FETCH_MAX_CHARS</code>.</li>
</ul>
<h2 id="_84">Интеграции и провайдеры</h2>
<ul>
<li>Активируются через переменные окружения: <code>PROXY_URL</code>, <code>TAVILY_API_KEY</code>, <code>JINA_API_KEY</code>, <code>ZAI_API_KEY</code>.</li>
<li>Резервный метод — прямой HTTP-запрос + обработка через <code>trafilatura</code>.</li>
</ul>
<h2 id="_85">Формат вывода</h2>
<p>Функции возвращают объект вида:
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="w"> </span><span class="nt">"success"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="nt">"output"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// или { "error": "..." }</span>
</code></pre></div>
Совместимо с инструментальным интерфейсом агента.</p>
<h2 id="_86">Дополнительно</h2>
<ul>
<li><code>MEMORY_FILE = "MEMORY.md"</code> — указание на файл памяти (используется в других модулях).</li>
</ul>
<h1 id="_87">Краткое резюме</h1>
<p>Данный документ представляет собой техническую документацию, объединяющую несколько частей, описывающих архитектуру, функциональность и использование системы. В документации рассматриваются основные компоненты системы, их взаимодействие, интерфейсы и процессы. Описаны требования, принципы работы, примеры использования и рекомендации по интеграции. Документ предназначен для разработчиков, инженеров и технических специалистов, обеспечивающих развертывание и сопровождение решения.</p>
<p>Определяет структуры данных для описания и ответа инструментов (tools) в системе взаимодействия с ИИ-моделями.  </p>
<p><code>ToolSpec</code> описывает спецификацию инструмента: имя, описание, параметры в формате JSON Schema, таймаут выполнения (по умолчанию 120 секунд), уровень риска (<code>low</code> по умолчанию), необходимость подтверждения (<code>requires_approval</code>), теги и возможность параллельного выполнения (<code>parallelizable</code>). Поддерживает преобразование в форматы OpenAI и Google через методы <code>to_openai_tool</code> и <code>to_google_tool</code>.  </p>
<p><code>ToolResponse</code> представляет ответ от инструмента: флаг успеха, опциональный вывод, сообщение об ошибке и дополнительные метаданные.  </p>
<p>Используется для стандартизации описания и обработки внешних инструментов в AI-агентах.</p>
<h1 id="toolregistry">ToolRegistry — Реестр инструментов и менеджер плагинов</h1>
<p>Класс <code>ToolRegistry</code> обеспечивает централизованное управление инструментами (плагинами) для агента, включая их регистрацию, хранение, валидацию, выполнение и доступ. Поддерживает локальные плагины, удалённые MCP-инструменты (Model Control Protocol), а также генерацию совместимых спецификаций для ИИ-моделей (OpenAI, Google).</p>
<h2 id="_88">Основные функции</h2>
<ul>
<li><strong>Регистрация и загрузка</strong>:</li>
<li><code>_load_plugins</code>: загружает локальные плагины из директории <code>plugins</code>.</li>
<li><code>ensure_mcp_loaded</code>: асинхронно обнаруживает и кэширует MCP-инструменты.</li>
<li>
<p><code>register</code>: регистрирует плагин с проверкой уникальности имени и валидацией параметров.</p>
</li>
<li>
<p><strong>Доступ к инструментам</strong>:</p>
</li>
<li><code>get_definitions</code>: возвращает спецификации инструментов в формате OpenAI/Google.</li>
<li><code>get_plugin_commands</code>: извлекает команды плагинов с проверкой уникальности.</li>
<li>
<p><code>_filter_allowed</code>: фильтрует инструменты по списку <code>allowed_tools</code> (<code>"All"</code>, <code>"None"</code>).</p>
</li>
<li>
<p><strong>Выполнение и управление</strong>:</p>
</li>
<li><code>execute</code>, <code>execute_many</code>: запуск инструментов с таймаутом (<code>TOOL_TIMEOUT_MS</code>) и обработкой ошибок.</li>
<li><code>execute_parallel_or_sequential</code>: определяет режим выполнения (параллельно/последовательно) на основе флага <code>parallelizable</code>.</li>
<li>
<p><code>any_awaiting_input</code>, <code>cancel_all_inputs</code>: управление состоянием ожидания ввода.</p>
</li>
<li>
<p><strong>Интерфейс и обработчики</strong>:</p>
</li>
<li><code>build_bot_commands</code>, <code>build_bot_ui</code>: формируют команды и UI-элементы бота.</li>
<li><code>get_message_handlers</code>, <code>get_inline_handlers</code>: собирают обработчики сообщений и inline-запросов.</li>
<li>
<p>Поддержка callback-обработчиков через <code>callback_query_handler</code>.</p>
</li>
<li>
<p><strong>Валидация и нормализация</strong>:</p>
</li>
<li><code>_validate_and_normalize_command</code>, <code>_validate_and_normalize_handler</code>: проверяют и дополняют метаданные.</li>
<li><code>_validate_args</code>: валидация аргументов по JSON-схеме из <code>ToolSpec</code>.</li>
</ul>
<h2 id="_89">Состояние и сервисы</h2>
<p>Плагины получают доступ к общим сервисам через <code>services</code>:
- <code>pending_questions</code>, <code>recent_messages</code>, <code>task_store</code>, <code>scheduler_tasks</code>, <code>user_tasks</code>.</p>
<h2 id="_90">Важные компоненты</h2>
<ul>
<li><code>MCPManager</code>: управление MCP-серверами и кэширование инструментов.</li>
<li><code>PluginLoader</code>: загрузка локальных плагинов.</li>
<li><code>MCPRemoteToolPlugin</code>: представление удалённых MCP-инструментов.</li>
</ul>
<h2 id="_91">Настройки и поведение</h2>
<ul>
<li><code>TOOL_TIMEOUT_MS</code>: глобальный таймаут выполнения инструментов.</li>
<li>Автоматическая нормализация имён через <code>get_function_prefix</code>.</li>
<li>Обнаружение опечаток: <code>get_missing_suggestions</code> с использованием <code>difflib</code>.</li>
<li>Синглтон-реализация: <code>_REGISTRY_SINGLETON</code>, инициализируется через <code>get_tool_registry</code>.</li>
</ul>
<h2 id="_92">Утилиты</h2>
<ul>
<li><code>record_message</code>: хранит последние 20 ID сообщений для управления контекстом.</li>
<li><code>resolve_question</code>: разрешает ожидающие вопросы через <code>Future</code>.</li>
<li><code>close_all</code>: корректно завершает все плагины с логированием ошибок.</li>
</ul>
<h2 id="_93">Назначение</h2>
<p><code>ToolRegistry</code> обеспечивает:
- Единый интерфейс для всех инструментов.
- Безопасное и контролируемое выполнение.
- Гибкую настройку доступности и интерфейса.
- Поддержку расширяемости через плагины и MCP.</p>
<p>Переменные конфигурации, задающие таймауты и ограничения на объём вывода для различных операций.<br/>
<code>TOOL_TIMEOUT_MS</code> — максимальное время выполнения инструмента (120 секунд).<br/>
<code>GREP_TIMEOUT_MS</code> — таймаут операции поиска (30 секунд).<br/>
<code>WEB_FETCH_TIMEOUT_MS</code> — таймаут получения данных из веба (90 секунд).<br/>
<code>OUTPUT_TRIM_LEN</code> — максимальная длина обрезанного вывода (3000 символов).<br/>
<code>OUTPUT_HEAD_LEN</code> — длина начальной части вывода при обрезке (1500 символов).<br/>
<code>OUTPUT_TAIL_LEN</code> — длина конечной части вывода при обрезке (1000 символов).<br/>
Используются для контроля производительности и объёма данных в обработке инструментов.</p>
<p>Плагин инструмента для интеграции с удалёнными MCP-сервисами через стандартный интерфейс взаимодействия с инструментами. Обеспечивает регистрацию и выполнение вызовов к MCP-инструментам, управляемым через <code>MCPManager</code>.  </p>
<p>Ключевые сущности:<br/>
- <code>MCPRemoteToolPlugin</code> — реализация плагина, предоставляющего доступ к удалённому MCP-инструменту.<br/>
- <code>MCPToolInfo</code> — описание инструмента (имя, схема ввода, описание).<br/>
- <code>MCPManager</code> — менеджер, отвечающий за выполнение вызовов к MCP-серверам.  </p>
<p>Особенности:<br/>
- Использует <code>_normalize_schema</code> для приведения входной схемы к валидному JSON Schema формату с корневым типом <code>object</code>.<br/>
- Результаты выполнения обрабатываются через <code>_render_mcp_result</code>, извлекающий текст из <code>content</code> или сериализующий ответ в JSON.<br/>
- Идентификатор плагина формируется как <code>MCP[&lt;server_name&gt;]</code>, префиксы функций отключены для сохранения оригинальных имён инструментов.<br/>
- Таймаут выполнения — 30 секунд, выполнение не параллелизуется.  </p>
<p>Параметры спецификации (<code>ToolSpec</code>):<br/>
- <code>name</code> — имя инструмента в реестре.<br/>
- <code>description</code> — описание из <code>MCPToolInfo</code> или сгенерированное.<br/>
- <code>parameters</code> — нормализованная схема входных данных.<br/>
- <code>parallelizable</code> — <code>False</code>.<br/>
- <code>timeout_ms</code> — 30000.  </p>
<p>При сбое вызова ошибка логируется и возвращается в структурированном виде.</p>
<p>Плагин инструмента для поиска текста или регулярных выражений в файлах с использованием <code>grep</code>. Позволяет искать определения, вхождения или паттерны кода в указанной директории или файле. Поддерживает контекст вывода, нечувствительность к регистру, фильтрацию по типу файлов и исключение чувствительных директорий и файлов (например, <code>node_modules</code>, <code>.git</code>, <code>.env</code>, ключи).  </p>
<p>Ключевые параметры:
- <code>pattern</code> — обязательный поисковый запрос или регулярное выражение.
- <code>path</code> — путь для поиска (по умолчанию — текущая директория).
- <code>context_before</code>, <code>context_after</code> — количество строк до и после совпадения.
- <code>files_only</code> — возвращать только пути к файлам, содержащим совпадения.
- <code>ignore_case</code> — выполнить поиск без учёта регистра.</p>
<p>Автоматически блокирует запросы, содержащие потенциально опасные ключевые слова (например, <code>password</code>, <code>token</code>, <code>secret</code>). Использует безопасное разрешение путей в пределах рабочей области. Результат ограничивается 200 строками. Время выполнения ограничено через <code>GREP_TIMEOUT_MS</code>.</p>
<p>Инструмент <code>show_me_diagrams</code> для генерации и рендеринга диаграмм с использованием PlantUML. Поддерживает два режима: <code>generate</code> — генерация PlantUML-кода на основе описания с помощью LLM (через OpenAI API), и <code>render</code> — прямой рендеринг переданного PlantUML-кода в PNG. Поддерживаемые типы диаграмм: <code>gantt_chart</code>, <code>mind_map</code>, <code>flowchart</code>, <code>project_timeline</code>, <code>infographic</code>, <code>org_chart</code>, <code>process_diagram</code>.</p>
<p>Ключевые параметры:
- <code>action</code>: <code>generate</code> или <code>render</code> (обязательный)
- <code>diagram_type</code>: тип диаграммы (для <code>generate</code>)
- <code>description</code>: описание диаграммы (для <code>generate</code>)
- <code>plantuml_code</code>: PlantUML-код (для <code>render</code>)
- <code>title</code>: заголовок диаграммы (опционально)</p>
<p>Требуется наличие <code>plantuml.jar</code> в той же директории, что и скрипт, и установленного Java. Для генерации кода требуется <code>OPENAI_API_KEY</code>. Результат — путь к PNG-файлу и исходный PlantUML-код. Файлы сохраняются во временной директории. Таймаут выполнения — 120 секунд.</p>
<p>Инструмент для поиска изображений и GIF-файлов через DuckDuckGo Images. Предоставляет асинхронный интерфейс выполнения запросов с последующим извлечением URL найденных изображений. Поддерживает параметры поиска: текстовый запрос, тип контента (photo/gif), регион и максимальное количество результатов. Результаты перемешиваются перед выбором случайного изображения. Использует библиотеку <code>duckduckgo-search</code>, которая должна быть установлена. В случае ошибки или отсутствия результатов возвращает соответствующее сообщение. Основные параметры: <code>query</code> (обязательный), <code>type</code>, <code>region</code>, <code>max_results</code>. Инструмент параллелизуем.</p>
<p>Инструмент <code>read_file</code> предназначен для безопасного чтения содержимого файлов в рамках рабочей области. Позволяет читать файлы по указанному пути с возможностью задать смещение (номер начальной строки) и ограничение на количество возвращаемых строк. Перед использованием проверяет доступ к файлу: разрешает доступ только в пределах текущей рабочей директории, блокирует чтение чувствительных файлов и файлов из чужих рабочих пространств. Поддерживает чтение отсутствующих или пустых файлов с соответствующим информированием. Основные параметры: <code>path</code> (обязательный), <code>offset</code>, <code>limit</code>. Используется в цепочках инструментов, где требуется анализ исходного кода или данных перед редактированием.</p>
<p>Плагин инструмента для асинхронного получения содержимого файлов из репозитория GitHub по указанному пути. Поддерживает выборку как отдельных файлов, так и содержимого директорий с ограничением на количество обрабатываемых файлов.  </p>
<p>Ключевые сущности:<br/>
- <code>GitHubAnalysisTool</code> — реализация плагина, наследующая <code>ToolPlugin</code>.<br/>
- <code>ToolSpec</code> — описание инструмента: имя <code>github_analysis</code>, параметры <code>owner</code>, <code>repo</code>, <code>path</code>, <code>max_files</code>.<br/>
- Обязательные параметры: <code>owner</code>, <code>repo</code>.<br/>
- <code>max_files</code> — ограничение от 1 до 20 файлов (по умолчанию 5).  </p>
<p>Авторизация осуществляется через токен, который берётся из переменной окружения <code>GITHUB_TOKEN</code> или из конфигурации плагина. Запросы к API GitHub выполняются синхронно в отдельном потоке через <code>asyncio.to_thread</code>.  </p>
<p>Поддерживается декодирование контента из base64 или загрузка по <code>download_url</code>. Результат включает имена файлов и их содержимое, объединённые с разделителем. В случае ошибки возвращается сообщение об ошибке.</p>
<p>Инструмент для выполнения запросов к WolframAlpha с получением кратких текстовых ответов. Используется для вычислений, научных данных, статистики и других точных ответов на основе структурированной базы знаний. Поддерживает выполнение через асинхронный интерфейс с синхронным вызовом API в отдельном потоке. Требует наличие переменной окружения <code>WOLFRAM_APP_ID</code>. Запросы рекомендуется передавать на английском языке для лучшей точности. Основной метод — <code>execute</code>, принимающий параметр <code>query</code>. Используется простой HTTP-запрос к <code>/v1/result</code>, возвращающий plain text. Таймаут выполнения — 60 секунд.</p>
<h1 id="telegram-_1">Резюме: Система диалогов и инструментов для Telegram-бота</h1>
<p>Базовый класс <code>ToolPlugin</code> и миксин <code>DialogMixin</code> предоставляют унифицированную архитектуру для реализации плагинов с поддержкой инструментов, интерактивных диалогов и интеграции с Telegram.</p>
<h2 id="_94">Основные компоненты</h2>
<ul>
<li><strong><code>ToolPlugin</code></strong> — абстрактный базовый класс, определяющий:</li>
<li>Интерфейс для описания (<code>get_spec</code>) и выполнения инструментов (<code>execute</code>).</li>
<li>Жизненный цикл: <code>initialize()</code>, <code>close()</code>.</li>
<li>Интеграцию с Telegram: меню, обработчики сообщений и inline-колбэков.</li>
<li>
<p>Протокол ожидания ввода: <code>awaiting_input()</code>, <code>cancel_input()</code>.</p>
</li>
<li>
<p><strong><code>DialogMixin</code></strong> — добавляет управление диалогами:</p>
</li>
<li>Состояния через <code>start_dialog()</code>, <code>end_dialog()</code>, <code>get_dialog()</code>, <code>set_step()</code>.</li>
<li>Автоматическое завершение по таймауту (<code>DIALOG_TIMEOUT = 300</code> сек).</li>
<li>Отмена диалога по словам из <code>CANCEL_WORDS</code> или кнопке «Отмена».</li>
<li>Вспомогательные методы: <code>_ensure_agent_enabled()</code>, <code>_plugin_id_safe()</code>.</li>
</ul>
<h2 id="_95">Диалоговые сущности</h2>
<ul>
<li><strong><code>dialog_button</code></strong> — кнопка, привязанная к шагу диалога: <code>dlg:{plugin_id}:{data}</code>.</li>
<li><strong><code>action_button</code></strong> — кнопка автономного действия: <code>cb:{plugin_id}:{action}[:{payload}]</code>.</li>
<li><strong><code>parse_callback_payload</code></strong> — извлечение payload из <code>callback_data</code>.</li>
</ul>
<h2 id="_96">Обработка событий</h2>
<ul>
<li><strong><code>handle_message</code></strong> — перехватывает сообщения при активном диалоге, проверяет отмену, передаёт в обработчик шага.</li>
<li><strong><code>handle_callback</code></strong> — центральный обработчик нажатий, маршрутизирует по типу:</li>
<li><code>_dispatch_callback</code> разделяет запросы на:<ul>
<li><code>dlg_cancel:</code> — отмена диалога (<code>_on_cancel_button</code>).</li>
<li><code>dlg:</code> — шаги диалога.</li>
<li><code>cb:</code> — автономные действия.</li>
</ul>
</li>
<li><strong><code>_dialog_callback_commands</code></strong> — регистрирует единый <code>CallbackQueryHandler</code> с фильтрацией по префиксу и ID плагина.</li>
<li><strong><code>_dialog_active_filter</code></strong> — фильтр для сообщений: только при активном диалоге, без команд.</li>
</ul>
<h2 id="_97">Конфигурация и расширение</h2>
<ul>
<li><strong><code>dialog_steps</code></strong> — словарь шагов диалога и их обработчиков (сообщения/колбэки).</li>
<li><strong><code>callback_handlers</code></strong> — сопоставление действий (<code>action</code>) с асинхронными обработчиками.</li>
<li><strong><code>step_hint</code></strong> — подсказка при некорректном вводе.</li>
<li><strong><code>extra_message_filters</code></strong> — расширение фильтрации (по умолчанию — блокировка всех вложений).</li>
</ul>
<h2 id="_98">Особенности</h2>
<ul>
<li>Единый обработчик колбэков с префиксной маршрутизацией.</li>
<li>Автоматическое завершение диалога при ошибке, таймауте или отключении агента.</li>
<li>Поддержка автономных действий с payload.</li>
<li>Плагины с диалогами должны наследоваться от <code>DialogMixin</code> первым для корректного MRO.</li>
</ul>
<p>Назначение: упрощение построения интерактивных сценариев в Telegram-ботах с чётким разделением состояний, безопасной обработкой ввода и гибкой маршрутизацией событий.</p>
<p>Инструмент <code>list_directory</code> предназначен для безопасного просмотра содержимого директории в рамках рабочей области агента. Поддерживает указание пути через параметр <code>path</code>, по умолчанию используется текущая директория (<code>cwd</code>). Реализует защиту от доступа к системным и привилегированным директориям, таким как <code>/etc</code>, <code>/root</code>, <code>/.ssh</code> и другим. Проверяет расположение запрашиваемого пути относительно рабочей директории, блокируя доступ к чужим пользовательским пространствам. Выполняет команду <code>ls -la</code> через <code>subprocess</code>, возвращает содержимое в случае успеха или сообщение об ошибке. Все пути нормализуются и проверяются с помощью вспомогательных функций из <code>helpers</code>. Ключевые параметры: <code>path</code> — строка с путём к директории.</p>
<p>Инструмент <code>ask_user</code> предназначен для взаимодействия с пользователем через интерфейс с кнопками выбора. Используется, когда агенту требуется подтверждение или выбор из нескольких вариантов. Возвращает текст выбранного пользователем варианта.</p>
<p>Ключевая сущность — <code>AskUserTool</code>, реализующая интерфейс <code>ToolPlugin</code>. Описание инструмента определяется через <code>ToolSpec</code>, включая обязательные параметры:<br/>
- <code>question</code> (строка) — вопрос, отображаемый пользователю;<br/>
- <code>options</code> (массив строк, от 2 до 4 элементов) — варианты ответов в виде кнопок.</p>
<p>Инструмент не поддерживает параллельное выполнение (<code>parallelizable=False</code>).  </p>
<p>В процессе выполнения:<br/>
- Генерируется уникальный <code>question_id</code> на основе времени и UUID;<br/>
- Создаётся <code>Future</code> для асинхронного ожидания ответа;<br/>
- Отправляется запрос пользователю через <code>bot._send_ask_question</code>;<br/>
- Ожидается ответ в течение 120 секунд; при таймауте возвращается ошибка.</p>
<p>Состояние ожидания хранится в <code>self.services["pending_questions"]</code>, что позволяет обрабатывать ответ при его поступлении.</p>
<h1 id="textdocumentqatool">TextDocumentQATool — Документация</h1>
<h2 id="_99">Назначение</h2>
<p>Инструмент <code>TextDocumentQATool</code> реализует Telegram-бота для управления текстовыми документами и диалогового взаимодействия с ними на основе LLM. Позволяет пользователям загружать, просматривать, задавать вопросы по содержимому и удалять документы.</p>
<h2 id="_100">Основные функции</h2>
<ul>
<li><strong><code>upload</code></strong> — загрузка документа (имя + содержимое), сохранение в <code>.txt</code> и метаданных в <code>.meta</code>.</li>
<li><strong><code>list</code></strong> — отображение списка доступных документов.</li>
<li><strong><code>ask</code></strong> — задание вопроса по содержимому документа с использованием ИИ.</li>
<li><strong><code>delete</code></strong> — удаление документа и связанного метафайла по <code>document_id</code>.</li>
</ul>
<h2 id="_101">Хранение данных</h2>
<ul>
<li>Файлы сохраняются в директории, определяемой через <code>AGENT_SANDBOX_ROOT</code>, <code>config.defaults.workdir</code> или <code>cwd</code>.</li>
<li>Документы: <code>{doc_id}.txt</code> (содержимое), <code>{doc_id}.meta</code> (имя).</li>
<li><code>doc_id</code> генерируется как SHA1-хеш содержимого.</li>
</ul>
<h2 id="_102">Диалоговый интерфейс</h2>
<p>Интегрирован с <code>DialogMixin</code>, поддерживает пошаговый ввод:
- <code>wait_name</code> — ввод имени документа.
- <code>wait_content</code> — ввод текста документа.
- <code>wait_doc_select</code> — выбор документа из списка.
- <code>wait_query</code> — ввод вопроса.</p>
<p>Управление состоянием через <code>set_step</code> / <code>get_dialog</code>.</p>
<h2 id="llm">Интеграция с LLM</h2>
<ul>
<li>Используется <code>AsyncOpenAI</code> для асинхронных запросов.</li>
<li>Модель: <code>gpt-4o-mini</code> (настраивается через <code>OPENAI_MODEL</code>).</li>
<li>Ключ API: <code>OPENAI_API_KEY</code> (обязательный).</li>
<li>Базовый URL: <code>OPENAI_BASE_URL</code> (опционально, например, для прокси).</li>
<li>Параметры: <code>temperature=0.2</code>, <code>max_tokens=800</code>.</li>
<li>Контекст ограничивается 12000 символами.</li>
<li>Промпт включает системное сообщение и пользовательский вопрос.</li>
</ul>
<h2 id="_103">Ответы</h2>
<p>Возвращаются в формате JSON:
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="w"> </span><span class="nt">"success"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="nt">"output"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
или
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="w"> </span><span class="nt">"success"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nt">"error"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w"> </span><span class="p">}</span>
</code></pre></div></p>
<h2 id="_104">Интерфейс</h2>
<ul>
<li>Меню с меткой «Документы».</li>
<li>Обработка команд через callback-запросы (<code>_cb_*</code>).</li>
<li>Формирование клавиатуры: <code>_build_doc_list_keyboard()</code>.</li>
</ul>
<h2 id="_105">Ограничения</h2>
<ul>
<li>Таймаут выполнения: 120 секунд.</li>
<li>Нет поддержки параллельных сессий.</li>
<li>Логика ответа на вопрос (<code>ask</code>) частично реализована.</li>
</ul>
<h2 id="_106">Зависимости</h2>
<ul>
<li>Переменные окружения: <code>OPENAI_API_KEY</code>, <code>OPENAI_BASE_URL</code>, <code>OPENAI_MODEL</code>.</li>
<li>Асинхронная работа с OpenAI API.</li>
</ul>
<p>Инструмент <code>manage_message</code> позволяет агенту управлять собственными недавними сообщениями в текущем диалоге: удалять (последнее или по индексу) и редактировать последнее сообщение. Поддерживает три действия через параметр <code>action</code>: <code>delete_last</code>, <code>delete_by_index</code>, <code>edit_last</code>. Для удаления по индексу используется параметр <code>index</code>, для редактирования — <code>new_text</code>. Индексация сообщений ведётся от 0 (самое старое) до -1 (последнее). Инструмент взаимодействует с ботом через контекст (<code>bot._delete_message</code>, <code>bot._edit_message</code>) и отслеживает идентификаторы сообщений в хранилище <code>services.recent_messages</code>. Операции ограничены только сообщениями агента в текущем чате. В случае ошибок возвращает подробное описание сбоев, включая проблемы с доступом, сроком жизни сообщения или валидностью индекса.</p>
<p>Инструмент <code>send_file</code> позволяет отправлять файлы из рабочей директории в чат. Предназначен для обмена результатами работы, например, созданными скриптами, отчётами или данными. Путь к файлу может быть относительным или абсолютным. Файл проверяется на наличие в рабочей области, его размер (не более 50 МБ), а также на чувствительность — запрещены отправка файлов с ключевыми словами вроде <code>.env</code>, <code>secrets</code>, <code>id_rsa</code> и другими, связанными с учётными данными. Перед отправкой файл проверяется на существование и ненулевой размер. Поддерживается необязательная подпись (caption). Отправка осуществляется через бота, используя метод <code>_send_document</code>. В случае ошибок возвращаются информативные сообщения, включая ограничения по правам доступа (например, запрет на отправку медиа в группе).</p>
<p>Инструмент <code>CodeInterpreterTool</code> предоставляет возможность безопасного выполнения ограниченного Python-кода в изолированной среде на локальной машине. Основное назначение — интерпретация и выполнение фрагментов кода, не требующих импорта сторонних модулей или доступа к системным ресурсам. Инструмент включает статическую проверку кода на наличие потенциально опасных конструкций и выполняет код в отдельном процессе с ограничением по времени.</p>
<p>Ключевые сущности:<br/>
- <code>ToolPlugin</code> — базовый класс для инструментов агента.<br/>
- <code>ToolSpec</code> — описание интерфейса инструмента, включая параметры и поведение.<br/>
- <code>_static_block</code> — проверка кода по регулярным выражениям на запрещённые конструкции (импорты, <code>os</code>, <code>subprocess</code>, <code>open</code>, <code>eval</code>, <code>exec</code>, дандер-методы и др.).<br/>
- <code>_run_sync</code> — выполнение кода в отдельном процессе Python через временный файл, с ограниченным окружением и перехватом вывода.</p>
<p>Важные настройки и параметры:<br/>
- <code>code</code> (обязательный) — строка с Python-кодом для выполнения.<br/>
- <code>timeout_sec</code> — таймаут выполнения (по умолчанию 20 секунд, ограничение от 1 до 60 секунд).<br/>
- <code>parallelizable=False</code> — инструмент не поддерживает параллельное выполнение.<br/>
- <code>timeout_ms=60_000</code> — максимальное время ожидания ответа от инструмента.  </p>
<p>Выход содержит <code>output</code> при успехе или <code>error</code> при сбое, включая блокировку по правилам фильтрации. Результат обрезается с помощью <code>helpers._trim_output</code> для предотвращения передачи избыточных данных.</p>
<h1 id="_107">Резюме: Плагинная система с поддержкой диалогов</h1>
<p>Базовый класс <code>ToolPlugin</code> служит основой для всех плагинов, обеспечивая интеграцию с агентом и Telegram-интерфейсом. Плагины автоматически регистрируются в <code>ToolRegistry</code> и доступны как для вызова агентом, так и для взаимодействия с пользователем. Ключевые параметры: <code>plugin_id</code> (уникальный ID) и <code>function_prefix</code> (префикс инструмента). Работают в приоритетной группе хендлеров (-1) при активной сессии агента.</p>
<h2 id="_108">Основные методы и контракт</h2>
<ul>
<li><code>get_spec()</code> — возвращает JSON Schema спецификации инструмента.</li>
<li><code>execute()</code> — выполняет логику плагина, возвращает <code>{"success": bool, "output"|"error": str}</code>.</li>
</ul>
<h2 id="dialogmixin">Диалоги и интерактивность (<code>DialogMixin</code>)</h2>
<p><code>DialogMixin</code> (наследуется <strong>до</strong> <code>ToolPlugin</code>) обеспечивает поддержку многошаговых диалогов:
- Управление состоянием ввода: <code>awaiting_input(chat_id)</code>, <code>cancel_input(chat_id)</code>.
- Обработка inline-колбэков: <code>get_inline_handlers()</code> возвращает список <code>{action, handler}</code>.
- Диалоги привязаны к <code>chat_id</code>, позволяя параллельные сессии.</p>
<h3 id="_109">Диалоговые шаги</h3>
<p>Определяются в <code>dialog_steps()</code> как словарь или callable. Каждый шаг может содержать:
- <code>"message"</code> — обработчик текстового ввода.
- <code>"callback"</code> — обработчик колбэк-кнопок.</p>
<p>Управление:
- <code>start_dialog(chat_id)</code> — запуск диалога.
- <code>set_step(chat_id, step_name)</code> — переход к шагу.
- <code>end_dialog(chat_id)</code> — завершение.</p>
<p>Таймаут неактивности — <code>DIALOG_TIMEOUT</code> (по умолчанию 300 сек), сбрасывается при <code>set_step()</code>.</p>
<h2 id="callback-">Callback-система</h2>
<p>Единая маршрутизация через <code>_dispatch_callback</code>, проверяющая активность агента. Поддерживаемые типы кнопок:</p>
<table>
<thead>
<tr>
<th>Тип</th>
<th>Формат <code>callback_data</code></th>
<th>Назначение</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dlg:</code></td>
<td><code>dlg:{plugin_id}:{payload}</code></td>
<td>Кнопки внутри диалога</td>
</tr>
<tr>
<td><code>cb:</code></td>
<td><code>cb:{plugin_id}:{action}:{payload?}</code></td>
<td>Автономные действия</td>
</tr>
<tr>
<td><code>dlg_cancel:</code></td>
<td><code>dlg_cancel:{plugin_id}</code></td>
<td>Отмена диалога</td>
</tr>
</tbody>
</table>
<h3 id="_110">Вспомогательные методы</h3>
<ul>
<li><code>dialog_button(label, payload)</code> — кнопка в диалоге.</li>
<li><code>action_button(label, action, payload=None)</code> — автономная кнопка.</li>
<li><code>cancel_markup()</code> — готовая кнопка «Отмена».</li>
<li><code>parse_callback_payload(update)</code> — извлечение <code>payload</code> из <code>callback_data</code>.</li>
</ul>
<p>Регистрация: все колбэки объединяются в один <code>CallbackQueryHandler</code> через <code>_dialog_callback_commands()</code>, возвращаемый из <code>get_commands()</code>.</p>
<h2 id="_111">Меню и команды</h2>
<ul>
<li><code>get_menu_label()</code> — метка верхнего уровня меню.</li>
<li><code>get_menu_actions()</code> — список действий (метка + action).</li>
<li>Команды Telegram: определяются в <code>get_commands()</code>.</li>
</ul>
<h2 id="_112">Обработка ввода</h2>
<ul>
<li>Перехват сообщений при активном диалоге.</li>
<li>Автоотмена при вводе слов из <code>CANCEL_WORDS</code>.</li>
<li>Поддержка медиа и других типов — через <code>extra_message_filters()</code>.</li>
<li>Подсказки для шагов — <code>step_hint(step)</code>.</li>
</ul>
<h2 id="_113">Жизненный цикл и интеграция</h2>
<ul>
<li>Инициализация: <code>initialize(config, services)</code>.</li>
<li>Завершение: <code>close()</code>.</li>
<li>Доступ к сервисам: <code>services.config</code>, <code>pending_questions</code>, <code>task_store</code>, <code>scheduler_tasks</code>, <code>user_tasks</code> и др.</li>
<li>Автоматическая очистка диалогов при смене/закрытии сессии или отключении агента.</li>
</ul>
<h2 id="_114">Регистрация плагинов</h2>
<ul>
<li>Автоматическая загрузка из <code>agent/plugins/</code> (исключая <code>__init__.py</code>, <code>base.py</code>).</li>
<li>Имена инструментов: <code>{function_prefix}.{spec.name}</code>.</li>
</ul>
<h2 id="_115">Рекомендации</h2>
<ul>
<li>Обрабатывайте ошибки в <code>execute()</code> локально, возвращая структурированный ответ.</li>
<li>Для длительных операций увеличьте <code>DIALOG_TIMEOUT</code>.</li>
<li>Плагин не должен напрямую зависеть от <code>bot.py</code> — используйте абстракции <code>ToolPlugin</code>.</li>
</ul>
<h2 id="_116">Пример функциональности</h2>
<p>Плагин с двухуровневым меню:
1. Запуск диалога → выбор режима (<code>fast</code>/<code>detailed</code>) → ввод текста → преобразование в верхний регистр.
2. Показ информации.</p>
<p>Обработчики: <code>_cb_start</code>, <code>_cb_info</code>, <code>_on_mode_button</code>, <code>_on_mode_text</code>, <code>_on_input</code>.</p>
<h1 id="taskmanagementtool-telegram-">TaskManagementTool — Управление задачами в Telegram-боте</h1>
<h2 id="_117">Назначение</h2>
<p>Инструмент для управления задачами в Telegram-боте с поддержкой создания, просмотра, обновления и удаления задач. Реализует приоритеты, статусы, дедлайны, теги и уведомления. Данные хранятся в JSON-файле <code>tasks.json</code> в директории <code>_shared</code> (определяется через <code>AGENT_SANDBOX_ROOT</code> или fallback в текущую).</p>
<h2 id="_118">Ключевые сущности</h2>
<ul>
<li><strong><code>TaskManagementTool</code></strong> — основной класс, наследующий <code>DialogMixin</code> и <code>ToolPlugin</code>.</li>
<li><strong>Задача</strong> — содержит:</li>
<li><code>task_id</code>: уникальный ID (на основе временной метки и UUID)</li>
<li><code>title</code>, <code>description</code> (опционально)</li>
<li><code>priority</code>: high / medium / low</li>
<li><code>status</code>: pending / in_progress / completed / cancelled</li>
<li><code>deadline</code>: строка в формате "YYYY-MM-DD HH:MM"</li>
<li><code>deadline_ts</code>: Unix-время дедлайна</li>
<li><code>last_updated</code>: временная метка последнего изменения</li>
<li><code>notify</code>: флаги уведомлений</li>
<li><strong>Хранение</strong>: вложенный словарь <code>{user_id: {task_id: task_data}}</code>, где <code>user_id</code> — фактически <code>chat_id</code>.</li>
</ul>
<h2 id="_119">Функциональность</h2>
<ul>
<li><strong>Операции</strong>:</li>
<li><code>create</code>: создание задачи (с парсингом приоритета, дедлайна и заголовка)</li>
<li><code>list</code>: вывод до 50 задач, отсортированных по статусу, дедлайну и приоритету</li>
<li><code>update</code>: изменение полей задачи</li>
<li><code>delete</code>: удаление по <code>task_id</code></li>
<li><strong>Диалоговый ввод</strong>: состояние <code>wait_text</code> для добавления задачи, отмена через команды: <code>отмена</code>, <code>cancel</code>, <code>выход</code>, <code>-</code>.</li>
<li><strong>Интерфейс</strong>: формируется через <code>_build_tasks_menu</code> (до 12 задач с кнопками). Поддержка callback-команд: <code>add</code>, <code>refresh</code>, <code>view</code>, <code>del</code>, <code>next</code>, <code>view_help</code>.</li>
</ul>
<h2 id="_notifypolicy">Настройки уведомлений (<code>_NotifyPolicy</code>)</h2>
<ul>
<li><code>due_soon_window_sec</code>: интервал для уведомления о скором дедлайне</li>
<li><code>overdue_repeat_sec</code>: минимальный интервал между повторами уведомлений о просрочке</li>
<li><code>check_interval_sec</code>: частота проверки дедлайнов (реализована в <code>bot.py</code>)</li>
<li>Уведомления отправляются однократно при входе в "скоро истекает" и с повтором при просрочке.</li>
</ul>
<h2 id="_120">Технические особенности</h2>
<ul>
<li>Все операции — асинхронные, совместимы с <code>telegram.ext</code>.</li>
<li>Валидация: формат дедлайна, допустимые значения приоритета и статуса.</li>
<li>Автогенерация <code>task_id</code>.</li>
<li>Изоляция данных по <code>user_id</code>.</li>
<li>Вспомогательные функции: <code>_load_all_tasks</code>, <code>_save_all_tasks</code>.</li>
<li>Логирование ошибок при работе с файлом.</li>
</ul>
<p>Инструмент <code>MovieInfoTool</code> предоставляет доступ к информации о фильмах через API The Movie Database (TMDb). Поддерживает два действия: получение фильмов, текущих в прокате (<code>now_playing</code>), и поиск фильмов по критериям (<code>discover</code>) с возможностью фильтрации по жанру. </p>
<p>Ключевые параметры:
- <code>action</code> (обязательный): тип запроса — <code>now_playing</code> или <code>discover</code>.
- <code>genre_id</code>: идентификатор жанра TMDb для фильтрации.
- <code>count</code>: количество возвращаемых фильмов (от 1 до 30, по умолчанию 10).
- <code>language</code>: язык локализации (по умолчанию <code>ru-RU</code>).
- <code>region</code>: регион для фильтрации проката (по умолчанию <code>RU</code>).</p>
<p>Требует наличие переменной окружения <code>TMDB_API_KEY</code>. Запросы к API выполняются синхронно в отдельном потоке. Результат включает название, дату выхода, рейтинг и краткое описание фильма (обрезанное до 200 символов). Вывод автоматически обрезается для соответствия ограничениям системы. Инструмент поддерживает параллельное выполнение и имеет таймаут 60 секунд.</p>
<p>Инструмент <code>delete_file</code> предназначен для удаления файлов в пределах рабочей директории. Является частью системы плагинов инструментов агента и реализует интерфейс <code>ToolPlugin</code>. Основное назначение — безопасное удаление файлов с проверкой на принадлежность рабочему пространству.</p>
<p>Ключевые сущности:
- <code>ToolSpec</code> — описание инструмента, включая имя, описание и параметры.
- <code>helpers._resolve_within_workspace</code> — проверяет и разрешает путь внутри рабочей директории.
- <code>helpers._is_other_user_workspace</code> — блокирует доступ к файлам из чужого рабочего пространства.</p>
<p>Параметры:
- <code>path</code> (обязательный) — путь к удаляемому файлу, относительный или абсолютный, но должен находиться в workspace.</p>
<p>Особенности:
- Удаление возможно только для файлов, находящихся в текущей рабочей директории (<code>cwd</code>).
- При отсутствии файла возвращается ошибка "File not found".
- Попытка удалить файл вне workspace или в чужом workspace блокируется.
- В случае успеха возвращается сообщение <code>Deleted: &lt;path&gt;</code>, иначе — описание ошибки.</p>
<p>Инструмент <code>search_web</code> предназначен для выполнения поисковых запросов в интернете. Используется для получения актуальной информации: новости, текущие события, определения, цены, погода и другая внешняя информация. Ключевая сущность — класс <code>SearchWebTool</code>, наследующий <code>ToolPlugin</code>. Основные параметры: <code>name</code>, <code>description</code>, <code>parameters</code> (с обязательным полем <code>query</code> типа строка). Уровень риска — средний (<code>medium</code>). Выполнение делегируется вспомогательной функции <code>search_web_impl</code>, которая использует переданный <code>config</code> для настройки поиска. Требует наличия параметра <code>query</code> в аргументах.</p>
<h1 id="haiper-image-to-video-tool">Haiper Image-to-Video Tool — Краткое резюме</h1>
<p><strong>Назначение</strong><br/>
Инструмент для преобразования изображения в видео с использованием внешнего API <code>api.vsegpt.ru</code>. Позволяет пользователям через Telegram загружать изображение, задавать текстовый промпт анимации и получать готовое видео в формате MP4.</p>
<p><strong>Ключевые возможности</strong>
- Поддержка загрузки изображений: как фото, так и документы в Telegram.
- Пошаговый диалог через <code>DialogMixin</code>:<br/>
  - <code>wait_image</code> — ожидание изображения.<br/>
  - <code>wait_prompt</code> — ввод текстового описания анимации.
- Автоматическое определение расширения и кодирование изображения в base64.
- Генерация видео через API <code>https://api.vsegpt.ru/v1/video</code> с опросом статуса каждые 10 секунд.
- Отправка результата пользователю как документа в Telegram.</p>
<p><strong>Основные сущности</strong>
- <code>HaiperImageToVideoTool</code>: основной класс, реализует <code>ToolPlugin</code> и <code>DialogMixin</code>.
- Временные файлы хранятся в <code>_shared/haiper/&lt;chat_id&gt;</code> или <code>/tmp/video_generation</code>.</p>
<p><strong>Параметры</strong>
- <code>image_path</code> — путь к изображению (обязательный, JPG/PNG).
- <code>prompt</code> — описание анимации (опционально, по умолчанию: "animate image").
- <code>model</code> / <code>model_id</code> — версия модели (по умолчанию: <code>haiper-2.0</code>).
- <code>aspect_ratio</code> — фиксировано <code>16:9</code>.</p>
<p><strong>Настройки</strong>
- <code>API_URL</code>: <code>https://api.vsegpt.ru/v1/video</code>
- <code>DIALOG_TIMEOUT</code>: 1 час (учитывает длительность генерации).
- <code>AGENT_SANDBOX_ROOT</code>: корень для временных файлов (по умолчанию — текущая директория).
- <code>ZAI_API_KEY</code>: API-ключ (обязателен, передаётся через окружение или конфиг).</p>
<p><strong>Процесс работы</strong>
1. Проверка и разрешение пути к изображению.
2. Кодирование изображения в base64.
3. POST-запрос на <code>/generate</code> для запуска генерации.
4. Опрос <code>/status</code> каждые 10 секунд (до 45 минут).
5. Скачивание MP4 при успехе.
6. Сохранение и возврат пути к видео.</p>
<p><strong>Таймауты</strong>
- Генерация: до 45 минут.
- HTTP-таймауты: 60 сек (генерация), 30 сек (статус), 120 сек (скачивание).</p>
<p><strong>Обработка ошибок</strong>
- Полная обработка на всех этапах: загрузка, генерация, отправка.
- При ошибках возвращается словарь: <code>{"success": false, "error": "описание"}</code>.</p>
<p><strong>Особенности</strong>
- Асинхронный вызов с синхронным выполнением в отдельном потоке.
- Поддержка интеграции в агентские системы с песочницей.</p>
<p>Инструмент <code>run_command</code> предназначен для выполнения shell-команд в рамках рабочей среды агента. Поддерживает операции с системой, пакетными менеджерами (git, npm, pip) и другими CLI-инструментами. Имеет встроенные механизмы безопасности.</p>
<p>Ключевые сущности:
- <code>ToolPlugin</code> — базовый класс плагина.
- <code>ToolSpec</code> — описание инструмента: имя, параметры, уровень риска.
- <code>helpers</code> — вспомогательные функции проверки и выполнения команд.</p>
<p>Основные параметры:
- <code>command</code> (обязательный) — строка с командой для выполнения.</p>
<p>Уровень риска: <code>high</code>. Не поддерживает параллельное выполнение (<code>parallelizable=False</code>).</p>
<p>Важные проверки:
- Изоляция рабочей области (<code>_check_workspace_isolation</code>).
- Попытка выхода за пределы рабочей директории (<code>_check_command_path_escape</code>).
- Анализ опасности команды (<code>check_command</code>) — блокировка или запрос подтверждения для <code>rm -rf</code>, <code>sudo</code> и аналогичных.</p>
<p>Если команда потенциально опасна, но не заблокирована — требуется подтверждение пользователя через callback <code>_APPROVAL_CALLBACK</code>. Выполнение откладывается до получения подтверждения.</p>
<p>Результат выполнения — словарь с полями <code>success</code>, <code>output</code>/<code>error</code>, при необходимости — флаг <code>approval_required</code>.</p>
<p>Инструмент <code>edit_file</code> позволяет редактировать файлы путём точной замены текста. Требует указания пути к файлу, текста для поиска (<code>old_text</code>) и нового текста (<code>new_text</code>). Перед редактированием выполняется ряд проверок безопасности: доступ к рабочей области, чувствительные файлы, символические ссылки, а также анализ на наличие опасного кода в новом содержимом. Поддерживает работу только в пределах рабочей директории (<code>cwd</code>), указанной в контексте. Файл должен существовать, а <code>old_text</code> — присутствовать в нём дословно. В случае успеха возвращается подтверждение, при ошибках — детализированное сообщение с возможным превью содержимого.</p>
<h1 id="_121">Краткое резюме</h1>
<p>Данный документ представляет собой техническую документацию, объединяющую несколько частей, описывающих архитектуру, функциональность и использование системы. В документации рассматриваются основные компоненты системы, их взаимодействие, интерфейсы и процессы. Описаны требования, принципы работы, примеры использования и рекомендации по интеграции. Документ предназначен для разработчиков, инженеров и технических специалистов, обеспечивающих развертывание и сопровождение решения.</p>
<p>Плагин инструмента для оптимизации пользовательских промптов с использованием модели OpenAI. Назначение — улучшение формулировки исходного запроса для повышения точности и качества ответов модели. Основная сущность — класс <code>PromptPerfectTool</code>, реализующий интерфейс <code>ToolPlugin</code>.</p>
<p>Ключевые параметры инструмента:
- <code>original_prompt</code> (обязательный) — исходный текст промпта, который необходимо оптимизировать.
- <code>context</code> (опциональный) — дополнительный контекст, уточняющий задачу.</p>
<p>Инструмент использует настройки из переменных окружения или конфигурации:
- <code>OPENAI_API_KEY</code> — API-ключ для доступа к OpenAI (обязателен).
- <code>OPENAI_BASE_URL</code> — базовый URL для API (опционально, используется при работе с прокси или локальными эндпоинтами).
- <code>OPENAI_MODEL</code> — модель для оптимизации (по умолчанию <code>gpt-4o-mini</code>).</p>
<p>В процессе выполнения формируется системное сообщение с инструкцией по улучшению промпта, после чего запрос отправляется в модель. Результат — оптимизированный промпт, возвращаемый в поле <code>output</code>. При ошибках возвращается флаг <code>success: False</code> и описание проблемы.</p>
<p>Инструмент <code>auto_tts</code> для генерации аудио из текста с использованием OpenAI TTS. Позволяет озвучивать текст с выбором голоса, модели, формата вывода и дополнительных инструкций. Результат — путь к сохранённому аудиофайлу в формате mp3, opus, aac, flac, wav или pcm.</p>
<p>Ключевые параметры:
- <code>text</code> — текст для озвучивания (обязательный)
- <code>voice</code> — голос (допустимые значения: alloy, ash, ballad, coral, echo, sage, shimmer, verse, marin, cedar; по умолчанию: alloy)
- <code>model</code> — модель TTS (по умолчанию: gpt-4o-mini-tts)
- <code>response_format</code> — формат аудиофайла (по умолчанию: mp3)
- <code>instructions</code> — дополнительные инструкции для голоса (опционально)</p>
<p>Требует наличие <code>OPENAI_API_KEY</code> в переменных окружения или в конфигурации. Базовый URL для OpenAI может быть задан через <code>OPENAI_BASE_URL</code>. Аудиофайлы сохраняются во временной директории <code>/tmp/tts</code> (или аналоге для ОС). Инструмент поддерживает параллельное выполнение и имеет таймаут 120 секунд.</p>
<p>Инструмент для генерации изображений по текстовому промпту с использованием HuggingFace Inference API. Реализован как плагин <code>ToolPlugin</code> и предоставляет методы для асинхронного выполнения через <code>execute</code>. Основан на модели Stable Diffusion, поддерживает указание кастомной модели через параметр <code>model</code> (по умолчанию — <code>HiDream-ai/HiDream-I1-Full</code>).</p>
<p>Ключевые параметры:
- <code>prompt</code> (обязательный) — текстовое описание изображения.
- <code>model</code> (опциональный) — идентификатор модели в репозитории HuggingFace.</p>
<p>Для работы требуется токен аутентификации в переменной окружения <code>STABLE_DIFFUSION_TOKEN</code>. Изображение сохраняется во временной директории <code>/tmp/image_generation</code> (или аналоге для ОС) с расширением <code>.png</code>, возвращается путь к файлу.</p>
<p>При первой генерации для "холодной" модели выполняется повторный запрос. Таймаут операции — 300 секунд. Ошибки логируются, возвращаются в виде словаря с <code>success=False</code> и описанием проблемы.</p>
<p>Плагин инструмента для делегирования сложных задач во внешний CLI-интерфейс (например, codex/gemini/claude code). Используется, когда задача требует полноценного цикла разработки или выходит за рамки возможностей стандартных инструментов. Основная сущность — <code>UseCliTool</code>, реализующая интерфейс <code>ToolPlugin</code>. Ключевой параметр выполнения — <code>task_text</code>, содержащий описание задачи. Для работы требуется активная сессия CLI, передаваемая через контекст (<code>ctx["session"]</code>). В случае успеха возвращает обрезанный вывод сессии, в случае ошибки — сообщение об ошибке. Вывод очищается от ANSI-кодов.</p>
<h1 id="reminderstool-telegram-">RemindersTool — Управление напоминаниями в Telegram-боте</h1>
<h2 id="_122">Назначение</h2>
<p>Инструмент <code>RemindersTool</code> предоставляет функциональность создания, просмотра и удаления пользовательских напоминаний через Telegram-бота. Работает в связке с системой диалогов и обработки callback-запросов.</p>
<h2 id="_123">Основные возможности</h2>
<ul>
<li><strong>Создание напоминаний</strong> по формату <code>ГГГГ-ММ-ДД ЧЧ:ММ текст</code></li>
<li><strong>Просмотр списка</strong> активных напоминаний с отображением времени выполнения и оставшегося времени</li>
<li><strong>Удаление</strong> напоминаний по ID с проверкой принадлежности</li>
<li>Поддержка интерактивного интерфейса: кнопки, диалоги, клавиатуры</li>
</ul>
<h2 id="_124">Ключевые сущности</h2>
<ul>
<li><code>reminder_id</code> — уникальный идентификатор напоминания</li>
<li><code>services["scheduler_tasks"]</code> — хранилище задач с деталями выполнения</li>
<li><code>services["user_tasks"]</code> — привязка пользователей к их активным напоминаниям</li>
</ul>
<h2 id="execute">Поддерживаемые действия (<code>execute</code>)</h2>
<ul>
<li><code>set</code> — запуск диалога создания напоминания</li>
<li><code>list</code> — отображение списка активных напоминаний</li>
<li><code>delete</code> — удаление по ID</li>
<li><code>view</code>, <code>close_menu</code> — вспомогательные действия для интерфейса</li>
</ul>
<h2 id="_125">Ограничения</h2>
<ul>
<li>Макс. длительность напоминания: <strong>24 часа (86400 сек)</strong></li>
<li>Макс. количество на пользователя: <strong>5 активных напоминаний</strong></li>
<li>Формат времени: строго <code>YYYY-MM-DD HH:MM</code></li>
<li>Отмена ввода: команды <code>отмена</code>, <code>cancel</code>, <code>выход</code>, <code>-</code></li>
</ul>
<h2 id="_126">Технические особенности</h2>
<ul>
<li>Использует <code>DialogMixin</code> для пошагового ввода</li>
<li>Асинхронное выполнение через <code>asyncio.create_task</code></li>
<li>Автоматическая очистка после срабатывания</li>
<li>Отправка уведомлений через <code>bot._send_message</code></li>
<li>Таймаут инструмента: <strong>30 секунд</strong></li>
<li>Не поддерживает параллельное выполнение (<code>parallelizable=False</code>)</li>
</ul>
<h2 id="_127">Интеграция</h2>
<ul>
<li>Доступ через меню: "Напоминания" → "Список", "Создать"</li>
<li>Callback-действия: <code>list</code>, <code>set</code>, <code>delete</code>, <code>view</code>, <code>close_menu</code></li>
<li>Динамическое обновление времени в описании инструмента</li>
</ul>
<p>Инструмент <code>write_file</code> предназначен для создания или перезаписи файлов в рабочей директории агента. Обеспечивает безопасную запись с проверкой пути и содержимого. Поддерживает разрешение путей относительно рабочей директории (<code>cwd</code>), блокирует запись в чувствительные файлы, чужие рабочие пространства и при обнаружении символических ссылок, ведущих за пределы workspace. Проверяет содержимое на наличие потенциально опасного кода (например, утечки секретов). Требует параметры <code>path</code> и <code>content</code>. При успешной записи возвращает количество записанных байт. Все операции логируются, ошибки обрабатываются с безопасным возвратом.</p>
<p>Инструмент <code>search_files</code> предназначен для поиска файлов в проекте с использованием glob-шаблонов. Позволяет агенту исследовать структуру проекта, находя файлы по заданному пути с поддержкой рекурсии (<code>**</code>).  </p>
<p>Ключевые параметры:
- <code>pattern</code> — строка с glob-шаблоном (например, <code>**/*.ts</code>, <code>src/**/*.js</code>), обязательный параметр.</p>
<p>Особенности реализации:
- Запрещены шаблоны с выходом за пределы рабочей директории (<code>..</code>) во избежание path traversal.
- Поиск ограничен текущей рабочей директорией (<code>ctx["cwd"]</code>), проверяется через <code>realpath</code>.
- Исключаются пути внутри <code>node_modules</code> и <code>.git</code>.
- Пропускаются директории — в результат попадают только файлы.
- Максимальное количество возвращаемых файлов — 200.
- В случае ошибки возвращается сообщение об ошибке, исключения логируются.</p>
<p>Возвращаемый результат:
- При успехе: <code>{"success": True, "output": "список файлов через \\n"}</code>.
- При ошибке: <code>{"success": False, "error": "описание ошибки"}</code>.</p>
<p>Плагин инструмента для извлечения и парсинга содержимого веб-страницы по заданному URL. Возвращает очищенный текст в формате Markdown. Основан на базовом классе <code>ToolPlugin</code> и реализует методы <code>get_spec</code> и <code>execute</code>. </p>
<p>Ключевая сущность — <code>FetchPageTool</code>, предоставляющий спецификацию инструмента с именем <code>fetch_page</code>, обязательным параметром <code>url</code> (строка) и уровнем риска <code>medium</code>. Выполнение делегирует функции <code>fetch_page_impl</code> из модуля <code>helpers</code>, передавая URL и конфигурацию инструмента. Требует корректной настройки <code>self.config</code> для работы (например, таймауты, заголовки, политики доступа). Используется в агентских сценариях, где необходима загрузка внешнего контента.</p>
<p>Инструмент для извлечения и очистки текстового содержимого веб-страниц по заданному URL. Использует внешний сервис <a href="https://r.jina.ai">r.jina.ai</a> для получения основного текста без HTML-разметки. В случае недоступности Jina применяется fallback-запрос напрямую к URL.</p>
<p><strong>Ключевые параметры:</strong>
- <code>url</code> (обязательный) — адрес целевой страницы.
- <code>max_chars</code> (опциональный, по умолчанию 6000, ограничение от 500 до 20000) — максимальное количество символов в ответе.</p>
<p><strong>Особенности:</strong>
- Выполняется асинхронно с использованием <code>asyncio.to_thread</code> для синхронных HTTP-запросов.
- Автоматически обрезает вывод с помощью <code>helpers._trim_output</code>.
- При ошибках возвращает структурированную информацию с флагом <code>success: False</code>.
- Поддерживает параллельное выполнение.
- Таймаут операции — 60 секунд.</p>
<p><strong>Зависимости:</strong> <code>requests</code>, внешний API <code>r.jina.ai</code>.</p>
<p>Инструмент для извлечения субтитров с YouTube-видео по его <code>video_id</code>. Поддерживает выбор языка и автоматическое определение доступных транскрипций (ручные, сгенерированные). Использует библиотеку <code>youtube-transcript-api</code>, которая должна быть установлена.</p>
<p>Ключевые параметры:
- <code>video_id</code> (обязательный) — идентификатор видео на YouTube.
- <code>languages</code> — приоритетный список языков (по умолчанию <code>['ru', 'en']</code>).</p>
<p>Инструмент пытается найти транскрипцию в порядке: ручная → автоматическая → любая доступная. Возвращает текст субтитров с указанием языка и типа (ручной/автогенерированный). Поддерживает выполнение в параллельных потоках и имеет таймаут 60 секунд. Ошибки логируются, пустой или отсутствующий <code>video_id</code> приводит к ошибке выполнения.</p>
<h1 id="webresearchtool">WebResearchTool — Краткое резюме</h1>
<p>Плагин <code>WebResearchTool</code> предназначен для проведения асинхронных мультиязычных веб-исследований (поддержка: русский, английский, китайский). На основе пользовательского запроса генерирует уточнённые поисковые фразы с помощью OpenAI, находит релевантные ссылки через Jina AI Search API и при необходимости анализирует их содержимое с использованием LLM.</p>
<h2 id="_128">Основные возможности</h2>
<ul>
<li><strong>Генерация поисковых запросов</strong>: до 5 уточнённых фраз на каждом языке с помощью OpenAI.</li>
<li><strong>Поиск статей</strong>: через Jina AI (<code>s.jina.ai</code>) с поддержкой языков и ограничением результатов (<code>max_results_per_lang</code>, по умолчанию 10).</li>
<li><strong>Загрузка и очистка контента</strong>: асинхронное извлечение текста из HTML/PDF с использованием:</li>
<li><code>trafilatura</code> (основной),</li>
<li><code>BeautifulSoup</code> (fallback),</li>
<li>Jina Reader API (<code>r.jina.ai</code>) — резервный метод.</li>
<li><strong>Анализ содержимого</strong>: агрегация и обработка текста через большую языковую модель (LLM) для формирования структурированного ответа с указанием источников.</li>
<li><strong>Автоматическое определение языка</strong>, типа контента и очистка URL.</li>
</ul>
<h2 id="_129">Ключевые методы</h2>
<ul>
<li><code>_generate_search_queries_lang</code>: генерация поисковых запросов на заданном языке.</li>
<li><code>_find_articles_for_language</code>: параллельный поиск по языку с round-robin объединением результатов.</li>
<li><code>_download_content</code>: загрузка и очистка контента с поддержкой таймаутов, редиректов и сжатия.</li>
<li><code>_analyze_content_with_llm</code>: анализ агрегированного текста с помощью LLM.</li>
<li><code>execute</code>: основной метод, координирующий весь процесс.</li>
</ul>
<h2 id="_130">Настройки</h2>
<ul>
<li>Обязательные: <code>JINA_API_KEY</code>, <code>OPENAI_API_KEY</code>.</li>
<li>Опциональные: <code>OPENAI_BASE_URL</code>, <code>OPENAI_MODEL</code>, <code>OPENAI_BIG_MODEL</code>.</li>
<li>Таймауты: 20 сек (загрузка), 30 сек (Jina API).</li>
<li>Поддержка кастомных заголовков, логирования, fallback-механизмов при ошибках.</li>
</ul>
<h2 id="_131">Результат</h2>
<ul>
<li>Список релевантных ссылок по языкам.</li>
<li>Опционально — аналитическое резюме с источниками.</li>
<li>Отчёт о выполнении (найдено/загружено статей), обработка ошибок на всех этапах.</li>
</ul>
<p>Плагин устойчив к частичным сбоям и обеспечивает высокую точность и читаемость результатов.</p>
<p>Инструмент <code>schedule_task</code> позволяет планировать напоминания или выполнение команд с задержкой. Поддерживает три действия: добавление задачи, просмотр списка задач пользователя и отмену задачи по ID. Максимальная задержка — 24 часа, максимум 5 задач на пользователя.</p>
<p>Ключевые параметры:
- <code>action</code>: действие (<code>add</code>, <code>list</code>, <code>cancel</code>)
- <code>type</code>: тип задачи (<code>message</code> — напоминание, <code>command</code> — выполнение shell-команды)
- <code>content</code>: текст напоминания или команда для выполнения
- <code>delay_minutes</code>: задержка в минутах (1–1440)
- <code>task_id</code>: идентификатор задачи (требуется для отмены)</p>
<p>Задачи хранятся во внутренних хранилищах <code>scheduler_tasks</code> (по ID) и <code>user_tasks</code> (по пользователю). При срабатывании отправляется сообщение через бота. Команды выполняются через <code>helpers.execute_shell_command</code> с ограничением вывода до 500 символов. Задачи удаляются из хранилища после выполнения или отмены.</p>
<p>Файл реализует инструмент долговременной памяти для агента, позволяющий сохранять, читать и очищать текстовые записи с автоматическим добавлением временных меток. Предназначен для хранения важной информации: контекста проекта, решений, задач и т.п. — с сохранением между сессиями.</p>
<p>Ключевые сущности: <code>MemoryTool</code> — основной класс, наследующий <code>DialogMixin</code> и <code>ToolPlugin</code>, обеспечивает интеграцию с интерфейсом агента и диалоговым взаимодействием. Поддерживает три действия: <code>read</code>, <code>append</code>, <code>clear</code>.</p>
<p>Основные настройки и параметры:
- <code>MEMORY_FILE</code> — имя файла для хранения памяти (определяется в <code>tooling.helpers</code>).
- Путь к файлу памяти формируется на основе <code>config.defaults.workdir</code> или переменной окружения <code>AGENT_SANDBOX_ROOT</code>.
- Файл создаётся в подкаталоге <code>_sandbox</code> рабочей директории.</p>
<p>Интерфейс:
- В меню доступны действия: «Показать», «Добавить запись», «Очистить».
- Поддержка команд через диалоговый интерфейс и API агента.
- При добавлении записи запрашивается текст через диалог; отмена возможна по ключевым словам.</p>
<p>API-метод <code>execute</code> позволяет использовать инструмент в автоматизированных сценариях с параметрами:
- <code>action</code> (обязательный): <code>read</code>, <code>append</code>, <code>clear</code>.
- <code>content</code>: текст для добавления (только для <code>append</code>).</p>
<p>Файл обеспечивает отказоустойчивое чтение и запись с обработкой ошибок, поддерживает русский интерфейс и ограничение длины вывода (до 3500 символов).</p>
<p>Инструмент <code>ChiefTool</code> предоставляет доступ к поиску рецептов через API Edamam по заданным ингредиентам или запросу. Поддерживает асинхронное выполнение и параллельный запуск. Для работы требует переменные окружения <code>EDAMAM_APP_ID</code> и <code>EDAMAM_APP_KEY</code>. Основной метод <code>execute</code> принимает параметры <code>query</code> (обязательный) и <code>count</code> (необязательный, от 1 до 10), возвращает найденные рецепты с названием, источником и ссылкой. Поиск выполняется синхронно в отдельном потоке через <code>asyncio.to_thread</code>. Результаты обрезаются и форматируются с помощью вспомогательной функции <code>_trim_output</code>. Ключевые параметры: <code>query</code>, <code>count</code>, <code>app_id</code>, <code>app_key</code>, <code>timeout_ms=60000</code>.</p>
<p>Инструмент <code>manage_tasks</code> предназначен для управления списком задач в рамках сессии. Позволяет добавлять, обновлять, просматривать и очищать выполненные задачи, что полезно при планировании многоэтапных операций. Основные сущности — задачи с полями <code>id</code>, <code>content</code>, <code>status</code> и <code>created_at</code>. Задачи хранятся в <code>services.task_store</code> с привязкой к <code>session_id</code>.</p>
<p>Поддерживаемые действия:
- <code>add</code>: добавляет новые задачи или обновляет существующие по <code>id</code>.
- <code>update</code>: изменяет поля <code>content</code> или <code>status</code> у существующих задач.
- <code>list</code>: возвращает отформатированный список всех задач текущей сессии.
- <code>clear</code>: удаляет задачи со статусами <code>completed</code> или <code>cancelled</code>.</p>
<p>Ключевые параметры в <code>args</code>: <code>action</code> (обязательный), <code>tasks</code> (массив задач). Каждая задача должна содержать <code>id</code> и <code>content</code>. Статус по умолчанию — <code>pending</code>. Результат выполнения включает флаг <code>success</code> и поле <code>output</code> с данными или сообщением. Инструмент не поддерживает параллельное выполнение.</p>
<p>Инструмент <code>GTTSTextToSpeechTool</code> реализует генерацию аудио из текста с использованием сервиса Google Text-to-Speech (gTTS). Является плагином инструмента для агента, позволяет асинхронно озвучивать текст на указанном языке и возвращать путь к сохранённому MP3-файлу.</p>
<p>Ключевые сущности:
- <code>get_spec</code> — определяет интерфейс инструмента: имя <code>gtts_text_to_speech</code>, обязательный параметр <code>text</code>, опциональный <code>lang</code> (по умолчанию <code>ru</code>), формат вывода — путь к файлу.
- <code>execute</code> — асинхронно вызывает синхронную функцию озвучки в отдельном потоке, обрабатывает ошибки.
- <code>_tts_sync</code> — синхронная логика: генерация речи через <code>gTTS</code>, сохранение в временной директории <code>/tmp/tts</code> (или <code>temp</code> в Windows) с уникальным именем на основе timestamp.</p>
<p>Важные настройки:
- Таймаут выполнения — 90 секунд.
- Поддержка параллельного выполнения (<code>parallelizable=True</code>).
- Файлы сохраняются во временной директории ОС в подкаталоге <code>tts</code>.
- Требуется установленный пакет <code>gTTS</code> (<code>pip install gTTS</code>).</p>
<p>Клиент для взаимодействия с MCP (Model Control Protocol) через HTTP, использующий JSON-RPC 2.0 для обмена сообщениями. Предназначен для асинхронного вызова инструментов (tools), их перечисления и инициализации соединения с MCP-сервером.</p>
<p>Основные сущности:
- <code>HttpMCPClientConfig</code> — конфигурация клиента: имя, URL сервера, таймаут, заголовки и версия протокола.
- <code>HttpMCPClient</code> — основной класс клиента, реализующий логику соединения, отправки запросов и обработки ответов.</p>
<p>Ключевые методы:
- <code>start()</code> — инициализирует HTTP-клиент и выполняет <code>initialize</code> и <code>initialized</code> вызовы.
- <code>stop()</code> — закрывает соединение.
- <code>list_tools()</code> — возвращает список доступных инструментов с их описанием и схемой входных данных.
- <code>call_tool()</code> — вызывает указанный инструмент с заданными аргументами.</p>
<p>Особенности:
- Использует <code>httpx.AsyncClient</code> для асинхронных HTTP-запросов.
- Поддерживает JSON-RPC 2.0, включая уведомления (без <code>id</code>).
- Автоматически обрабатывает ошибки и пустые ответы.
- При инициализации отправляет <code>initialize</code> и <code>notifications/initialized</code>, что совместимо с MCP-шлюзом на <code>127.0.0.1:8888</code>.</p>
<p>Конфигурационные параметры (<code>HttpMCPClientConfig</code>):
- <code>name</code> — логическое имя клиента.
- <code>url</code> — адрес MCP-сервера.
- <code>timeout_ms</code> — таймаут запроса в миллисекундах (по умолчанию 30 000).
- <code>headers</code> — дополнительные HTTP-заголовки.
- <code>protocol_version</code> — версия MCP-протокола (по умолчанию "2024-11-05").</p>
<p>Клиент для взаимодействия с MCP (Model Control Protocol) сервером через стандартные потоки ввода-вывода. Реализует асинхронное взаимодействие по протоколу JSON-RPC, поддерживает инициализацию, вызов инструментов и получение списка доступных инструментов.</p>
<p>Основные сущности:
- <code>StdioMCPClient</code> — основной класс клиента, управляющий подключением к MCP-серверу, отправкой запросов и обработкой ответов.
- <code>MCPToolInfo</code> — дата-класс, описывающий метаданные инструмента: имя, описание и схему входных параметров.
- <code>JsonRpcStream</code> — обёртка для чтения/записи JSON-RPC сообщений через <code>stdin</code>/<code>stdout</code>.</p>
<p>Ключевые функции:
- <code>start()</code> — запускает процесс MCP-сервера и инициирует handshake (инициализацию).
- <code>stop()</code> — останавливает процесс и завершает соединение.
- <code>list_tools()</code> — возвращает список доступных инструментов.
- <code>call_tool()</code> — вызывает указанный инструмент с заданными аргументами.</p>
<p>Параметры инициализации:
- <code>name</code> — имя клиента (для логирования).
- <code>cmd</code> — команда для запуска MCP-сервера.
- <code>cwd</code> — рабочая директория процесса.
- <code>env</code> — переменные окружения.
- <code>timeout_ms</code> — таймаут ожидания ответа от сервера.
- <code>protocol_version</code> — версия MCP-протокола (по умолчанию "2024-11-05").</p>
<p>Внутренние механизмы:
- Используется <code>asyncio</code> для асинхронного обмена сообщениями.
- <code>_reader_loop</code> — фоновая задача, обрабатывающая входящие JSON-RPC сообщения.
- <code>_pending</code> — словарь ожидающих ответов, сопоставляющий <code>id</code> запроса с <code>Future</code>.
- <code>_lock</code> — обеспечивает потокобезопасность при генерации идентификаторов запросов.</p>
<p>Особенности:
- При неудачной инициализации клиент продолжает работу, полагая, что сервер может поддерживать базовые методы.
- Логирование ошибок выполняется через стандартный модуль <code>logging</code>.</p>
<p>Класс <code>JsonRpcStream</code> обеспечивает чтение и запись JSON-RPC сообщений с поддержкой двух форматов фрейминга: LSP-совместимого (на основе заголовка <code>Content-Length</code>) и NDJSON (по одному JSON-объекту на строку). Используется для обмена сообщениями в асинхронных клиент-серверных взаимодействиях, например, с Language Server Protocol.</p>
<p>Основные сущности:
- <code>reader</code> и <code>writer</code> — объекты <code>asyncio.StreamReader</code> и <code>asyncio.StreamWriter</code> для работы с потоком ввода-вывода.
- <code>write()</code> — отправляет JSON-объект, используя по умолчанию <code>Content-Length</code> фрейминг (если <code>prefer_content_length=True</code>), иначе — в формате NDJSON.
- <code>read()</code> — читает следующее сообщение, автоматически определяя формат по первому блоку данных: если строка начинается с <code>Content-Length:</code>, применяется LSP-фрейминг, иначе — ожидается NDJSON.</p>
<p>Ключевые особенности:
- При чтении <code>Content-Length</code> обрабатываются заголовки до пустой строки, затем читается тело указанной длины.
- Некорректные JSON-сообщения или заголовки игнорируются, возвращается <code>None</code>.
- Логирование ошибок парсинга выполняется через модуль <code>logging</code>.
- Функция <code>encode_content_length_message</code> формирует корректный заголовок <code>Content-Length</code> и тело сообщения в соответствии с LSP.</p>
<p>Модуль обеспечивает интеграцию MCP-клиента с внешними инструментальными серверами. Предназначен для управления подключением, отправки запросов и обработки ответов от внешних инструментов через MCP (Model Communication Protocol). Ключевые сущности включают клиентское соединение, обработчики инструментов и маршрутизацию запросов. Поддерживает настройку URL сервера, тайм-аутов соединения, аутентификации (при наличии) и списка доступных инструментов. Основные параметры: <code>server_url</code>, <code>timeout</code>, <code>headers</code>, <code>tools</code>. Используется для расширения функциональности системы за счёт внешних сервисов — например, баз данных, API или вычислительных модулей.</p>
<p>Класс <code>MCPManager</code> управляет подключением и взаимодействием с MCP-серверами (Model Control Protocol), обеспечивая запуск клиентов, кэширование инструментов и вызов методов. Поддерживает два типа транспорта: <code>stdio</code> и <code>http</code>. Инициализация клиентов происходит лениво и защищена блокировкой. Инструменты кэшируются в JSON-файле по пути <code>_shared/mcp_tools_cache.json</code> для ускорения последующих запусков. Методы <code>list_all_tools</code>, <code>call</code> и <code>build_registry_name</code> позволяют получать доступные инструменты, вызывать их и формировать имена, совместимые с ограничениями OpenAI. Ключевые параметры: <code>enabled</code>, <code>transport</code>, <code>cmd</code>, <code>url</code>, <code>timeout_ms</code>, <code>headers</code> — задаются через конфигурацию <code>AppConfig</code>.</p>
<p>Тест проверяет, что при отправке большого объёма вывода в HTML-формате корректно обрезается начало, а отправляется только конец (последние 10 000 символов). Используется заглушка <code>ansi_to_html</code> для фиксации переданной строки; ожидается, что ей будет передан хвост вывода (<code>tail</code>). Настройки теста включают временный каталог, конфигурацию бота с одним инструментом <code>dummy</code>, ограничение на длину вывода и моки для методов отправки сообщений и документов. Тест асинхронный, выполняется через <code>asyncio.run</code>.</p>
<p>Файл содержит модульные тесты для метода <code>_next_ready_task</code> класса <code>ManagerOrchestrator</code>, отвечающего за выбор следующей задачи для выполнения с учётом зависимостей, статусов, попыток и блокировок. Основное внимание уделено логике определения готовности задачи, нормализации статусов после перезапуска и каскадному блокированию зависимых задач.</p>
<p>Ключевые сущности: <code>DevTask</code>, <code>ProjectPlan</code>, <code>ManagerOrchestrator</code>.</p>
<p>Тестируемая логика включает:
- Выбор первой подходящей задачи из списка.
- Пропуск задач со статусом <code>approved</code>.
- Обработку зависимостей: задача становится готовой только после успешного завершения всех зависимостей.
- Каскадное блокирование задач при провале зависимостей (статус <code>blocked</code>).
- Нормализацию временных статусов (<code>in_progress</code>, <code>in_review</code>, <code>rejected</code>) в <code>pending</code> при условии, что количество попыток не исчерпано.
- Перевод задачи в статус <code>failed</code>, если количество попыток (<code>attempt</code>) достигло <code>max_attempts</code>.
- Корректное завершение плана, когда все задачи завершены или заблокированы.</p>
<p>Также проверяется вспомогательный метод <code>_is_plan_blocked</code>, определяющий, заблокирован ли весь план (нет ни одной готовой к выполнению задачи).</p>
<p>Тест-файл для проверки логики декомпозиции менеджера: разбор JSON, обработка fallback-сценариев и преобразование полезной нагрузки в план (<code>payload_to_plan</code>). Основные тестируемые компоненты:</p>
<ul>
<li><code>_extract_json_object</code> — извлекает JSON из строки, корректно обрабатывая Markdown-разметку (с указанием <code>json</code> или без), вложенные объекты, текст вокруг JSON и пустые/некорректные входные данные.</li>
<li><code>_truncate_report</code> — усекает длинные тексты до заданного лимита символов, добавляя уведомление об обрезке; корректно обрабатывает короткие, пустые и <code>None</code> значения.</li>
<li><code>_payload_to_plan</code> (через <code>ManagerOrchestrator._try_parse_plan</code>) — преобразует словарь в объект <code>ProjectPlan</code>, валидируя структуру, ограничивая количество задач (<code>max_tasks</code>), поддерживая альтернативные ключи (<code>analysis</code> и <code>project_analysis</code>) и возвращая <code>None</code> при отсутствии задач.</li>
</ul>
<p>Ключевые сущности: <code>ProjectPlan</code>, <code>DevTask</code>, <code>ManagerOrchestrator</code>.<br/>
Важные настройки (в <code>_FakeConfig</code>): <code>manager_max_tasks</code>, <code>manager_dev_report_max_chars</code>.<br/>
Тесты обеспечивают устойчивость к разнообразным входным форматам и граничным случаям.</p>
<p>Тестовый файл, проверяющий корректность работы агента в боте без отправки сообщений. Использует временные пути и моки для изоляции среды. Основная цель — убедиться, что при выполнении агента не происходит отправки сообщений через <code>_send_message</code> или <code>_send_document</code>, даже если агент возвращает финальный ответ.  </p>
<p>Конфигурация <code>AppConfig</code> инициализируется с минимальными параметрами: отключён MCP, заданы пути к рабочей директории и файлам состояния, определён инструмент <code>dummy</code> в режиме <code>headless</code>. Создаётся сессия с включённым агентом. Методы отправки сообщений заменяются моками через <code>monkeypatch</code>, а <code>agent.run</code> заменяется на заглушку, возвращающую тестовый текст.  </p>
<p>После вызова <code>app.run_agent</code> проверяется, что список <code>sent</code> остался пустым — подтверждение, что сообщения не отправлялись. Тест асинхронный, запускается через <code>asyncio.run</code>.</p>
<p>Тест проверяет корректность установки режима разметки и экранирования текста при отправке сообщений через метод <code>_send_message</code> в боте. Основное внимание уделено поведению при использовании MarkdownV2 (<code>md2=True</code>): проверяется, что параметр <code>parse_mode</code> устанавливается в <code>"MarkdownV2"</code>, а текст корректно форматируется. При отключённом <code>md2</code> режим разметки не должен передаваться. Используются временная директория (<code>tmp_path</code>) и моки для изоляции теста. Тест асинхронный, запускается через <code>asyncio.run</code>.</p>
<p>Тест-файл для проверки функциональности реестра инструментов и отдельных плагинов в агентской системе. Основное назначение — верификация корректной регистрации инструментов, выполнения их вызовов и защиты от ошибок в реализациях.  </p>
<p>Ключевые сущности: <code>ToolRegistry</code> — реестр инструментов, <code>search_web</code>, <code>run_command</code>, <code>CodeInterpreterTool</code> — примеры инструментов.  </p>
<p>Проверяются следующие аспекты:<br/>
- Имена инструментов регистрируются без префиксов (без точечной нотации).<br/>
- Вызов <code>search_web</code> корректно делегируется реализации через <code>helpers.search_web_impl</code> с передачей параметров.<br/>
- Метод <code>_static_block</code> в <code>CodeInterpreterTool</code> безопасен к выполнению и не вызывает исключений при обработке валидного кода.  </p>
<p>Используется <code>monkeypatch</code> для изоляции тестов и <code>asyncio.run</code> для синхронного выполнения асинхронных вызовов. Конфигурация загружается из <code>config_example.yaml</code> через <code>load_config</code>.</p>
<p>Тест-файл для проверки выбора модели в веб-исследовательском инструменте <code>WebResearchTool</code>. Проверяет приоритет настройки модели: переменная окружения <code>OPENAI_BIG_MODEL</code> имеет приоритет над значением из конфигурационного файла. Используются фикстуры <code>monkeypatch</code> для мокинга переменных окружения и загрузки конфигурации из <code>config_example.yaml</code>. Ключевые сущности: <code>WebResearchTool</code>, <code>load_config</code>, параметры <code>openai_big_model</code> и <code>big_model_to_use</code>. Тесты убеждаются, что метод <code>_get_model(big=True)</code> возвращает корректное имя модели в зависимости от контекста — конфиг или переменная окружения.</p>
<h1 id="orchestratorrunner">Резюме документации: Тестирование модуля <code>OrchestratorRunner</code></h1>
<p>Файл содержит модульные тесты для <code>OrchestratorRunner</code>, направленные на проверку корректности формирования и отправки финального ответа агентом. Основные аспекты:</p>
<ul>
<li><strong>Тестируемые функции</strong>:  </li>
<li>Формирование финального ответа с текстом "Готово".  </li>
<li>Вызов <code>send_output</code> с параметрами <code>force_html=True</code>, <code>send_header=False</code>.  </li>
<li>Неблокирующее выполнение <code>orchestrator.run</code> (проверка через таймаут).  </li>
<li>
<p>Отправка артефактов через <code>send_document</code> при наличии <code>file</code> в <code>ExecutorResponse</code>.</p>
</li>
<li>
<p><strong>Ключевые сущности</strong>:  </p>
</li>
<li><code>OrchestratorRunner</code> — основной тестируемый класс.  </li>
<li><code>ExecutorResponse</code>, <code>PlanStep</code> — данные, участвующие в обработке шагов.  </li>
<li>
<p><code>_FakeBot</code> — заглушка бота для имитации отправки сообщений.</p>
</li>
<li>
<p><strong>Тестовая инфраструктура</strong>:  </p>
</li>
<li>Используются <code>tmp_path</code> для изолированных временных файлов.  </li>
<li>Конфигурация инициализируется через <code>AppConfig</code> с указанием путей.  </li>
<li>
<p>Моки и заглушки:  </p>
<ul>
<li><code>_execute_step</code>, <code>_maybe_update_memory</code> — фиктивные реализации.  </li>
<li><code>chat_completion</code> — возвращает "FINAL".  </li>
</ul>
</li>
<li>
<p><strong>Сценарии</strong>:  </p>
</li>
<li>Запуск оркестратора с целевым назначением (например, Telegram).  </li>
<li>Проверка, что бот получил ожидаемые документы (включая <code>artifact_path</code>).  </li>
<li>Подтверждение ассертов по завершении теста.</li>
</ul>
<p>Тесты обеспечивают изолированное, неблокирующее и детерминированное выполнение с проверкой внешних взаимодействий.</p>
<p>Тест проверяет, что агент продолжает работу после единичного сбоя инструмента. Используется фиктивный реестр инструментов <code>_FakeToolRegistry</code>, имитирующий нестабильный инструмент <code>flaky_tool</code>, который падает при первом вызове и успешно выполняется при втором. Агент <code>ReActAgent</code> настроен с тестовой конфигурацией <code>AppConfig</code>, включающей временные пути и заглушки для внешних зависимостей. Метод <code>_call_openai</code> заменяется моком, который последовательно возвращает два вызова инструмента, а затем завершающее сообщение без инструментов. Тест убеждается, что агент не прерывается при первой ошибке и в итоге достигает статуса <code>ok</code> или <code>partial</code> с ожидаемым выводом <code>"done"</code>.</p>
<p>Устанавливает путь к корню репозитория, чтобы модули верхнего уровня (например, <code>bot.py</code>, <code>config.py</code>) были доступны для импорта в тестах. Добавляет корневую директорию проекта в <code>sys.path</code>, если она ещё не присутствует. Используется в тестовых файлах для корректного разрешения зависимостей без необходимости установки пакета.</p>
<p>Модуль содержит тесты для функций <code>parse_dotenv</code> и <code>load_dotenv</code> из <code>dotenv_loader</code>, а также проверку интеграции загрузки переменных окружения при чтении конфигурации. Основное назначение — проверка корректности разбора <code>.env</code>-файлов с учётом комментариев, кавычек, экранирования и существующих переменных окружения. Ключевые сценарии включают: разбор базовых значений, обработку пробелов и хэшей, поведение при наличии уже установленных переменных (<code>override=False</code>/<code>True</code>) и автоматическую загрузку <code>.env</code> из директории с конфигурационным файлом. Используются временные пути (<code>tmp_path</code>) и моки окружения (<code>monkeypatch</code>) для изолированного тестирования.</p>
<p>Тест-функции для проверки корректности работы метода <code>_trim_fetch_output</code> из модуля <code>helpers</code>. Основное назначение — убедиться, что вывод обрезается до допустимого размера (<code>FETCH_MAX_CHARS</code>, не более 80k символов) с добавлением уведомления об обрезании, если исходный текст превышает лимит. Первый тест проверяет обрезание и наличие маркера "обрезано" в строке, второй — что короткие строки остаются без изменений. Используется для регрессионной проверки поведения при обработке больших объёмов данных.</p>
<p>Файл содержит тесты для функций хранения и управления проектным планом в модуле <code>manager_store</code>. Проверяется корректность сохранения, загрузки, архивирования и удаления объекта <code>ProjectPlan</code> с использованием временной директории (<code>tmp_path</code>). В тесте участвуют сущности <code>ProjectPlan</code>, <code>ProjectAnalysis</code> и <code>DevTask</code>. Основные проверки включают: полноту данных после сохранения и загрузки, изменение статуса при архивировании, отсутствие плана после архивации и идемпотентность операции удаления. Ключевые параметры — путь к рабочей директории и статус при архивации.</p>
<p>Тест проверяет, что значение таймаута в профиле по умолчанию установлено в 240 секунд (240 000 миллисекунд). Загружает конфигурацию из примера файла <code>config_example.yaml</code>, инициализирует реестр инструментов и строит профиль по умолчанию. Основная проверка — соответствие атрибута <code>timeout_ms</code> объекта профиля ожидаемому значению. Использует фикстуры и компоненты: <code>load_config</code>, <code>ToolRegistry</code>, <code>build_default_profile</code>.</p>
<p>Тест проверяет, что при суммировании длинного текста (5000 символов) с ограничением по длине результата (<code>max_chars=500</code>) используется указанный в конфигурации <em>крупный</em> модельный параметр <code>openai_big_model</code>. Создаётся временная конфигурация <code>AppConfig</code> с моком OpenAI-клиента, который фиксирует, какая модель была вызвана. Убеждается, что в запросе к API использовалась модель <code>big-model</code>, а не <code>openai_model</code>. Тест использует <code>monkeypatch</code> для подмены клиента и <code>asyncio</code> для асинхронного выполнения.</p>
<p>Тест проверяет сохранение и восстановление состояния <code>SessionManager</code> при включённом режиме менеджера. Использует временный путь (<code>tmp_path</code>) для изолированного тестирования файловой системы. Загружает конфигурацию из примера <code>config_example.yaml</code>, настраивает путь к состоянию (<code>state_path</code>) и рабочую директорию. Создаёт сессию с включённым <code>manager_enabled</code> и выключенным <code>agent_enabled</code>, затем сохраняет её через <code>_persist_sessions()</code>. После инициализации нового экземпляра <code>SessionManager</code> с теми же настройками проверяет, что сессия корректно восстановлена и флаг <code>manager_enabled</code> сохранён. Основные сущности: <code>SessionManager</code>, <code>Session</code>, конфигурация <code>cfg</code>, временные файлы. Ключевые параметры: <code>state_path</code>, <code>workdir</code>, <code>manager_enabled</code>.</p>
<p>Тест проверяет, что агент корректно обрабатывает ограничение по максимальному количеству итераций, возвращая частичный результат. Используется фиктивная конфигурация <code>AppConfig</code> с временной директорией и моком реестра инструментов <code>_FakeToolRegistry</code>, который всегда возвращает успешный непустой результат. Метод <code>_call_openai</code> заменяется заглушкой, принудительно генерирующей вызов инструмента на каждом шаге, чтобы гарантировать достижение лимита итераций. В результате ожидается статус <code>partial</code>, а в выводе — сообщение о превышении лимита и упоминание последних вызовов инструментов. Основная цель — убедиться, что агент не завершается с ошибкой, а возвращает промежуточные результаты при достижении порога итераций.</p>
<p>Тест-функция, проверяющая поведение метода <code>_interrupt_before_close</code> в приложении бота. Назначение — убедиться, что прерывание одной сессии не влияет на другие активные сессии. Создаёт экземпляр <code>BotApp</code> с временной конфигурацией, запускает два асинхронных задачи-заглушки, ассоциированных с разными сессиями. Методом <code>_interrupt_before_close</code> прерывается только первая сессия, после чего проверяется, что соответствующая задача отменена, а вторая задача остаётся активной. Используются временные пути (<code>tmp_path</code>) для изоляции теста. В конце выполняется корректная очистка задач через <code>cancel()</code> и подавление исключений при завершении.</p>
<p>Тест проверяет корректность работы функции <code>execute_shell_command</code> из модуля <code>agent.tooling.helpers</code> при выполнении команды без вывода. Имитирует выполнение команды с помощью <code>subprocess.run</code>, возвращая заглушку с кодом возврата 1 и пустым выводом. Проверяет, что результат содержит информацию об ошибке, включая отсутствие вывода, упоминание команды (<code>command=</code>) и рабочей директории (<code>cwd=</code>), а также корректный код возврата в метаданных. Использует <code>monkeypatch</code> для подмены <code>subprocess.run</code> и <code>asyncio.run</code> для запуска асинхронной функции.</p>
<p>Тест проверяет, что при отправке большого объёма вывода (<code>output</code>) метод <code>send_output</code> передаёт в функцию суммаризации только последние 50 000 символов (хвост). Используется фиктивная реализация суммаризации и заглушки для отправки сообщений в Telegram, чтобы избежать реальных сетевых вызовов и операций ввода-вывода. Настройка <code>summary_max_chars=200</code> в <code>DefaultsConfig</code> игнорируется, так как логика теста сосредоточена на ограничении в 50 000 символов для передачи в <code>summarize_text_with_reason</code>. Тест подтверждает корректность обрезки вывода по хвосту при превышении размера.</p>
<p>Тест проверяет, что бот отправляет текстовый превью вывода, даже если генерация HTML-версии задерживается. Используется временная директория и моки для изоляции. Конфигурация <code>AppConfig</code> инициализируется с минимальными настройками, включая dummy-инструмент и отключённый MCP. Основное поведение тестируется при вызове <code>send_output</code> с <code>force_html=True</code>. Моки имитируют быстрое создание HTML-файла, но блокируют выполнение <code>ansi_to_html</code> через <code>asyncio.Event</code>. Установлены нулевые таймауты для <code>_SUMMARY_WAIT_FOR_HTML_S</code> и <code>_SUMMARY_TIMEOUT_S</code>, чтобы превью отправлялось немедленно. События отправки сообщений фиксируются в список <code>events</code>. Проверяется, что сообщение (превью) было отправлено до завершения генерации HTML. Задача отменяется для корректного завершения.</p>
<p>Файл содержит тестовую функцию <code>test_send_message_retries_and_records</code>, проверяющую поведение метода <code>send_message</code> класса <code>TelegramIO</code>. Тест убеждается, что при временных сетевых ошибках (<code>NetworkError</code>) происходит повторная попытка отправки сообщения, и после успешной отправки вызывается функция записи идентификатора сообщения.</p>
<p>Ключевые сущности:
- <code>TelegramIO</code> — класс, инкапсулирующий взаимодействие с Telegram API.
- <code>record_message</code> — колбэк, вызываемый для сохранения соответствия <code>chat_id</code> и <code>message_id</code>.
- <code>_Bot</code> — мок бота, имитирующий <code>send_message</code> с выбросом <code>NetworkError</code> первые два раза.
- <code>asyncio.sleep</code> заменяется на заглушку <code>_fast_sleep</code>, чтобы ускорить повторные попытки.</p>
<p>Важные настройки:
- Повторные попытки отправки сообщения при <code>NetworkError</code>.
- Колбэк <code>record_message</code> фиксирует успешную отправку.
- Используется <code>monkeypatch</code> для изоляции теста и контроля поведения <code>asyncio.sleep</code>.</p>
<p>Тест проверяет:
- Метод <code>send_message</code> вызывается ровно 3 раза (2 неудачи, 1 успех).
- После успеха возвращается объект сообщения с <code>message_id = 123</code>.
- Колбэк <code>record_message</code> корректно вызывается с аргументами <code>(777, 123)</code>.</p>
<p>Файл содержит юнит-тесты для функций <code>format_manager_status</code> и <code>needs_resume_choice</code> из модуля управления агентом.  </p>
<p><strong>Назначение</strong>:<br/>
Проверка корректности форматирования статуса менеджера проекта с отображением эмодзи, зависимостей и комментариев к задачам, а также логики определения необходимости подтверждения возобновления работы.</p>
<p><strong>Ключевые сущности</strong>:<br/>
- <code>ProjectPlan</code> — описание плана проекта с задачами.<br/>
- <code>DevTask</code> — задача разработки с полями: статус, зависимости, попытки выполнения, комментарии ревью.<br/>
- <code>format_manager_status</code> — формирует читаемое представление статуса плана (с эмодзи ✅/❌, зависимостями, комментариями).<br/>
- <code>needs_resume_choice</code> — определяет, требуется ли пользовательское подтверждение для возобновления работы (в зависимости от флага <code>auto_resume</code> и содержания ввода <code>user_text</code>).</p>
<p><strong>Важные настройки/параметры</strong>:<br/>
- <code>max_comment_chars</code> — ограничение длины отображаемых комментариев (в тесте используется 1000).<br/>
- <code>auto_resume</code> — флаг автоматического возобновления без подтверждения.<br/>
- <code>user_text</code> — ввод пользователя, влияющий на решение о возобновлении (игнорируется при <code>auto_resume=True</code>, проверяется на пустоту).</p>
<p>Тестовый файл, проверяющий логику перепланирования оркестратора после выполнения каждого шага. Основная цель — убедиться, что при динамическом расширении плана (например, добавлении новых шагов) оркестратор корректно отслеживает выполненные шаги и не выполняет их повторно, несмотря на перепланирование.  </p>
<p>Используются фиктивные реализации <code>plan_steps</code> и <code>_execute_step</code> для моделирования поведения: план изначально содержит два шага, затем расширяется до трёх. Проверяется, что:
- Все шаги выполнены ровно один раз.
- Общее количество вызовов планирования — три (начальный план + после каждого из двух первых шагов).
- Результат выполнения включает ожидаемые выходные данные по каждому шагу.</p>
<p>Ключевые сущности: <code>OrchestratorRunner</code>, <code>PlanStep</code>, <code>ExecutorResponse</code>.<br/>
Настройки конфигурации инициализируются с временными путями для изоляции теста. Используется <code>monkeypatch</code> для подмены асинхронных вызовов.</p>
<p>Тест проверяет, что состояние (state) корректно изолируется по идентификатору сессии. Используется временный файл <code>state.json</code>, в котором определены две сессии — <code>s1</code> и <code>s2</code> — с общими значениями <code>tool</code> и <code>workdir</code>, но разными <code>resume_token</code>, <code>summary</code>, <code>updated_at</code> и <code>name</code>. Функция <code>load_state</code> загружает данные и проверяет наличие обоих сеансов. Функция <code>get_state</code> извлекает состояние по пути, инструменту, рабочей директории и идентификатору сессии. При указании <code>session_id="s1"</code> возвращается соответствующее состояние с <code>resume_token == "r1"</code>. При отсутствии <code>session_id</code> и совпадении <code>tool</code> и <code>workdir</code> у нескольких сессий возвращается <code>None</code>, чтобы избежать неоднозначности. Тест подтверждает, что состояние изолировано и разрешается однозначно только при явном указании идентификатора сессии.</p>
<p>Тест проверяет корректность отправки вывода в Telegram с учётом параллельной обработки HTML и аннотаций. Настраивается тестовое окружение с временной директорией и моками для <code>_send_message</code>, <code>_send_document</code>, <code>summarize_text_with_reason</code>, <code>ansi_to_html</code>, <code>make_html_file</code> и <code>asyncio.to_thread</code>. Цель — убедиться, что при отправке большого объёма вывода (5000 символов) срабатывает логика параллельной генерации HTML-представления и краткого резюме. Проверяется порядок событий: сначала сообщение с заголовком, затем документ (HTML-файл), затем сообщение с резюме. Используются <code>asyncio.Event</code> для синхронизации между задачами и принудительного контроля очерёдности выполнения. Убеждается, что HTML-генерация не блокирует отправку резюме, и обе задачи выполняются конкурентно.</p>
<p>Тест-файл для проверки функции <code>_try_parse_review</code> класса <code>ManagerOrchestrator</code>. Проверяет корректность разбора текстового ответа, содержащего JSON с результатами ревью кода. Основные проверяемые сценарии: валидные JSON-ответы с флагами <code>approved: true/false</code>, извлечение данных из JSON, обёрнутого в Markdown-разметку (<code>```json</code>), обработка текста с дополнительным содержимым вокруг JSON, а также случаи с отсутствующими обязательными полями (например, <code>approved</code>) или некорректным форматом. Обязательным полем для успешного разбора является <code>approved</code>, остальные поля (например, <code>summary</code>, <code>comments</code>, <code>files_reviewed</code>, <code>tests_passed</code>) могут отсутствовать или иметь значение <code>null</code>. В случае ошибки парсинга или отсутствия ключевых полей возвращается <code>None</code>.</p></div>
</div>
</div>
<footer class="col-md-12">
<hr/>
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
</footer>
<script src="js/bootstrap.bundle.min.js"></script>
<script>
            var base_url = ".",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
<script src="js/base.js"></script>
<script src="search/main.js"></script>
<div aria-hidden="true" aria-labelledby="searchModalLabel" class="modal" id="mkdocs_search_modal" role="dialog" tabindex="-1">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<h4 class="modal-title" id="searchModalLabel">Search</h4>
<button aria-label="Close" class="btn-close" data-bs-dismiss="modal" type="button"></button>
</div>
<div class="modal-body">
<p>From here you can search these documents. Enter your search terms below.</p>
<form>
<div class="form-group">
<input class="form-control" id="mkdocs-search-query" placeholder="Search..." title="Type search term here" type="search"/>
</div>
</form>
<div data-no-results-text="No results found" id="mkdocs-search-results"></div>
</div>
<div class="modal-footer">
</div>
</div>
</div>
</div><div aria-hidden="true" aria-labelledby="keyboardModalLabel" class="modal" id="mkdocs_keyboard_modal" role="dialog" tabindex="-1">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
<button aria-label="Close" class="btn-close" data-bs-dismiss="modal" type="button"></button>
</div>
<div class="modal-body">
<table class="table">
<thead>
<tr>
<th style="width: 20%;">Keys</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="help shortcut"><kbd>?</kbd></td>
<td>Open this help</td>
</tr>
<tr>
<td class="next shortcut"><kbd>n</kbd></td>
<td>Next page</td>
</tr>
<tr>
<td class="prev shortcut"><kbd>p</kbd></td>
<td>Previous page</td>
</tr>
<tr>
<td class="search shortcut"><kbd>s</kbd></td>
<td>Search</td>
</tr>
</tbody>
</table>
</div>
<div class="modal-footer">
</div>
</div>
</div>
</div>
</body>
</html>
