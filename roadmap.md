# Сравнение с аналогами и дорожная карта улучшений

Ниже — краткое сравнение текущего проекта `cli-proxy` с наиболее близкими по идее решениями и предложение дорожной карты развития.

## Аналоги и позиционирование

### 1) Telecode
Telecode — «мост» между Telegram и локальными AI‑CLI (Codex/Claude) через webhook/FastAPI и туннель (ngrok). Фокус — быстрый старт и переключение движка. citeturn0search4

**Отличия cli-proxy**
- У вас процесс‑локальный Telegram‑бот без отдельного web‑сервера и туннеля (polling), проще для локальной работы.
- Сильнее про «сессию как объект»: очередь, resume‑токен, состояние, inline‑меню управления.
- Встроенный Git‑контур (inline‑меню + операции) и HTML‑лог отправкой в бот.

### 2) telegram-mcp-server
Проект MCP‑сервера для удалённого управления Codex/Claude через Telegram, с режимом «долгого ожидания», управлением сессиями и файловыми операциями. citeturn0search0

**Отличия cli-proxy**
- У вас прямой контроль локальной CLI‑сессии, не MCP.
- Зато есть более плотная интеграция с локальным файловым деревом, Git‑операции и подсказки/summary.
- В MCP‑решении есть «unattended mode» и развитый контекст MCP‑инструментов.

### 3) vibego
CLI‑утилита, которая через Telegram управляет Codex/ClaudeCode, включает мастер‑бота, логирование, хранение состояния в `~/.config/vibego/`. citeturn0search3turn0search5

**Отличия cli-proxy**
- У вас более «прикладная» Telegram‑логика (inline‑меню, ручное управление сессиями/очередью).
- В vibego — выделенная инфраструктура (master‑service), свои команды и сценарии.

### 4) telegram-mcp
MCP‑сервер для Telegram: предоставляет единую команду `interact` и подключение к хостингу, без настройки токена бота. citeturn0search1

**Отличия cli-proxy**
- У вас полный контроль локально и отсутствие зависимости от хостинга.
- Но нет «универсального MCP‑слоя», который может подключаться к разным агентам как инструменты.

### 5) mcp-telegram
MCP‑сервер на Telethon (MTProto) для более широких операций с Telegram: поиск, редактирование, медиа и т.п. citeturn0search2

**Отличия cli-proxy**
- У вас акцент на прокси‑управление CLI и сессиями, а не на богатую Telegram‑автоматизацию.

## Дорожная карта улучшений

## Быстрое сравнение по фичам

| Фича | cli-proxy | Telecode | telegram-mcp-server | vibego | telegram-mcp | mcp-telegram |
| --- | --- | --- | --- | --- | --- | --- |
| Локальный polling‑бот без сервера | ✅ | ❌ (webhook/tunnel) | ❌ | ✅ | ✅ | ✅ |
| Управление сессиями (use/rename/close) | ✅ | ✅ | ✅ | ✅ | ⚠️ | ⚠️ |
| Очередь задач на сессию | ✅ | ⚠️ | ✅ | ⚠️ | ⚠️ | ❌ |
| Resume‑токен/восстановление | ✅ | ✅ | ✅ | ✅ | ⚠️ | ❌ |
| Git‑операции из бота | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
| HTML‑лог выводов | ✅ | ❌ | ⚠️ | ⚠️ | ❌ | ❌ |
| MCP‑совместимость | ❌ | ❌ | ✅ | ❌ | ✅ | ✅ |
| Богатые Telegram‑операции (MTProto) | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |

Примечания: ⚠️ — частично/по косвенным признакам, не ключевая функция.

## Привязка дорожной карты к модулям

### Фаза 1: Надёжность и UX
1) Надёжная очередь и сериализация
   - `bot.py` (run_prompt / dispatch сообщений)
   - `session.py` (SessionManager, очередь)
2) Единый журнал событий
   - `bot.py` (перехват исключений, логирование)
   - `state.py` (ошибки чтения/записи)
3) Понятный статус занятости
   - `session_ui.py` (sess_status)
   - `git_ops.py` (git_busy/git_conflict)
4) Улучшение summary UX
   - `summary.py` (tail‑digest/фокус на конце)

### Фаза 2: Интеграции и возможности
1) MCP‑бридж (опционально)
   - новый модуль `mcp_bridge.py`
   - `bot.py` (переключение режима)
2) Умный Git‑workflow
   - `git_ops.py` (шаблоны, агрегированные команды)
3) Файловые операции
   - `dirs_ui.py` (просмотр/скачивание)
   - `bot.py` (отправка файлов)
4) Шаблоны задач
   - `command_registry.py` (preset‑команды)
   - `bot.py` (обработчики)

### Фаза 3: Масштабирование
1) Мульти‑контексты/профили
   - `config.py` (мульти‑профили)
   - `state.py` (namespacing состояния)
2) Наблюдаемость
   - `bot.py` (метрики)
   - новый модуль `metrics.py`
3) Безопасность
   - `bot.py` (ACL/роль‑политики)
   - `utils.py` (валидация путей)

### Фаза 1: Надёжность и UX (1–2 недели)
1) **Надёжная очередь и сериализация**  
   - Ввести «лок» на выполнение команд сессии (чтобы исключить гонки при `create_task` и параллельных callback).  
   - Приоритеты очереди: «ручные» команды выше фоновых.
2) **Единый журнал событий**  
   - Логировать ошибки I/O (state/session persistence) в файл + краткое уведомление в чат.  
   - Добавить идентификатор сообщения/команды к каждому запуску.
3) **Понятный статус занятости**  
   - Разделить «CLI busy» и «Git busy» в статусе сессии + время ожидания.
4) **Улучшение summary UX**  
   - Добавить метку «ключевые события хвоста» и короткий «tail‑digest» (1–2 пункта).

### Фаза 2: Интеграции и возможности (2–4 недели)
1) **MCP‑бридж (опционально)**  
   - Добавить MCP‑endpoint как альтернативный режим работы (аналогично telegram‑mcp‑server).  
   - Это откроет совместимость с внешними клиентами, не ломая polling‑архитектуру.
2) **Умный Git‑workflow**  
   - Шаблоны «PR‑сводка», «git status + diff + suggested commit» в один клик.  
   - Авто‑детект конфликтов и шаги по их разрешению.
3) **Файловые операции**  
   - Просмотр/скачивание файлов по inline‑меню (как минимум top‑N изменённых).
4) **Шаблоны задач**  
   - Preset‑кнопки «тесты», «линт», «сборка», «рефакторинг» с параметрами.

### Фаза 3: Масштабирование (4–8 недель)
1) **Мульти‑рабочие контексты**  
   - Разделение «профилей» (prod/dev) и изоляция конфигов/логов.
2) **Наблюдаемость**  
   - Метрики (время ответа, длина очереди, средний размер output, ошибки).
3) **Безопасность**  
   - Политики доступа (роль/команды), журнал доступа.  
   - Ограничение выполнения потенциально опасных команд.

## Как это позиционировать
`cli-proxy` сейчас выглядит как «локальный control‑center для AI‑CLI» с сильным упором на сессии и Git.  
Если добавить MCP‑режим, можно закрыть сегмент «универсального удалённого агента» и приблизиться к `telegram-mcp-server`, сохранив вашу ключевую особенность — нативную работу с локальным git‑репозиторием и состоянием сессии.
