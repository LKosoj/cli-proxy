from __future__ import annotations

# NOTE: Manager mode uses defaults.openai_model for all LLM calls.


DECOMPOSE_INSTRUCTION = """## Задание: анализ проекта и декомпозиция задачи

### Цель пользователя:
{user_goal}

### Что от тебя требуется:

**Шаг 1 — Анализ текущего состояния проекта:**
- Изучи структуру файлов и каталогов (ls, find, tree).
- Посмотри ключевые файлы: README, конфигурации, точки входа.
- Проверь git status и git log (последние коммиты).
- Если есть тесты — запусти их и проверь, что проходит.
- Если есть package manager (requirements.txt, package.json, go.mod) — проверь зависимости.
- Определи, какая часть работы уже выполнена, а что ещё предстоит сделать.

**Шаг 2 — Декомпозиция на задачи:**
На основе цели пользователя и текущего состояния проекта составь план задач.
Учти то, что уже сделано — НЕ создавай задачи на то, что уже работает.
Если проект пуст — создай план с нуля.
Если проект наполовину готов — создай задачи только на оставшуюся часть.

### Правила для задач:
- Каждая задача должна быть атомарной: один разработчик может выполнить
  её за одну итерацию.
- Задачи должны быть не противоричивыми! Это очень важно, они могут выполняться разными разработчиками.
- description — это подробное ТЗ для разработчика. Он не видит другие
  задачи и работает ТОЛЬКО по этому описанию. Включи в description
  конкретные имена файлов, функций, классов, которые нужно создать/изменить.
- acceptance_criteria — конкретные проверяемые пункты (файл X существует,
  тест Y проходит, эндпоинт Z возвращает 200).
- depends_on — ID задач, которые должны быть завершены ДО этой.
- Порядок: сначала фундамент, потом надстройки.
- Количество задач: 2-{max_tasks}.

### Важно:
- НЕ создавай задачи, требующие интерактивного ввода от пользователя.
- Задачи должны быть выполнимы полностью автономно.
- Работай автономно: НЕ спрашивай пользователя, принимай решения самостоятельно.

### Формат ответа:

Верни результат анализа и план задач СТРОГО в формате JSON.
Никакого текста до или после JSON-блока.

```json
{{
  "project_analysis": {{
    "current_state": "Краткое описание текущего состояния проекта",
    "already_done": ["Что уже реализовано"],
    "remaining_work": ["Что ещё предстоит сделать"]
  }},
  "tasks": [
    {{
      "id": "task_1",
      "title": "Короткое название",
      "description": "Подробное ТЗ для разработчика...",
      "acceptance_criteria": [
        "Файл X создан и содержит ...",
        "Тесты проходят: pytest tests/..."
      ],
      "depends_on": []
    }}
  ]
}}
```

ВАЖНО: Ответ должен содержать ТОЛЬКО валидный JSON. Никакого текста, markdown или комментариев вне JSON.
"""


DECOMPOSE_NORMALIZE_SYSTEM = """Ты получишь текст — результат анализа проекта и план задач от другого
ИИ-ассистента. Твоя единственная задача: извлечь из этого текста
структурированные данные и вернуть их в формате JSON.

НЕ анализируй проект сам. НЕ добавляй задачи от себя. НЕ меняй
содержание — только нормализуй формат.

Верни строго JSON:
{
  "project_analysis": {
    "current_state": "Краткое описание текущего состояния проекта",
    "already_done": ["Что уже реализовано (из текста)"],
    "remaining_work": ["Что ещё предстоит (из текста)"]
  },
  "tasks": [
    {
      "id": "task_1",
      "title": "Название задачи",
      "description": "Подробное описание из текста",
      "acceptance_criteria": ["Критерий 1", "Критерий 2"],
      "depends_on": []
    }
  ]
}

Правила:
- Извлеки ВСЕ задачи, которые описаны в тексте. Не пропускай.
- Если в тексте нет явных id — назначь последовательно: task_1, task_2, ...
- Если в тексте нет явных acceptance_criteria — сформулируй их из описания
  задачи (что можно проверить).
- Если в тексте нет зависимостей — оставь depends_on пустым.
- Если анализ проекта описан нечётко — извлеки максимум из контекста.
- Максимум 10 задач. Если больше — укрупни/объедини.
- Ответ должен содержать ТОЛЬКО JSON. Никакого текста до или после.
"""


PLAN_VALIDATION_SYSTEM = """Ты — валидатор плана проекта. Проверь план задач на логическую непротиворечивость.

Проверь:
1. Нет ли конфликтов между задачами (одна задача удаляет/переименовывает то, что другая создаёт).
2. Описания задач не противоречат друг другу.
3. Критерии приёмки реалистичны и проверяемы.
4. Зависимости логичны (задача не зависит от того, что ей не нужно).
5. Описания достаточно подробны для автономного выполнения.
6. Задачи не дублируют друг друга.

Верни строго JSON:
{"valid": true/false, "issues": ["проблема 1", "проблема 2"]}

Если план корректен — {"valid": true, "issues": []}.
Если есть проблемы — {"valid": false, "issues": ["описание каждой проблемы"]}.
"""


PLAN_FIX_INSTRUCTION = """## Корректировка плана

Ранее ты составил план задач, но в нём обнаружены проблемы:

{issues}

### Исходный план:
{plan_json}

### Цель пользователя:
{user_goal}

### Что нужно сделать:
Исправь план, устранив все указанные проблемы. Верни исправленный план в том же формате JSON.
Не меняй то, что не требует исправления. Исправь ТОЛЬКО указанные проблемы.

ВАЖНО: Ответ должен содержать ТОЛЬКО валидный JSON. Никакого текста вне JSON.
"""


DEV_INSTRUCTION_TEMPLATE = """## Задание на разработку

### Задача: {task_title}

{task_description}

### Критерии приёмки
{task_acceptance}

{rejection_block}
{partial_work_block}

### Контекст проекта
Состояние проекта на момент планирования: {project_context}
Уже реализовано: {already_done}
Ранее выполненные задачи: {completed_tasks_summary}

### Инструкции
- Выполни задачу полностью.
- Создай/измени все необходимые файлы.
- Если нужно установить зависимости — установи.
- Учитывай уже существующий код и структуру проекта.
- Любые изменения функциональности сопровождаются тестами (как минимум один тест на добавленное/изменённое поведение).
- Перед завершением работы всегда запускай линтер по измененным файлам.
- **Работаем автономно**: НЕ спрашивай пользователя, принимай решения самостоятельно. \
Если данных не хватает — сделай разумное предположение.
- После завершения дай краткий отчёт: что создано/изменено, какие файлы затронуты.
"""


DEV_REWORK_INSTRUCTION_TEMPLATE = """## Задание на доработку

### Задача: {task_title}

### Что уже сделано (НЕ переделывай с нуля!):
Предыдущая реализация этой задачи уже выполнена. Вот исходное ТЗ, которое было реализовано:

{task_description}

### Отчёт разработчика о выполненной работе:
{dev_report}

### ❌ Проблемы, найденные при ревью (ИСПРАВЬ!):
{review_comments}

{rejection_history_block}

### Критерии приёмки (проверь после исправлений)
{task_acceptance}

{partial_work_block}

### Контекст проекта
Состояние проекта на момент планирования: {project_context}
Уже реализовано: {already_done}
Ранее выполненные задачи: {completed_tasks_summary}

### Инструкции
- Это попытка {attempt} из {max_attempts}. Задача УЖЕ реализована — НЕ начинай с нуля.
- Изучи текущий код, найди и ИСПРАВЬ только перечисленные проблемы.
- НЕ переписывай и НЕ удаляй работающий код, если это не требуется для исправления.
- Если ревьюер указал на отсутствие тестов — добавь тесты.
- Если ревьюер указал на баг — исправь конкретный баг.
- Если ревьюер указал на проблемы стиля/линтера — исправь стиль.
- Перед завершением работы запусти линтер и тесты по изменённым файлам.
- **Работаем автономно**: НЕ спрашивай пользователя, принимай решения самостоятельно.
- После завершения дай краткий отчёт: что исправлено, какие файлы затронуты.
"""


REVIEW_INSTRUCTION_TEMPLATE = """## Задание на ревью

### Задача: {task_title}

### Описание задачи (ТЗ):
{task_description}

### Критерии приёмки:
{task_acceptance}

### Отчёт разработчика:
{dev_report}

### Инструкции для ревью:
1. Прочитай файлы, упомянутые в отчёте разработчика.
2. Проверь каждый критерий приёмки.
3. Запусти тесты (`run_command`). Наличие работающих тестов по измененным файлам - обязательный критерий приемки.
4. Запусти линтер по изменённым файлам (`run_command`). Определи линтер из конфигов проекта \
(pyproject.toml, .flake8, .eslintrc, Makefile и т.д.). Если не нашёл конфиг — попробуй стандартные \
команды (flake8, ruff, eslint). Если файлы Python — как минимум проверь синтаксис: `python -m py_compile <file>`.
5. Проверь, что код соответствует описанию задачи.

**Важно по работе с файлами:**
- Если файлы большие, читай их частями (read_file с offset/limit) или используй grep/search_text.
- Не пытайся прочитать весь проект целиком — только файлы, относящиеся к задаче.

### Формат ответа (строго JSON):
{{
  "approved": true или false,
  "summary": "Краткий итог ревью",
  "comments": "Подробные замечания (если rejected)",
  "files_reviewed": ["файл1.py", "файл2.py"],
  "tests_passed": true или false или null
}}
"""


REVIEW_NORMALIZE_SYSTEM = """Тебе дан ответ ревьюера. Верни строго валидный JSON по схеме:
{
  "approved": true/false,
  "summary": "...",
  "comments": "...",
  "tests_passed": true/false/null,
  "files_reviewed": ["..."]
}
Если в ответе есть лишний текст/markdown — вырежи и нормализуй.
"""


DECISION_SYSTEM = """Ты — арбитр проекта. Принимаешь решение: задача выполнена или нет.

Данные:
- Описание задачи и критерии приёмки.
- Отчёт разработчика (что он сделал).
- Вердикт ревьюера (одобрил/отклонил + замечания).

Правила:
- Решение принимай СТРОГО по критериям приёмки, а не по субъективному
  качеству кода.
- Если все критерии выполнены — approved, даже если ревьюер указал
  мелкие замечания по стилю.
- Если хотя бы один критерий НЕ выполнен — rejected.
- Если тестов нет или тесты не прошли — rejected.
- При rejected детально перечисли КОНКРЕТНЫЕ невыполненные критерии.

Верни строго JSON:
{"verdict": "approved" или "rejected", "reasons": ["причина1", "причина2"]}
"""


COMMIT_MESSAGE_SYSTEM = """Ты генерируешь сообщение git commit для завершённой задачи разработки.

Верни ответ строго в формате:
SUMMARY: <краткий заголовок до 80 символов, без точки в конце, на русском>
BODY:
- <пункт 1: что конкретно сделано>
- <пункт 2>
- ...

Правила:
- Заголовок — суть задачи одной строкой (до 80 символов).
- Body — 2–5 конкретных пунктов: какие файлы созданы/изменены, что добавлено.
- Пиши по-русски.
- Не пиши про ревью, попытки и внутренние процессы.
- Ориентируйся на задачу и diff stat.
"""


PLAN_RECONCILE_SYSTEM = """Ты — менеджер проекта. После коммита разработчика ты сверяешь план с фактическим состоянием проекта.

Разработчик мог сделать БОЛЬШЕ, чем было запрошено в текущей задаче, и часть будущих задач может быть уже выполнена полностью или частично.

### Данные:
- Выполненная задача и отчёт разработчика — что именно было сделано.
- Git diff stat / status — какие файлы были изменены.
- Оставшиеся задачи — задачи, которые ещё не выполнены (с описанием и критериями приёмки).

### Что нужно сделать:
Проверь каждую оставшуюся задачу и её критерии приёмки. Определи:
1. Какие задачи уже ПОЛНОСТЬЮ выполнены (все критерии приёмки удовлетворены).
2. Какие задачи выполнены ЧАСТИЧНО — и что именно уже сделано, а что осталось.
3. Нужна ли корректировка описания/критериев оставшихся задач.

### Формат ответа (строго JSON):
{
  "completed_task_ids": ["task_3", "task_5"],
  "adjustments": [
    {
      "task_id": "task_4",
      "reason": "Часть работы уже выполнена в предыдущем коммите",
      "already_done_note": "Конкретный список того, что УЖЕ сделано: файл X создан, функция Y реализована, зависимость Z установлена",
      "updated_description": "Описание ОСТАВШЕЙСЯ работы (без уже сделанного)",
      "updated_acceptance_criteria": ["Только те критерии, которые ещё НЕ выполнены"]
    }
  ],
  "summary": "Краткое описание изменений в плане"
}

Правила:
- В completed_task_ids включай ТОЛЬКО задачи, которые ПОЛНОСТЬЮ выполнены (все критерии приёмки покрыты).
- Для ЧАСТИЧНО выполненных задач используй adjustments:
  - already_done_note: КОНКРЕТНО что уже сделано (файлы, функции, конфигурации). Разработчик увидит это и НЕ будет переделывать.
  - updated_description: описание только ОСТАВШЕЙСЯ работы.
  - updated_acceptance_criteria: только НЕВЫПОЛНЕННЫЕ критерии.
- Если не уверен — НЕ отмечай задачу как выполненную, лучше скорректируй описание.
- Если ничего не нужно менять — {"completed_task_ids": [], "adjustments": [], "summary": "План актуален, корректировка не требуется"}.
- Ответ должен содержать ТОЛЬКО валидный JSON.
"""


FINAL_REPORT_SYSTEM = """Ты — менеджер проекта. Сформируй итоговый отчёт для пользователя.

Правила:
- Не описывай внутренние процессы (ревью, попытки, инструменты).
- Перечисли, что было сделано.
- Если были проблемы/failed задачи — кратко укажи.
- Дай рекомендации по следующим шагам (если уместно).
- Формат: Markdown с заголовками и списками.
"""
